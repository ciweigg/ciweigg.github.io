<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[3-hexo使用说明]]></title>
      <url>/2017/12/26/3-hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<blockquote>
<p>下面如果没有特殊说明， <code>_config.yml</code> 都指主题配置文件，即 <code>3-hexo</code> 目录下</p>
</blockquote>
<h2 id="自定义首页"><a href="#自定义首页" class="headerlink" title="自定义首页"></a>自定义首页</h2><p>可查看这篇文章： </p>
<h2 id="blog快捷键"><a href="#blog快捷键" class="headerlink" title="blog快捷键"></a>blog快捷键</h2><p>可查看这篇文章： </p>
<h2 id="更换头像"><a href="#更换头像" class="headerlink" title="更换头像"></a>更换头像</h2><p>两种方式：</p>
<ol>
<li>替换 <code>source/img/avatar.jpg</code> 图片。</li>
<li>修改 <code>_config.yml</code> 中头像的配置记录</li>
</ol>
<pre><code class="xml"># 你的头像url
avatar: /img/avatar.jpg
favicon: /img/avatar.jpg
</code></pre>
<h2 id="设置链接图标"><a href="#设置链接图标" class="headerlink" title="设置链接图标"></a>设置链接图标</h2><p>如下，如果没有连接，则不展示图标。</p>
<pre><code class="xml">#链接图标，链接为空则不显示
link:
  rss: /atom.xml
  github: https://github.com/yelog
  facebook: https://www.facebook.com/faker.tops
  twitter:
  linkedin:
  instagram:
  reddit: https://www.reddit.com/user/yelog/
  weibo: http://weibo.com/u/2307534817
  email: jaytp@qq.com
</code></pre>
<h2 id="配置评论系统"><a href="#配置评论系统" class="headerlink" title="配置评论系统"></a>配置评论系统</h2><p>目前添加了三种评论系统 <strong>disqus、多说、网易云跟帖</strong></p>
<blockquote>
<p><code>日志：</code> 2017-03-21：多说将于2017-06-01正式关停服务</p>
</blockquote>
<h3 id="启用评论"><a href="#启用评论" class="headerlink" title="启用评论"></a>启用评论</h3><p>以 <code>disqus</code> 为例；</p>
<ol>
<li>关掉其他两个评论（设置on: false）</li>
<li>启用 <code>disqus</code> ,设置on: true</li>
<li>登陆 <code>disqus</code> 注册，得到shortname，填入shortname。</li>
<li>重启 <code>hexo</code>。</li>
</ol>
<h3 id="meta区显示评论数"><a href="#meta区显示评论数" class="headerlink" title="meta区显示评论数"></a>meta区显示评论数</h3><p>开启设置 <code>_config.yml</code></p>
<pre><code class="xml">comment_count: true
# 文章标题下方显示评论数
</code></pre>
<p><img src="http://oncj6b2vl.bkt.clouddn.com/FlDHXpVnJ-ECFCehRBoKkQMlqj_R.png" alt="开启效果"></p>
<h3 id="评论区预加载"><a href="#评论区预加载" class="headerlink" title="评论区预加载"></a>评论区预加载</h3><p>开启设置 <code>_config.yml</code></p>
<pre><code class="xml">preload_comment: false
</code></pre>
<ol>
<li>false: 当点击评论条等区域时再加载评论模块</li>
<li>true: 页面加载时加载评论区<br><img src="http://oncj6b2vl.bkt.clouddn.com/FrYn2xsPMLBizQZ_p_mCa-hJYTG_.png" alt="关闭效果"></li>
</ol>
<h2 id="样式设置"><a href="#样式设置" class="headerlink" title="样式设置"></a>样式设置</h2><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>首先要关闭hexo根目录下<code>_config.yml</code>中的高亮设置：</p>
<pre><code class="xml">highlight:
  enable: false
</code></pre>
<p>配置主题下<code>_config.yml</code>中的高亮设置：<br>可以根据提示，配置喜欢的高亮主题</p>
<pre><code class="xml">highlight:
  on: true # true开启代码高亮
  lineNum: true # true显示行号
  theme: darcula
# 代码高亮主题,效果可以查看 https://highlightjs.org/static/demo/
# 支持主题：
# sublime : 参考sublime的高亮主题
# darcula : 参考idea中的darcula的主题
# atom-dark : 参考Atom的dark主题
# atom-light : 参考Atom的light主题
# github : 参考GitHub版的高亮主题
# github-gist : GitHub-Gist主题
# brown-paper : 牛皮纸效果
# gruvbox-light : gruvbox的light主题
# gruvbox-dark ： gruvbox的dark主题
# rainbow :
# railscasts :
# sunburst :
# kimbie-dark :
# kimbie-light :
# school-book : 纸张效果
</code></pre>
<h3 id="表格样式"><a href="#表格样式" class="headerlink" title="表格样式"></a>表格样式</h3><p>目前提供了3中样式，修改 <code>_config.yml</code></p>
<pre><code class="xml">table: green_title
# table 的样式
# 为空时类似github的table样式
# green 绿色样式
# green_title 头部为青色的table样式
</code></pre>
<h3 id="文章列表的hover样式"><a href="#文章列表的hover样式" class="headerlink" title="文章列表的hover样式"></a>文章列表的hover样式</h3><p>鼠标移入的背景色和文字颜色变动，设置 <code>_config.yml</code></p>
<pre><code class="xml">#文章列表 鼠标移上去的样式, 为空时使用默认效果
article_list:
  hover:
    background: &#39;#e2e0e0&#39;  # 背景色:提供几种：&#39;#c1bfc1&#39;  &#39;#fbf4a8&#39;
    color:     # 文字颜色 提供几种：&#39;#ffffff&#39;
# 注意：由于颜色如果包含#，使用单引号 &#39; 引起来
</code></pre>
<h2 id="开启字数统计"><a href="#开启字数统计" class="headerlink" title="开启字数统计"></a>开启字数统计</h2><ol>
<li>开启此功能需先安装插件，在 hexo根目录 执行 <code>npm i hexo-wordcount --save</code></li>
<li>修改 <code>_config.yml</code></li>
</ol>
<pre><code class="xml">word_count: true
</code></pre>
<h2 id="多作者模式"><a href="#多作者模式" class="headerlink" title="多作者模式"></a>多作者模式</h2><p>可查看这篇文章： </p>
<h2 id="文章排序及置顶"><a href="#文章排序及置顶" class="headerlink" title="文章排序及置顶"></a>文章排序及置顶</h2><p>可查看这篇文章： </p>
<h2 id="关于写文章"><a href="#关于写文章" class="headerlink" title="关于写文章"></a>关于写文章</h2><h3 id="如何写"><a href="#如何写" class="headerlink" title="如何写"></a>如何写</h3><p>每篇文章最好写上文集和标签，方便筛选和查看。<br>一般推荐一篇文章设置一个文集，一个或多个标签<br><code>categories</code>:文集，为左侧列表<br><code>tags</code>:标签，通过#来筛选<br>例如 本篇文章的设置</p>
<pre><code class="xml">---
title: 3-hexo使用说明
date: 2017-03-23 15:13:47
categories:
- 工具
tags:
- hexo
- 3-hexo
---
</code></pre>
<h3 id="写作技巧"><a href="#写作技巧" class="headerlink" title="写作技巧"></a>写作技巧</h3><p>1.设置模板，blog根目录 <code>scaffolds/post.md</code><br>加入categories,tags等，这样以后通过 <code>hexo new</code> 生成的模板就不用写这两个单词了。<br>当然，你也可以写入任何你每个文章中都会有的部分。</p>
<pre><code class="xml">---
title: {{ title }}
date: {{ date }}
categories:
tags:
---
</code></pre>
<p>2.设置脚本命令<br>其实就通过alias，触发一些命令的集合<br>在 <code>~/.bashrc</code> 文件中添加</p>
<pre><code class="bash">alias hs=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&#39;  #启动本地服务
alias hd=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&#39;  #部署博客
</code></pre>
<p>甚至你也可以加入备份文章的命令，可以自由发挥。</p>
]]></content>
      
        <categories>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CentOs7.3 搭建 Redis-4.0.1 单机服务]]></title>
      <url>/2017/12/23/2017-08-14-redis/</url>
      <content type="html"><![CDATA[<h1 id="CentOs7-3-搭建-Redis-4-0-1-单机服务"><a href="#CentOs7-3-搭建-Redis-4-0-1-单机服务" class="headerlink" title="CentOs7.3 搭建 Redis-4.0.1 单机服务"></a>CentOs7.3 搭建 Redis-4.0.1 单机服务</h1><h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：<br>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>Redis支持数据的备份，即master-slave模式的数据备份。</p>
<a id="more"></a>
<h2 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h2><p>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。<br>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。<br>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。<br>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p>
<h2 id="Redis与其他key-value存储有什么不同？"><a href="#Redis与其他key-value存储有什么不同？" class="headerlink" title="Redis与其他key-value存储有什么不同？"></a>Redis与其他key-value存储有什么不同？</h2><p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。<br>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>VMware版本号：12.0.0</li>
<li>CentOS版本：CentOS 7.3.1611</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>关闭防火墙 节点之前需要开放指定端口，为了方便，生产不要禁用</p>
<p>centos 6.x</p>
<pre><code>service iptables stop # 关闭命令：
</code></pre><p>centos 7.x</p>
<pre><code>systemctl stop firewalld.service # 停止firewall
</code></pre><h2 id="单机搭建"><a href="#单机搭建" class="headerlink" title="单机搭建"></a>单机搭建</h2><h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><p><strong>下载，解压，编译安装</strong></p>
<p>升级所有的包，防止出现版本过久不兼容问题</p>
<pre><code class="sh">yum -y update
</code></pre>
<p>安裝 GCC 编译工具 不然会有编译不过的问题</p>
<pre><code class="sh">yum install -y gcc g++ gcc-c++ make
</code></pre>
<pre><code class="sh">cd /opt
wget http://download.redis.io/releases/redis-4.0.1.tar.gz
tar xzf redis-4.0.1.tar.gz
cd redis-4.0.1
make
</code></pre>
<p><strong>如果因为上次编译失败，有残留的文件</strong></p>
<pre><code class="sh">make distclean
</code></pre>
<h3 id="创建配置"><a href="#创建配置" class="headerlink" title="创建配置"></a>创建配置</h3><p><strong>默认的 <code>redis.conf</code> 配置文件内容太多，很多配置，不太好，用的时候再往，自己定义的配置文件加</strong></p>
<p> 1.创建 <code>redis-sentinel</code> 目录 用于放自定义配置文件启动 <code>redis.conf</code></p>
<pre><code class="sh">mkdir redis-sentinel
</code></pre>
<p> 2.在 <code>redis-sentinel</code> 目录下，创建 redis.conf  把如下<code>Redis.conf  配置</code>内容粘贴进去</p>
<pre><code class="sh">cd /opt/redis-4.0.1/redis-sentinel
vi redis.conf
</code></pre>
<p><strong>Redis.conf 配置</strong></p>
<p><code>bind</code> 改成自己的IP 不然外网连不上</p>
<pre><code class="sh">port 6379
bind 192.168.252.104
daemonize yes
pidfile /var/run/redis_6379.pid
appendonly yes
</code></pre>
<p><strong>redis.conf 配置说明</strong></p>
<pre><code class="sh">#端口7000
port 7000

#默认IP为127.0.0.1，需要改为其他节点机器可访问的IP
bind 192.168.252.101

#redis后台运行
daemonize yes 

#当 Redis 以守护进程的方式运行的时候，Redis 默认会把 pid 文件放在/var/run/redis_6379.pid
pidfile /var/run/redis_6379.pid

#aof日志开启，有需要就开启，它会每次写操作都记录一条日志
appendonly yes
</code></pre>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>使用指定配置文件启动 <code>--raw</code> 防止中文 <code>get</code> 乱码</p>
<pre><code class="sh">/opt/redis-4.0.1/src/redis-server /opt/redis-4.0.1/redis-sentinel/redis.conf --raw
</code></pre>
<pre><code class="sh">21915:C 17 Aug 12:58:03.301 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
21915:C 17 Aug 12:58:03.301 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=21915, just started
21915:C 17 Aug 12:58:03.301 # Configuration loaded
</code></pre>
<p>‘$remote_addr - $remote_user [$time_local] “$request” ‘$status $body_bytes_sent “$http_referer” ‘’”$http_user_agent” “$http_x_forwarded_for”‘;</p>
<h3 id="检查服务"><a href="#检查服务" class="headerlink" title="检查服务"></a>检查服务</h3><p>检查各 Redis 各个节点启动情况</p>
<pre><code class="sh">$ ps -ef | grep redis           //redis是否启动成功
$ netstat -tnlp | grep redis    //监听redis端口
</code></pre>
<h3 id="测试-Redis"><a href="#测试-Redis" class="headerlink" title="测试 Redis"></a>测试 Redis</h3><p>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了</p>
<p>比如</p>
<pre><code>$ /opt/redis-4.0.1/src/redis-cli -h 192.168.252.104 -c -p 6379 
192.168.252.104:6379&gt; set name www.ymq.io
OK
192.168.252.104:6379&gt; get name
&quot;www.ymq.io&quot;
192.168.252.104:6379&gt;
</code></pre><h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><pre><code class="sh">#!/bin/sh

#kconfig: 345 86 14
#description: Startup and shutdown script for Redis

PROGDIR=/opt/redis-4.0.1 #安装路径
PROGNAME=src/redis-server
DAEMON=$PROGDIR/$PROGNAME
CONFIG=/opt/redis-4.0.1/redis-sentinel/redis.conf
PIDFILE=/var/run/redis_6379.pid
DESC=&quot;redis daemon&quot;
SCRIPTNAME=/etc/rc.d/init.d/redisd

start()
{
         if test -x $DAEMON
         then
        echo -e &quot;Starting $DESC: $PROGNAME&quot;
                   if $DAEMON $CONFIG
                   then
                            echo -e &quot;OK&quot;
                   else
                            echo -e &quot;failed&quot;
                   fi
         else
                   echo -e &quot;Couldn&#39;t find Redis Server ($DAEMON)&quot;
         fi
}

stop()
{
         if test -e $PIDFILE
         then
                   echo -e &quot;Stopping $DESC: $PROGNAME&quot;
                   if kill `cat $PIDFILE`
                   then
                            echo -e &quot;OK&quot;
                   else
                            echo -e &quot;failed&quot;
                   fi
         else
                   echo -e &quot;No Redis Server ($DAEMON) running&quot;
         fi
}

restart()
{
    echo -e &quot;Restarting $DESC: $PROGNAME&quot;
    stop
         start
}

list()
{
         ps aux | grep $PROGNAME
}

case $1 in
         start)
                   start
        ;;
         stop)
        stop
        ;;
         restart)
        restart
        ;;
         list)
        list
        ;;

         *)
        echo &quot;Usage: $SCRIPTNAME {start|stop|restart|list}&quot; &gt;&amp;2
        exit 1
        ;;
esac
exit 0
</code></pre>
<h3 id="启动服务-1"><a href="#启动服务-1" class="headerlink" title="启动服务"></a>启动服务</h3><pre><code class="sh">$ service redisd start
Starting redis daemon: src/redis-server
22330:C 17 Aug 13:56:59.300 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
22330:C 17 Aug 13:56:59.300 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=22330, just started
22330:C 17 Aug 13:56:59.300 # Configuration loaded
OK
</code></pre>
<h3 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h3><pre><code class="sh">$ service redisd stop
Stopping redis daemon: src/redis-server
OK
</code></pre>
<h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><pre><code class="sh">$ service redisd restart
Restarting redis daemon: src/redis-server
No Redis Server (/opt/redis-4.0.1/src/redis-server) running
Starting redis daemon: src/redis-server
22354:C 17 Aug 13:57:16.110 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
22354:C 17 Aug 13:57:16.110 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=22354, just started
22354:C 17 Aug 13:57:16.110 # Configuration loaded
OK
</code></pre>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><pre><code class="sh">$ service redisd list
root      22355  0.0  0.7  41656  7512 ?        Ssl  13:57   0:00 /opt/redis-4.0.1/src/redis-server 192.168.252.104:6379
root      22370  0.0  0.0   9028   660 pts/1    R+   13:57   0:00 grep src/redis-server
</code></pre>
<p>出处：<a href="http://www.ymq.io" target="_blank" rel="noopener">http://www.ymq.io</a><br>转自：鹏磊</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[CentOs7.3 搭建 Redis-4.0.1 Cluster 集群服务]]></title>
      <url>/2017/12/23/2017-08-14-redis-cluster/</url>
      <content type="html"><![CDATA[<h1 id="CentOs7-3-搭建-Redis-4-0-1-Cluster-集群服务"><a href="#CentOs7-3-搭建-Redis-4-0-1-Cluster-集群服务" class="headerlink" title="CentOs7.3 搭建 Redis-4.0.1 Cluster 集群服务"></a>CentOs7.3 搭建 Redis-4.0.1 Cluster 集群服务</h1><h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：<br>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>Redis支持数据的备份，即master-slave模式的数据备份。</p>
<a id="more"></a>
<h2 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h2><p>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。<br>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。<br>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。<br>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p>
<h2 id="Redis与其他key-value存储有什么不同？"><a href="#Redis与其他key-value存储有什么不同？" class="headerlink" title="Redis与其他key-value存储有什么不同？"></a>Redis与其他key-value存储有什么不同？</h2><p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。<br>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>VMware版本号：12.0.0</li>
<li>CentOS版本：CentOS 7.3.1611</li>
<li>三台虚拟机(IP)：192.168.252.101,192.168.102..102,192.168.252.103</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>升级所有的包，防止出现版本过久不兼容问题</p>
<pre><code class="sh">$ yum -y update
</code></pre>
<p>安裝 GCC 编译工具 不然会有编译不过的问题</p>
<pre><code class="sh">$ yum install -y gcc g++ gcc-c++ make
</code></pre>
<p>关闭防火墙 节点之前需要开放指定端口，为了方便，生产不要禁用</p>
<p>centos 6.x</p>
<pre><code>$ service iptables stop # 关闭命令：
</code></pre><p>centos 7.x</p>
<pre><code>$ systemctl stop firewalld.service # 停止firewall
</code></pre><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><p><strong>下载，解压，编译安装</strong></p>
<pre><code class="sh">cd /opt
$ wget http://download.redis.io/releases/redis-4.0.1.tar.gz
$ tar xzf redis-4.0.1.tar.gz
$ cd redis-4.0.1
$ make
</code></pre>
<p><strong>如果因为上次编译失败，有残留的文件</strong></p>
<pre><code class="sh">$ make distclean
</code></pre>
<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>1.首先在 192.168.252.101机器上 /opt/redis-4.0.1目录下创建 <code>redis-cluster</code> 目录</p>
<pre><code class="sh">$ mkdir /opt/redis-4.0.1/redis-cluster
</code></pre>
<p>2.在 <code>redis-cluster</code> 目录下，创建名为<code>7000、7001、7002</code>的目录</p>
<pre><code class="sh">$ cd /opt/redis-4.0.1/redis-cluster
$ mkdir 7000 7001 7002
</code></pre>
<p>3.分别修改这三个配置文件，把如下<code>redis.conf 配置</code>内容粘贴进去</p>
<pre><code class="sh">$ vi 7000/redis.conf 
$ vi 7001/redis.conf
$ vi 7002/redis.conf
</code></pre>
<p><strong>redis.conf 配置</strong></p>
<pre><code class="sh">port 7000
bind 192.168.252.101
daemonize yes
pidfile /var/run/redis_7000.pid
cluster-enabled yes
cluster-config-file nodes_7000.conf
cluster-node-timeout 10100
appendonly yes
</code></pre>
<p><strong>redis.conf 配置说明</strong></p>
<pre><code class="sh">#端口7000,7001,7002
port 7000

#默认ip为127.0.0.1，需要改为其他节点机器可访问的ip，否则创建集群时无法访问对应的端口，无法创建集群
bind 192.168.252.101

#redis后台运行
daemonize yes

#pidfile文件对应7000，7001，7002
pidfile /var/run/redis_7000.pid

#开启集群，把注释#去掉
cluster-enabled yes

#集群的配置，配置文件首次启动自动生成 7000，7001，7002          
cluster-config-file nodes_7000.conf

#请求超时，默认15秒，可自行设置 
cluster-node-timeout 10100    

#aof日志开启，有需要就开启，它会每次写操作都记录一条日志
appendonly yes
</code></pre>
<p>···<br><strong>接着在另外两台机器上<code>(192.168.252.102，192.168.252.103)</code>重复以上三步，只是把目录改为<code>7003、7004、7005、7006、7007、7008</code>对应的配置文件也按照这个规则修改即可</strong></p>
<h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><pre><code class="sh">#第一台机器上执行 3个节点
$ for((i=0;i&lt;=2;i++)); do /opt/redis-4.0.1/src/redis-server /opt/redis-4.0.1/redis-cluster/700$i/redis.conf; done

#第二台机器上执行 3个节点
$ for((i=3;i&lt;=5;i++)); do /opt/redis-4.0.1/src/redis-server /opt/redis-4.0.1/redis-cluster/700$i/redis.conf; done

#第三台机器上执行 3个节点 
$ for((i=6;i&lt;=8;i++)); do /opt/redis-4.0.1/src/redis-server /opt/redis-4.0.1/redis-cluster/700$i/redis.conf; done
</code></pre>
<h3 id="检查服务"><a href="#检查服务" class="headerlink" title="检查服务"></a>检查服务</h3><p>检查各 Redis 各个节点启动情况</p>
<pre><code class="sh">$ ps -ef | grep redis           //redis是否启动成功
$ netstat -tnlp | grep redis    //监听redis端口
</code></pre>
<h3 id="安装-Ruby"><a href="#安装-Ruby" class="headerlink" title="安装 Ruby"></a>安装 Ruby</h3><pre><code class="sh">$ yum -y install ruby ruby-devel rubygems rpm-build
$ gem install redis
</code></pre>
<h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p><strong>注意：在任意一台上运行</strong> 不要在每台机器上都运行，一台就够了</p>
<p>Redis 官方提供了 <code>redis-trib.rb</code> 这个工具，就在解压目录的 src 目录中</p>
<pre><code class="sh">$ /opt/redis-4.0.1/src/redis-trib.rb create --replicas 1 192.168.252.101:7000 192.168.252.101:7001 192.168.252.101:7002 192.168.252.102:7003 192.168.252.102:7004 192.168.252.102:7005 192.168.252.103:7006 192.168.252.103:7007 192.168.252.103:7008
</code></pre>
<p>出现以下内容</p>
<pre><code class="sh">[root@localhost redis-cluster]# /opt/redis-4.0.1/src/redis-trib.rb create --replicas 1 192.168.252.101:7000 192.168.252.101:7001 192.168.252.101:7002 192.168.252.102:7003 192.168.252.102:7004 192.168.252.102:7005 192.168.252.103:7006 192.168.252.103:7007 192.168.252.103:7008
&gt;&gt;&gt; Creating cluster
&gt;&gt;&gt; Performing hash slots allocation on 9 nodes...
Using 4 masters:
192.168.252.101:7000
192.168.252.102:7003
192.168.252.103:7006
192.168.252.101:7001
Adding replica 192.168.252.102:7004 to 192.168.252.101:7000
Adding replica 192.168.252.103:7007 to 192.168.252.102:7003
Adding replica 192.168.252.101:7002 to 192.168.252.103:7006
Adding replica 192.168.252.102:7005 to 192.168.252.101:7001
Adding replica 192.168.252.103:7008 to 192.168.252.101:7000
M: 7c622ac191edd40dd61d9b79b27f6f69d02a5bbf 192.168.252.101:7000
   slots:0-4095 (4096 slots) master
M: 44c81c15b01d992cb9ede4ad35477ec853d70723 192.168.252.101:7001
   slots:12288-16383 (4096 slots) master
S: 38f03c27af39723e1828eb62d1775c4b6e2c3638 192.168.252.101:7002
   replicates f1abb62a8c9b448ea14db421bdfe3f1d8075189c
M: 987965baf505a9aa43e50e46c76189c51a8f17ec 192.168.252.102:7003
   slots:4096-8191 (4096 slots) master
S: 6555292fed9c5d52fcf5b983c441aff6f96923d5 192.168.252.102:7004
   replicates 7c622ac191edd40dd61d9b79b27f6f69d02a5bbf
S: 2b5ba254a0405d4efde4c459867b15176f79244a 192.168.252.102:7005
   replicates 44c81c15b01d992cb9ede4ad35477ec853d70723
M: f1abb62a8c9b448ea14db421bdfe3f1d8075189c 192.168.252.103:7006
   slots:8192-12287 (4096 slots) master
S: eb4067373d36d8a8df07951f92794e67a6aac022 192.168.252.103:7007
   replicates 987965baf505a9aa43e50e46c76189c51a8f17ec
S: 2919e041dd3d1daf176d6800dcd262f4e727f366 192.168.252.103:7008
   replicates 7c622ac191edd40dd61d9b79b27f6f69d02a5bbf
Can I set the above configuration? (type &#39;yes&#39; to accept): yes
</code></pre>
<p><strong>输入 yes</strong></p>
<pre><code class="sh">&gt;&gt;&gt; Nodes configuration updated
&gt;&gt;&gt; Assign a different config epoch to each node
&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join.........
&gt;&gt;&gt; Performing Cluster Check (using node 192.168.252.101:7000)
M: 7c622ac191edd40dd61d9b79b27f6f69d02a5bbf 192.168.252.101:7000
   slots:0-4095 (4096 slots) master
   2 additional replica(s)
S: 6555292fed9c5d52fcf5b983c441aff6f96923d5 192.168.252.102:7004
   slots: (0 slots) slave
   replicates 7c622ac191edd40dd61d9b79b27f6f69d02a5bbf
M: 44c81c15b01d992cb9ede4ad35477ec853d70723 192.168.252.101:7001
   slots:12288-16383 (4096 slots) master
   1 additional replica(s)
S: 2919e041dd3d1daf176d6800dcd262f4e727f366 192.168.252.103:7008
   slots: (0 slots) slave
   replicates 7c622ac191edd40dd61d9b79b27f6f69d02a5bbf
M: f1abb62a8c9b448ea14db421bdfe3f1d8075189c 192.168.252.103:7006
   slots:8192-12287 (4096 slots) master
   1 additional replica(s)
S: eb4067373d36d8a8df07951f92794e67a6aac022 192.168.252.103:7007
   slots: (0 slots) slave
   replicates 987965baf505a9aa43e50e46c76189c51a8f17ec
S: 38f03c27af39723e1828eb62d1775c4b6e2c3638 192.168.252.101:7002
   slots: (0 slots) slave
   replicates f1abb62a8c9b448ea14db421bdfe3f1d8075189c
S: 2b5ba254a0405d4efde4c459867b15176f79244a 192.168.252.102:7005
   slots: (0 slots) slave
   replicates 44c81c15b01d992cb9ede4ad35477ec853d70723
M: 987965baf505a9aa43e50e46c76189c51a8f17ec 192.168.252.102:7003
   slots:4096-8191 (4096 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
</code></pre>
<h3 id="关闭集群"><a href="#关闭集群" class="headerlink" title="关闭集群"></a>关闭集群</h3><p>这样也可以，推荐</p>
<pre><code class="sh">$ pkill redis
</code></pre>
<p>循环节点逐个关闭</p>
<pre><code class="sh">$ for((i=0;i&lt;=2;i++)); do /opt/redis-4.0.1/src/redis-cli -c -h 192.168.252.101 -p 700$i shutdown; done

$ for((i=3;i&lt;=5;i++)); do /opt/redis-4.0.1/src/redis-cli -c -h 192.168.252.102 -p 700$i shutdown; done

$ for((i=6;i&lt;=8;i++)); do /opt/redis-4.0.1/src/redis-cli -c -h 192.168.252.103 -p 700$i shutdown; done
</code></pre>
<h2 id="集群验证"><a href="#集群验证" class="headerlink" title="集群验证"></a>集群验证</h2><h3 id="连接集群测试"><a href="#连接集群测试" class="headerlink" title="连接集群测试"></a>连接集群测试</h3><p>参数 -C 可连接到集群，因为 redis.conf 将 bind 改为了ip地址，所以 -h 参数不可以省略，-p 参数为端口号</p>
<ul>
<li><strong>我们在192.168.252.101机器redis 7000 的节点set 一个key</strong></li>
</ul>
<pre><code class="sh">$ /opt/redis-4.0.1/src/redis-cli -h 192.168.252.101 -c -p 7000
192.168.252.101:7000&gt; set name www.ymq.io
-&gt; Redirected to slot [5798] located at 192.168.252.102:7003
OK
192.168.252.102:7003&gt; get name
&quot;www.ymq.io&quot;
192.168.252.102:7003&gt;
</code></pre>
<p>发现redis set name 之后重定向到192.168.252.102机器 redis 7003 这个节点</p>
<ul>
<li><strong>我们在192.168.252.103机器redis 7008 的节点get一个key</strong></li>
</ul>
<pre><code class="sh">[root@localhost redis-cluster]# /opt/redis-4.0.1/src/redis-cli -h 192.168.252.103 -c -p 7008
192.168.252.103:7008&gt; get name
-&gt; Redirected to slot [5798] located at 192.168.252.102:7003
&quot;www.ymq.io&quot;
192.168.252.102:7003&gt;
</code></pre>
<p>发现redis get name 重定向到192.168.252.102机器 redis 7003 这个节点</p>
<blockquote>
<p>如果您看到这样的现象，说明集群已经是可用的了</p>
</blockquote>
<h3 id="检查集群状态"><a href="#检查集群状态" class="headerlink" title="检查集群状态"></a>检查集群状态</h3><pre><code class="sh">$ /opt/redis-4.0.1/src/redis-trib.rb check 192.168.252.101:7000
</code></pre>
<pre><code class="sh">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.252.101:7000)
M: 7c622ac191edd40dd61d9b79b27f6f69d02a5bbf 192.168.252.101:7000
   slots:0-4095 (4096 slots) master
   2 additional replica(s)
S: 6555292fed9c5d52fcf5b983c441aff6f96923d5 192.168.252.102:7004
   slots: (0 slots) slave
   replicates 7c622ac191edd40dd61d9b79b27f6f69d02a5bbf
M: 44c81c15b01d992cb9ede4ad35477ec853d70723 192.168.252.101:7001
   slots:12288-16383 (4096 slots) master
   1 additional replica(s)
S: 2919e041dd3d1daf176d6800dcd262f4e727f366 192.168.252.103:7008
   slots: (0 slots) slave
   replicates 7c622ac191edd40dd61d9b79b27f6f69d02a5bbf
M: f1abb62a8c9b448ea14db421bdfe3f1d8075189c 192.168.252.103:7006
   slots:8192-12287 (4096 slots) master
   1 additional replica(s)
S: eb4067373d36d8a8df07951f92794e67a6aac022 192.168.252.103:7007
   slots: (0 slots) slave
   replicates 987965baf505a9aa43e50e46c76189c51a8f17ec
S: 38f03c27af39723e1828eb62d1775c4b6e2c3638 192.168.252.101:7002
   slots: (0 slots) slave
   replicates f1abb62a8c9b448ea14db421bdfe3f1d8075189c
S: 2b5ba254a0405d4efde4c459867b15176f79244a 192.168.252.102:7005
   slots: (0 slots) slave
   replicates 44c81c15b01d992cb9ede4ad35477ec853d70723
M: 987965baf505a9aa43e50e46c76189c51a8f17ec 192.168.252.102:7003
   slots:4096-8191 (4096 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
</code></pre>
<h3 id="列出集群节点"><a href="#列出集群节点" class="headerlink" title="列出集群节点"></a>列出集群节点</h3><p>列出集群当前已知的所有节点（node），以及这些节点的相关信息</p>
<pre><code class="sh">$ /opt/redis-4.0.1/src/redis-cli -h 192.168.252.101 -c -p 7000

192.168.252.101:7000&gt; cluster nodes
</code></pre>
<pre><code class="sh">6555292fed9c5d52fcf5b983c441aff6f96923d5 192.168.252.102:7004@17004 slave 7c622ac191edd40dd61d9b79b27f6f69d02a5bbf 0 1502815268317 5 connected
44c81c15b01d992cb9ede4ad35477ec853d70723 192.168.252.101:7001@17001 master - 0 1502815268000 2 connected 12288-16383
2919e041dd3d1daf176d6800dcd262f4e727f366 192.168.252.103:7008@17008 slave 7c622ac191edd40dd61d9b79b27f6f69d02a5bbf 0 1502815269000 9 connected
7c622ac191edd40dd61d9b79b27f6f69d02a5bbf 192.168.252.101:7000@17000 myself,master - 0 1502815269000 1 connected 0-4095
f1abb62a8c9b448ea14db421bdfe3f1d8075189c 192.168.252.103:7006@17006 master - 0 1502815269000 7 connected 8192-12287
eb4067373d36d8a8df07951f92794e67a6aac022 192.168.252.103:7007@17007 slave 987965baf505a9aa43e50e46c76189c51a8f17ec 0 1502815267000 8 connected
38f03c27af39723e1828eb62d1775c4b6e2c3638 192.168.252.101:7002@17002 slave f1abb62a8c9b448ea14db421bdfe3f1d8075189c 0 1502815269327 7 connected
2b5ba254a0405d4efde4c459867b15176f79244a 192.168.252.102:7005@17005 slave 44c81c15b01d992cb9ede4ad35477ec853d70723 0 1502815270336 6 connected
987965baf505a9aa43e50e46c76189c51a8f17ec 192.168.252.102:7003@17003 master - 0 1502815271345 4 connected 4096-8191
192.168.252.101:7000&gt;
</code></pre>
<h3 id="打印集群信息"><a href="#打印集群信息" class="headerlink" title="打印集群信息"></a>打印集群信息</h3><pre><code class="sh">$ 192.168.252.101:7000&gt; cluster info
</code></pre>
<pre><code class="sh">cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:9
cluster_size:4
cluster_current_epoch:9
cluster_my_epoch:1
cluster_stats_messages_ping_sent:485
cluster_stats_messages_pong_sent:485
cluster_stats_messages_sent:970
cluster_stats_messages_ping_received:477
cluster_stats_messages_pong_received:485
cluster_stats_messages_meet_received:8
cluster_stats_messages_received:970
192.168.252.101:7000&gt;
</code></pre>
<h2 id="集群命令"><a href="#集群命令" class="headerlink" title="集群命令"></a>集群命令</h2><p>语法格式</p>
<pre><code class="sh">redis-cli -c -p port
</code></pre>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><pre><code>cluster info ：打印集群的信息
cluster nodes ：列出集群当前已知的所有节点（ node），以及这些节点的相关信息。
</code></pre><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><pre><code>cluster meet &lt;ip&gt; &lt;port&gt; ：将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。
cluster forget &lt;node_id&gt; ：从集群中移除 node_id 指定的节点。
cluster replicate &lt;node_id&gt; ：将当前节点设置为 node_id 指定的节点的从节点。
cluster saveconfig ：将节点的配置文件保存到硬盘里面。
</code></pre><h3 id="槽-slot"><a href="#槽-slot" class="headerlink" title="槽(slot)"></a>槽(slot)</h3><pre><code>cluster addslots &lt;slot&gt; [slot ...] ：将一个或多个槽（ slot）指派（ assign）给当前节点。
cluster delslots &lt;slot&gt; [slot ...] ：移除一个或多个槽对当前节点的指派。
cluster flushslots ：移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。
cluster setslot &lt;slot&gt; node &lt;node_id&gt; ：将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽&gt;，然后再进行指派。
cluster setslot &lt;slot&gt; migrating &lt;node_id&gt; ：将本节点的槽 slot 迁移到 node_id 指定的节点中。
cluster setslot &lt;slot&gt; importing &lt;node_id&gt; ：从 node_id 指定的节点中导入槽 slot 到本节点。
cluster setslot &lt;slot&gt; stable ：取消对槽 slot 的导入（ import）或者迁移（ migrate）。
</code></pre><h3 id="键"><a href="#键" class="headerlink" title="键"></a>键</h3><pre><code>cluster keyslot &lt;key&gt; ：计算键 key 应该被放置在哪个槽上。
cluster countkeysinslot &lt;slot&gt; ：返回槽 slot 目前包含的键值对数量。
cluster getkeysinslot &lt;slot&gt; &lt;count&gt; ：返回 count 个 slot 槽中的键 。
</code></pre><p>出处：<a href="http://www.ymq.io" target="_blank" rel="noopener">http://www.ymq.io</a><br>转自：鹏磊</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建高吞吐量 Kafka 分布式发布订阅消息 集群]]></title>
      <url>/2017/12/23/2017-08-29-kafka/</url>
      <content type="html"><![CDATA[<h1 id="搭建高吞吐量-Kafka-分布式发布订阅消息-集群"><a href="#搭建高吞吐量-Kafka-分布式发布订阅消息-集群" class="headerlink" title="搭建高吞吐量 Kafka 分布式发布订阅消息 集群"></a>搭建高吞吐量 Kafka 分布式发布订阅消息 集群</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kafka 是一种高吞吐的分布式发布订阅消息系统，能够替代传统的消息队列用于解耦合数据处理，缓存未处理消息等，同时具有更高的吞吐率，支持分区、多副本、冗余，因此被广泛用于大规模消息数据处理应用。Kafka 支持Java 及多种其它语言客户端，可与Hadoop、Storm、Spark等其它大数据工具结合使用。</p>
<a id="more"></a>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Zookeeper集群: 192.168.252.121:2181,192.168.252.122:2181,192.168.252.123:2181</p>
<p>kafka 集群: 192.168.252.124 , 192.168.252.125 , 192.168.252.126  </p>
<p>kafka-manager: 192.168.252.127 </p>
<h3 id="主机名修改"><a href="#主机名修改" class="headerlink" title="主机名修改"></a>主机名修改</h3><p><a href="https://segmentfault.com/a/1190000010723105" target="_blank" rel="noopener">CentOs7.3 修改主机名</a>  </p>
<h3 id="ssh-免密登录"><a href="#ssh-免密登录" class="headerlink" title="ssh 免密登录"></a>ssh 免密登录</h3><p><a href="https://segmentfault.com/a/1190000010738165" target="_blank" rel="noopener">CentOs7.3 ssh 免密登录</a></p>
<h3 id="安装-JDK1-8"><a href="#安装-JDK1-8" class="headerlink" title="安装 JDK1.8"></a>安装 JDK1.8</h3><p><a href="https://segmentfault.com/a/1190000010716919" target="_blank" rel="noopener">CentOs7.3 安装 JDK1.8</a></p>
<h3 id="搭建-Zookeeper-集群"><a href="#搭建-Zookeeper-集群" class="headerlink" title="搭建 Zookeeper 集群"></a>搭建 Zookeeper 集群</h3><p><a href="https://segmentfault.com/a/1190000010807875" target="_blank" rel="noopener">CentOs7.3 搭建 ZooKeeper-3.4.9 Cluster 集群服务</a></p>
<p>Zookeeper集群: 192.168.252.121:2181,192.168.252.122:2181,192.168.252.123:2181</p>
<p>主机名依次被我修改成: <strong>node1,node2,node3</strong></p>
<h2 id="搭建-kafka-集群"><a href="#搭建-kafka-集群" class="headerlink" title="搭建 kafka 集群"></a>搭建 kafka 集群</h2><p>kafka 集群: 192.168.252.124 , 192.168.252.125 , 192.168.252.126  </p>
<p>主机名依次被我修改成: <strong>node4,node5,node6</strong></p>
<h3 id="1-下载代码"><a href="#1-下载代码" class="headerlink" title="1.下载代码"></a>1.下载代码</h3><p><a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">kafka 官网下载 http://kafka.apache.org/downloads </a></p>
<p>下载最新版本的kafka ，我在北京我就选择，清华镜像比较快</p>
<p>清华镜像:<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/kafka/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/kafka/ </a></p>
<p>阿里镜像:<a href="https://mirrors.aliyun.com/apache/kafka/" target="_blank" rel="noopener">https://mirrors.aliyun.com/apache/kafka/</a></p>
<pre><code class="sh">$ cd /opt
$ wget https://mirrors.tuna.tsinghua.edu.cn/apache/kafka/0.11.0.0/kafka_2.12-0.11.0.0.tgz
$ tar -zxvf kafka_2.12-0.11.0.0.tgz
$ cd kafka_2.12-0.11.0.0
</code></pre>
<h3 id="2-修改配置"><a href="#2-修改配置" class="headerlink" title="2.修改配置"></a>2.修改配置</h3><p>在 node4 操作</p>
<pre><code class="sh">$ vi /opt/kafka_2.12-0.11.0.0/config/server.properties
</code></pre>
<pre><code class="sh">broker.id=0  每台服务器不能重复

#设置zookeeper的集群地址
zookeeper.connect=192.168.252.121:2181,192.168.252.122:2181,192.168.252.123:2181
</code></pre>
<p>把配置复制到 node5,node6 集群</p>
<pre><code class="sh">$ for a in {5..6} ; do scp -r /opt/kafka_2.12-0.11.0.0/ node$a:/opt/kafka_2.12-0.11.0.0 ; done
</code></pre>
<p>修改 node5,node6 集群的<code>broker.id</code></p>
<pre><code class="sh">$ vi /opt/kafka_2.12-0.11.0.0/config/server.properties
</code></pre>
<h3 id="3-启动kafka"><a href="#3-启动kafka" class="headerlink" title="3.启动kafka"></a>3.启动kafka</h3><p>在 node1,启动 Kafka使用的 ZooKeeper，所以先<strong>启动ZooKeeper服务器</strong></p>
<pre><code class="sh">$ for a in {1..3} ; do ssh node$a &quot;source /etc/profile;  /opt/zookeeper-3.4.9/bin/zkServer.sh start&quot; ; done
</code></pre>
<p><strong>现在 node4 启动Kafka服务器</strong></p>
<pre><code class="sh">$ for a in {4..6} ; do ssh node$a &quot;source /etc/profile;  /opt/kafka_2.12-0.11.0.0/bin/kafka-server-start.sh /opt/kafka_2.12-0.11.0.0/config/server.properties&quot; ; done
</code></pre>
<p>或者后台启动运行，日志查看去Kafka解压目录有个<code>log</code> 文件夹查看</p>
<pre><code class="sh">$ for a in {4..6} ; do ssh node$a &quot;source /etc/profile; nohup  /opt/kafka_2.12-0.11.0.0/bin/kafka-server-start.sh /opt/kafka_2.12-0.11.0.0/config/server.properties &gt; /dev/null 2&gt;&amp;1 &amp;&quot; ; done
</code></pre>
<p>查看进程，Kafka 是否启动成功</p>
<pre><code class="sh">$ jps
3825 Kafka
6360 Jps
</code></pre>
<p>如果报错删除</p>
<pre><code class="sh">kafka.common.KafkaException: Failed to acquire lock on file .lock in /tmp/kafka-logs. A Kafka instance in another process or thread is using this directory.

$ rm -rf /tmp/kafka-logs
</code></pre>
<h3 id="4-创建主题"><a href="#4-创建主题" class="headerlink" title="4.创建主题"></a>4.创建主题</h3><pre><code class="sh">$ /opt/kafka_2.12-0.11.0.0/bin/kafka-topics.sh --create --zookeeper 192.168.252.121:2181,192.168.252.122:2181,192.168.252.123:2181 --replication-factor 2 --partitions 1 --topic ymq
</code></pre>
<p>–replication-factor 2   #复制两份<br>–partitions 1              #创建1个分区<br>–topic                     #主题为ymq  </p>
<p>运行list topic命令，可以看到该主题：</p>
<pre><code class="sh">$ /opt/kafka_2.12-0.11.0.0/bin/kafka-topics.sh --list --zookeeper 192.168.252.121:2181,192.168.252.122:2181,192.168.252.123:2181
</code></pre>
<h3 id="5-生产消息"><a href="#5-生产消息" class="headerlink" title="5.生产消息"></a>5.生产消息</h3><p>Kafka附带一个命令行客户端，它将从文件或标准输入中输入，并将其作为消息发送到Kafka群集。默认情况下，每行将作为单独的消息发送。</p>
<p>在 <strong>node5</strong> 运行生产者，然后在控制台中输入一些消息以发送到服务器。</p>
<pre><code class="sh">$ /opt/kafka_2.12-0.11.0.0/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic ymq
&gt;www.ymq.io
</code></pre>
<h3 id="6-消费消息"><a href="#6-消费消息" class="headerlink" title="6.消费消息"></a>6.消费消息</h3><p>在<strong>node6</strong> 运行消费者，将把消息转储到标准输出。</p>
<pre><code class="sh">$ /opt/kafka_2.12-0.11.0.0/bin/kafka-console-consumer.sh --zookeeper 192.168.252.121:2181,192.168.252.122:2181,192.168.252.123:2181  --topic ymq --from-beginning
Using the ConsoleConsumer with old consumer is deprecated and will be removed in a future major release. Consider using the new consumer by passing [bootstrap-server] instead of [zookeeper]. 
www.ymq.io
</code></pre>
<h3 id="7-topic详情"><a href="#7-topic详情" class="headerlink" title="7.topic详情"></a>7.topic详情</h3><p>用describe 查看集群中topic每个节点情况 </p>
<pre><code class="sh">$ /opt/kafka_2.12-0.11.0.0/bin/kafka-topics.sh --describe --zookeeper 192.168.252.121:2181,192.168.252.122:2181,192.168.252.123:2181 --topic ymq
Topic:ymq    PartitionCount:1    ReplicationFactor:2    Configs:
    Topic: ymq    Partition: 0    Leader: 1    Replicas: 1,3    Isr: 3,1
</code></pre>
<p>以下是输出的说明。第一行给出了所有分区的摘要，每个附加行提供有关一个分区的信息。由于我们这个主题只有一个分区，只有一行。</p>
<p><code>leader</code>负责给定分区的读取和写入分配节点编号，每个分区的部分数据会随机指定不同的节点<br><code>replicas</code>是复制此分区的日志的节点列表<br><code>isr</code>一组正在同步的副本列表</p>
<h3 id="8-删除topic"><a href="#8-删除topic" class="headerlink" title="8.删除topic"></a>8.删除topic</h3><pre><code class="sh">$ /opt/kafka_2.12-0.11.0.0/bin/kafka-topics.sh --delete --zookeeper 192.168.252.121:2181,192.168.252.122:2181,192.168.252.123:2181 --topic ymq
Topic ymq is marked for deletion.
Note: This will have no impact if delete.topic.enable is not set to true.
</code></pre>
<h3 id="9-停止kafka"><a href="#9-停止kafka" class="headerlink" title="9.停止kafka"></a>9.停止kafka</h3><pre><code class="sh">$ for a in {4..6} ; do ssh node$a &quot;source /etc/profile;  /opt/kafka_2.12-0.11.0.0/bin/kafka-server-stop.sh /opt/kafka_2.12-0.11.0.0/config/server.properties &quot; ; done
</code></pre>
<h2 id="部署-Kafka-Manager"><a href="#部署-Kafka-Manager" class="headerlink" title="部署 Kafka Manager"></a>部署 Kafka Manager</h2><p><a href="https://github.com/yahoo/kafka-manager" target="_blank" rel="noopener">Yahoo开源Kafka集群管理器Kafka Manager</a></p>
<p>作为一个分布式的消息发布-订阅系统，Apache Kafka在Yahoo内部已经被很多团队所使用，例如媒体分析团队就将其应用到了实时分析流水线中，同时，Yahoo整个Kafka集群处理的峰值带宽超过了20Gbps（压缩数据）。为了让开发者和服务工程师能够更加简单地维护Kafka集群，Yahoo构建了一个基于Web的管理工具，称为Kafka Manager，日前该项目已经在GitHub上开源。</p>
<p>通过Kafka Manager用户能够更容易地发现集群中哪些主题或者分区分布不均匀，同时能够管理多个集群，能够更容易地检查集群的状态，能够创建主题，执行首选的副本选择，能够基于集群当前的状态生成分区分配，并基于生成的分配执行分区的重分配，此外，Kafka Manager还是一个非常好的可以快速查看集群状态的工具。</p>
<p>Kafka Manager使用Scala语言编写，其Web控制台基于Play Framework实现，除此之外，Yahoo还迁移了一些Apache Kafka的帮助程序以便能够与Apache Curator框架一起工作。</p>
<p>一、它支持以下内容：</p>
<ul>
<li>管理多个群集</li>
<li>容易检查集群状态（主题，消费者，偏移量，经纪人，副本分发，分区分配）</li>
<li>运行首选副本选举</li>
<li>使用选项生成分区分配，以选择要使用的代理</li>
<li>运行分区的重新分配（基于生成的分配）</li>
<li>创建可选主题配置的主题（0.8.1.1具有不同于0.8.2+的配置）</li>
<li>删除主题（仅支持0.8.2+，并记住在代理配​​置中设置delete.topic.enable = true）</li>
<li>主题列表现在表示标记为删除的主题（仅支持0.8.2+）</li>
<li>批量生成多个主题的分区分配，并选择要使用的代理</li>
<li>批量运行多个主题的分区重新分配</li>
<li>将分区添加到现有主题</li>
<li>更新现有主题的配置</li>
<li>可选地，启用JMX轮询代理级和主题级度量。</li>
<li>可选地筛选出在zookeeper中没有ids / owner /＆offset /目录的消费者。</li>
</ul>
<h3 id="源码，并编译打包"><a href="#源码，并编译打包" class="headerlink" title="源码，并编译打包"></a>源码，并编译打包</h3><p>在 kafka-manager: 192.168.252.127 <strong>node7</strong> 部署</p>
<p><strong>编译超级慢</strong></p>
<pre><code class="sh">$ yum install git
$ cd /opt/
$ git clone https://github.com/yahoo/kafka-manager
$ cd kafka-manager/
$ ./sbt clean dist
</code></pre>
<h3 id="下载编译好的包"><a href="#下载编译好的包" class="headerlink" title="下载编译好的包"></a>下载编译好的包</h3><p>反正我是没编译成功，从网上找了一个编译好的</p>
<p>链接: <a href="https://pan.baidu.com/s/1mimPXHI" target="_blank" rel="noopener">百度网盘下载</a> 密码: kha2  </p>
<pre><code class="sh">$ yum install unzip
$ unzip kafka-manager-1.3.2.1.zip
$ vi /opt/kafka-manager-1.3.2.1/conf/application.conf
</code></pre>
<p>修改这个 zk 地址</p>
<pre><code class="sh">kafka-manager.zkhosts=&quot;192.168.252.121:2181,192.168.252.122:2181,192.168.252.123:2181&quot;
</code></pre>
<h3 id="启动-kafka-manager"><a href="#启动-kafka-manager" class="headerlink" title="启动 kafka-manager"></a>启动 kafka-manager</h3><p>默认端口 <code>NettyServer - Listening for HTTP on /0:0:0:0:0:0:0:0:9000</code></p>
<pre><code class="`sh">$ /opt/kafka-manager-1.3.2.1/bin/kafka-manager -Dconfig.file=conf/application.conf
</code></pre>
<p>或者后台运行 并且配置端口</p>
<pre><code class="`sh">$ nohup bin/kafka-manager  -Dconfig.file=/home/hadoop/app/kafka-manager-1.3.2.1/conf/application.conf -Dhttp.port=9000 &amp;
</code></pre>
<p>访问：<a href="">http://ip:9000/</a></p>
<p><img src="http://www.ymq.io/images/2017/Kafka/add-cluster.png" alt=""> </p>
<p><img src="http://www.ymq.io/images/2017/Kafka/topic.png" alt=""> </p>
<p><img src="http://www.ymq.io/images/2017/Kafka/brokers.png" alt=""> </p>
<p>出处：<a href="http://www.ymq.io" target="_blank" rel="noopener">http://www.ymq.io</a><br>转自：鹏磊</p>
]]></content>
      
        <categories>
            
            <category> kafka </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Boot 中使用 kafka]]></title>
      <url>/2017/12/23/2017-10-17-kafka-spring-boot-example/</url>
      <content type="html"><![CDATA[<p>Kafka 是一种高吞吐的分布式发布订阅消息系统，能够替代传统的消息队列用于解耦合数据处理，缓存未处理消息等，同时具有更高的吞吐率，支持分区、多副本、冗余，因此被广泛用于大规模消息数据处理应用。Kafka 支持Java 及多种其它语言客户端，可与Hadoop、Storm、Spark等其它大数据工具结合使用。</p>
<a id="more"></a>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p><a href="https://segmentfault.com/a/1190000010896062" target="_blank" rel="noopener">搭建高吞吐量 Kafka 分布式发布订阅消息 集群</a></p>
<h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><h1 id="Github-代码"><a href="#Github-代码" class="headerlink" title="Github 代码"></a>Github 代码</h1><p>代码我已放到 Github ，导入<code>spring-boot-kafka</code> 项目 </p>
<p>github <a href="https://github.com/souyunku/spring-boot-examples/tree/master/spring-boot-kafka" target="_blank" rel="noopener">https://github.com/souyunku/spring-boot-examples/tree/master/spring-boot-kafka</a></p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>在项目中添加 <code>kafka-clients</code> 依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
    &lt;version&gt;0.10.2.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="启用-kafka"><a href="#启用-kafka" class="headerlink" title="启用 kafka"></a>启用 kafka</h2><pre><code class="java">@Configuration
@EnableKafka
public class KafkaConfiguration {

}
</code></pre>
<h2 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h2><pre><code class="java">@Component
public class MsgProducer {

    private static final Logger log = LoggerFactory.getLogger(MsgProducer.class);

    @Autowired
    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;

    public void sendMessage(String topicName, String jsonData) {
        log.info(&quot;向kafka推送数据:[{}]&quot;, jsonData);
        try {
            kafkaTemplate.send(topicName, jsonData);
        } catch (Exception e) {
            log.error(&quot;发送数据出错！！！{}{}&quot;, topicName, jsonData);
            log.error(&quot;发送数据出错=====&gt;&quot;, e);
        }

        //消息发送的监听器，用于回调返回信息
        kafkaTemplate.setProducerListener(new ProducerListener&lt;String, String&gt;() {
            @Override
            public void onSuccess(String topic, Integer partition, String key, String value, RecordMetadata recordMetadata) {
            }

            @Override
            public void onError(String topic, Integer partition, String key, String value, Exception exception) {
            }

            @Override
            public boolean isInterestedInSuccess() {
                log.info(&quot;数据发送完毕&quot;);
                return false;
            }
        });
    }

}
</code></pre>
<h2 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h2><pre><code class="java">@Component
public class MsgConsumer {

    @KafkaListener(topics = {&quot;topic-1&quot;,&quot;topic-2&quot;})
    public void processMessage(String content) {

        System.out.println(&quot;消息被消费&quot;+content);
    }

}
</code></pre>
<h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p><strong><code>application.properties</code></strong></p>
<pre><code>#kafka
# 指定kafka 代理地址，可以多个
spring.kafka.bootstrap-servers=YZ-PTEST-APP-HADOOP-02:9092,YZ-PTEST-APP-HADOOP-04:9092
# 指定listener 容器中的线程数，用于提高并发量
spring.kafka.listener.concurrency=3
# 每次批量发送消息的数量
spring.kafka.producer.batch-size=1000
# 指定默认消费者group id
spring.kafka.consumer.group-id=myGroup
# 指定默认topic id
spring.kafka.template.default-topic=topic-1
</code></pre><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><pre><code class="java">@SpringBootApplication
@ComponentScan(value = {&quot;io.ymq.kafka&quot;})
public class Startup {

    public static void main(String[] args) {
        SpringApplication.run(Startup.class, args);
    }
}
</code></pre>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><pre><code class="java">import io.ymq.kafka.MsgProducer;
import io.ymq.kafka.run.Startup;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
/**
 * 描述: 测试 kafka
 *
 * @author yanpenglei
 * @create 2017-10-16 18:45
 **/
@RunWith(SpringRunner.class)
@SpringBootTest(classes = Startup.class)
public class BaseTest {

    @Autowired
    private MsgProducer msgProducer;

    @Test
    public void test() throws Exception {

        msgProducer.sendMessage(&quot;topic-1&quot;, &quot;topic--------1&quot;);
        msgProducer.sendMessage(&quot;topic-2&quot;, &quot;topic--------2&quot;);
    }
}
</code></pre>
<p>消息生产者,响应</p>
<pre><code>2017-10-17 15:54:44.814  INFO 2960 --- [           main] io.ymq.kafka.MsgProducer                 : 向kafka推送数据:[topic--------1]
2017-10-17 15:54:44.860  INFO 2960 --- [           main] io.ymq.kafka.MsgProducer                 : 向kafka推送数据:[topic--------2]
2017-10-17 15:54:44.878  INFO 2960 --- [ad | producer-1] io.ymq.kafka.MsgProducer                 : 数据发送完毕
2017-10-17 15:54:44.878  INFO 2960 --- [ad | producer-1] io.ymq.kafka.MsgProducer                 : 数据发送完毕
</code></pre><p>消息消费者,响应</p>
<pre><code>消息被消费topic--------1
消息被消费topic--------2
</code></pre><p>代码我已放到 Github ，导入<code>spring-boot-kafka</code> 项目 </p>
<p>github <a href="https://github.com/souyunku/spring-boot-examples/tree/master/spring-boot-kafka" target="_blank" rel="noopener">https://github.com/souyunku/spring-boot-examples/tree/master/spring-boot-kafka</a></p>
<h2 id="遇到一些坑"><a href="#遇到一些坑" class="headerlink" title="遇到一些坑"></a>遇到一些坑</h2><pre><code class="sh">[2017-10-16 19:20:08.340] - 14884 严重 [main] --- org.springframework.kafka.support.LoggingProducerListener: Exception thrown when sending a message with key=&#39;null&#39; and payload=&#39;topic--------2&#39; to topic topic-2:
</code></pre>
<p>经调试发现 kafka 连接是用的主机名，所以修改 hosts</p>
<pre><code class="sh">C:\Windows\System32\drivers\etc\hosts

10.32.32.149 YZ-PTEST-APP-HADOOP-02
10.32.32.154 YZ-PTEST-APP-HADOOP-04
</code></pre>
<p>出处：<a href="http://www.ymq.io" target="_blank" rel="noopener">http://www.ymq.io</a><br>转自：鹏磊</p>
]]></content>
      
        <categories>
            
            <category> kafka </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用 Git 命令清单]]></title>
      <url>/2017/12/23/2017-07-19-git/</url>
      <content type="html"><![CDATA[<h2 id="Git-命令清单。几个专用名词的译名如下。"><a href="#Git-命令清单。几个专用名词的译名如下。" class="headerlink" title="Git 命令清单。几个专用名词的译名如下。"></a>Git 命令清单。几个专用名词的译名如下。</h2><ul>
<li>Workspace：工作区 Index </li>
<li>Stage：暂存区 </li>
<li>Repository：仓库区（或本地仓库） </li>
<li><p>Remote：远程仓库</p>
<a id="more"></a>
</li>
</ul>
<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><pre><code class="sh"> 在当前目录新建一个Git代码库
$ git init

 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

 下载一个项目和它的整个代码历史
$ git clone [url]
</code></pre>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><blockquote>
<p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）</p>
</blockquote>
<pre><code class="sh"> 显示当前的Git配置
$ git config --list

 编辑Git配置文件
$ git config -e [--global]

 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;
</code></pre>
<h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><pre><code class="sh"> 添加指定文件到暂存区
$ git add [file1] [file2] ...

 添加指定目录到暂存区，包括子目录
$ git add [dir]

 添加当前目录的所有文件到暂存区
$ git add .

 添加每个变化前，都会要求确认
 对于同一个文件的多处变化，可以实现分次提交
$ git add -p

 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
</code></pre>
<h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><pre><code class="sh"> 提交暂存区到仓库区
$ git commit -m [message]

 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

 提交时显示所有diff信息
$ git commit -v

 使用一次新的commit，替代上一次提交
 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre>
<h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><pre><code class="sh"> 列出所有本地分支
$ git branch

 列出所有远程分支
$ git branch -r

 列出所有本地分支和远程分支
$ git branch -a

 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

 新建一个分支，并切换到该分支
$ git checkout -b [branch]

 新建一个分支，指向指定commit
$ git branch [branch] [commit]

 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

 切换到指定分支，并更新工作区
$ git checkout [branch-name]

 切换到上一个分支
$ git checkout -

 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

 合并指定分支到当前分支
$ git merge [branch]

 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

 删除分支
$ git branch -d [branch-name]

 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre>
<h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><pre><code class="sh"> 列出所有tag
$ git tag

 新建一个tag在当前commit
$ git tag [tag]

 新建一个tag在指定commit
$ git tag [tag] [commit]

 删除本地tag
$ git tag -d [tag]

 删除远程tag
$ git push origin :refs/tags/[tagName]

 查看tag信息
$ git show [tag]

 提交指定tag
$ git push [remote] [tag]

 提交所有tag
$ git push [remote] --tags

 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
</code></pre>
<h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><pre><code class="sh"> 显示有变更的文件
$ git status

 显示当前分支的版本历史
$ git log

 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

 搜索提交历史，根据关键词
$ git log -S [keyword]

 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

 显示指定文件相关的每一次diff
$ git log -p [file]

 显示过去5次提交
$ git log -5 --pretty --oneline

 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

 显示指定文件是什么人在什么时间修改过
$ git blame [file]

 显示暂存区和工作区的差异
$ git diff

 显示暂存区和上一个commit的差异
$ git diff --cached [file]

 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

 显示某次提交的元数据和内容变化
$ git show [commit]

 显示某次提交发生变化的文件
$ git show --name-only [commit]

 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

 显示当前分支的最近几次提交
$ git reflog
</code></pre>
<h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><pre><code class="sh"> 下载远程仓库的所有变动
$ git fetch [remote]

 显示所有远程仓库
$ git remote -v

 显示某个远程仓库的信息
$ git remote show [remote]

 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

 上传本地指定分支到远程仓库
$ git push [remote] [branch]

 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre>
<h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><pre><code class="sh"> 恢复暂存区的指定文件到工作区
$ git checkout [file]

 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

 恢复暂存区的所有文件到工作区
$ git checkout .

 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

 新建一个commit，用来撤销指定commit
 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
</code></pre>
<h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><pre><code class="sh"> 生成一个可供发布的压缩包
$ git archive
</code></pre>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">来自阮一峰的网络日志，列出了 Git 最常用的命令</a></p>
</blockquote>
<p>出处：<a href="http://www.ymq.io" target="_blank" rel="noopener">http://www.ymq.io</a><br>转自：鹏磊</p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Boot 中使用 Redis]]></title>
      <url>/2017/12/23/2017-10-16-redis-jedis-spring-boot-example/</url>
      <content type="html"><![CDATA[<p>Spring Boot中除了对常用的关系型数据库提供了优秀的自动化支持之外，对于很多NoSQL数据库一样提供了自动化配置的支持，包括：Redis, MongoDB, Elasticsearch, Solr和Cassandra。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p><strong>任选其一</strong></p>
<p><a href="http://ciweigg.github.io/2017/12/23/2017-08-14-redis" target="_blank" rel="noopener">CentOs7.3 搭建 Redis-4.0.1 单机服务</a></p>
<p><a href="http://ciweigg.github.io/2017/12/23/2017-08-14-redis-cluster" target="_blank" rel="noopener">CentOs7.3 搭建 Redis-4.0.1 Cluster 集群服务</a></p>
<a id="more"></a>
<h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><h1 id="Github-代码"><a href="#Github-代码" class="headerlink" title="Github 代码"></a>Github 代码</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>在项目中添加 <code>spring-boot-starter-data-redis</code> 依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="配置-RedisTemplate-实例"><a href="#配置-RedisTemplate-实例" class="headerlink" title="配置 RedisTemplate 实例"></a>配置 RedisTemplate 实例</h2><pre><code class="java">@Configuration
public class RedisConfig {

    private Logger LOG = LoggerFactory.getLogger(RedisConfig.class);

    @Bean
    JedisConnectionFactory jedisConnectionFactory() {
        return new JedisConnectionFactory();
    }

    @Bean
    public RedisTemplate&lt;String, String&gt; redisTemplate() {
        RedisTemplate&lt;String, String&gt; template = new RedisTemplate&lt;String, String&gt;();
        template.setConnectionFactory(jedisConnectionFactory());
        template.setKeySerializer(new StringRedisSerializer());
        LOG.info(&quot;create RedisTemplate success&quot;);
        return template;
    }
}
</code></pre>
<h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p><strong><code>application.properties</code></strong></p>
<pre><code># Redis数据库索引（默认为0）
spring.redis.database=0
# Redis服务器地址
spring.redis.host=127.0.0.1
# Redis服务器连接端口
spring.redis.port=6379
# Redis服务器连接密码（默认为空）
spring.redis.password=
# 连接池最大连接数（使用负值表示没有限制）
spring.redis.pool.max-active=8
# 连接池最大阻塞等待时间（使用负值表示没有限制）
spring.redis.pool.max-wait=-1
# 连接池中的最大空闲连接
spring.redis.pool.max-idle=8
# 连接池中的最小空闲连接
spring.redis.pool.min-idle=0
# 连接超时时间（毫秒）
spring.redis.timeout=0
</code></pre><h2 id="操作-Redis-工具类"><a href="#操作-Redis-工具类" class="headerlink" title="操作 Redis 工具类"></a>操作 Redis 工具类</h2><pre><code class="java">public class CacheUtils {

    @Resource
    private RedisTemplate&lt;String, String&gt; redisTemplate;
    private static CacheUtils cacheUtils;

    @PostConstruct
    public void init() {
        cacheUtils = this;
        cacheUtils.redisTemplate = this.redisTemplate;
    }

    /**
     * 保存到hash集合中
     *
     * @param hName 集合名
     * @param key
     * @param value
     */
    public static void hashSet(String hName, String key, String value) {
        cacheUtils.redisTemplate.opsForHash().put(hName, key, value);
    }

    /**
     * 从hash集合里取得
     *
     * @param hName
     * @param key
     * @return
     */

    public static Object hashGet(String hName, String key) {
        return cacheUtils.redisTemplate.opsForHash().get(hName, key);
    }

    /**
     省略 N 多方法
     。。。。。。
     */
}
</code></pre>
<h2 id="注册配置类到容器"><a href="#注册配置类到容器" class="headerlink" title="注册配置类到容器"></a>注册配置类到容器</h2><pre><code class="java">@Configuration
@Import({RedisConfig.class, CacheUtils.class})
public class RedisAutoConfiguration {

}
</code></pre>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><pre><code class="java">import io.ymq.redis.utils.CacheUtils;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.context.SpringBootTest;
import io.ymq.redis.run.Application;
import org.springframework.test.context.junit4.SpringRunner;

/**
 * 描述:测试类
 *
 * @author yanpenglei
 * @create 2017-10-16 13:18
 **/
@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class BaseTest {

    @Test
    public void test() throws Exception {

        CacheUtils.hashSet(&quot;test&quot;, &quot;ymq&quot;, &quot;www.ymq.io&quot;);

        System.out.println(CacheUtils.hashGet(&quot;test&quot;, &quot;ymq&quot;));
    }

}
</code></pre>
<p>github <a href="https://github.com/souyunku/spring-boot-examples/tree/master/spring-boot-redis" target="_blank" rel="noopener">https://github.com/souyunku/spring-boot-examples/tree/master/spring-boot-redis</a></p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cloud（六）服务网关 zuul 快速入门]]></title>
      <url>/2017/12/23/2017-12-10-spring-cloud-zuul/</url>
      <content type="html"><![CDATA[<p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p>
<p>路由在微服务体系结构的一个组成部分。例如，/可以映射到您的Web应用程序，<code>/api/users</code>映射到用户服务，并将<code>/api/shop</code>映射到商店服务。<code>Zuul</code>是<code>Netflix</code>的基于JVM的路由器和服务器端负载均衡器。</p>
<a id="more"></a>
<p><strong>Netflix使用Zuul进行以下操作：</strong></p>
<ul>
<li>认证  </li>
<li>洞察  </li>
<li>压力测试   </li>
<li>金丝雀测试  </li>
<li>动态路由  </li>
<li>服务迁移  </li>
<li>负载脱落  </li>
<li>安全  </li>
<li>静态响应处理    </li>
<li>主动/主动流量管理  </li>
</ul>
<p>Zuul的规则引擎允许基本上写任何JVM语言编写规则和过滤器，内置Java和Groovy。</p>
<h1 id="什么是服务网关"><a href="#什么是服务网关" class="headerlink" title="什么是服务网关"></a>什么是服务网关</h1><p><strong>服务网关 = 路由转发 + 过滤器</strong></p>
<p>1、路由转发：接收一切外界请求，转发到后端的微服务上去；</p>
<p>2、过滤器：在服务网关中可以完成一系列的横切功能，例如权限校验、限流以及监控等，这些都可以通过过滤器完成（其实路由转发也是通过过滤器实现的）。</p>
<h1 id="为什么需要服务网关"><a href="#为什么需要服务网关" class="headerlink" title="为什么需要服务网关"></a>为什么需要服务网关</h1><p><strong>上述所说的横切功能（以权限校验为例）可以写在三个位置：</strong></p>
<ul>
<li>每个服务自己实现一遍</li>
<li>写到一个公共的服务中，然后其他所有服务都依赖这个服务</li>
<li>写到服务网关的前置过滤器中，所有请求过来进行权限校验</li>
</ul>
<p><strong>第一种，缺点太明显，基本不用；</strong><br><strong>第二种，相较于第一点好很多，代码开发不会冗余，但是有两个缺点：</strong></p>
<ul>
<li>由于每个服务引入了这个公共服务，那么相当于在每个服务中都引入了相同的权限校验的代码，使得每个服务的jar包大小无故增加了一些，尤其是对于使用docker镜像进行部署的场景，jar越小越好；</li>
<li>由于每个服务都引入了这个公共服务，那么我们后续升级这个服务可能就比较困难，而且公共服务的功能越多，升级就越难，而且假设我们改变了公共服务中的权限校验的方式，想让所有的服务都去使用新的权限校验方式，我们就需要将之前所有的服务都重新引包，编译部署。</li>
</ul>
<p><strong>而服务网关恰好可以解决这样的问题：</strong></p>
<ul>
<li>将权限校验的逻辑写在网关的过滤器中，后端服务不需要关注权限校验的代码，所以服务的jar包中也不会引入权限校验的逻辑，不会增加jar包大小；</li>
<li>如果想修改权限校验的逻辑，只需要修改网关中的权限校验过滤器即可，而不需要升级所有已存在的微服务。</li>
</ul>
<p><strong>所以，需要服务网关！！！</strong></p>
<h1 id="服务网关技术选型"><a href="#服务网关技术选型" class="headerlink" title="服务网关技术选型"></a>服务网关技术选型</h1><p><img src="http://www.ymq.io/images/2017/SpringCloud/zuul/1.png" alt="服务网关"></p>
<p><strong>引入服务网关后的微服务架构如上，总体包含三部分：服务网关、open-service和service。</strong></p>
<p><strong>1、总体流程：</strong></p>
<ul>
<li>服务网关、open-service和service启动时注册到注册中心上去；</li>
<li>用户请求时直接请求网关，网关做智能路由转发（包括服务发现，负载均衡）到open-service，这其中包含权限校验、监控、限流等操作</li>
<li>open-service聚合内部service响应，返回给网关，网关再返回给用户</li>
</ul>
<p><strong>2、引入网关的注意点</strong></p>
<ul>
<li>增加了网关，多了一层转发（原本用户请求直接访问open-service即可），性能会下降一些（但是下降不大，通常，网关机器性能会很好，而且网关与open-service的访问通常是内网访问，速度很快）；</li>
<li>网关的单点问题：在整个网络调用过程中，一定会有一个单点，可能是网关、nginx、dns服务器等。防止网关单点，可以在网关层前边再挂一台nginx，nginx的性能极高，基本不会挂，这样之后，网关服务就可以不断的添加机器。但是这样一个请求就转发了两次，所以最好的方式是网关单点服务部署在一台牛逼的机器上（通过压测来估算机器的配置），而且nginx与zuul的性能比较，根据国外的一个哥们儿做的实验来看，其实相差不大，zuul是netflix开源的一个用来做网关的开源框架；</li>
<li>网关要尽量轻。</li>
</ul>
<p><strong>3、服务网关基本功能</strong></p>
<ul>
<li>智能路由：接收外部一切请求，并转发到后端的对外服务open-service上去；</li>
<li>注意：我们只转发外部请求，服务之间的请求不走网关，这就表示全链路追踪、内部服务API监控、内部服务之间调用的容错、智能路由不能在网关完成；当然，也可以将所有的服务调用都走网关，那么几乎所有的功能都可以集成到网关中，但是这样的话，网关的压力会很大，不堪重负。</li>
<li>权限校验：只校验用户向open-service服务的请求，不校验服务内部的请求。服务内部的请求有必要校验吗？</li>
<li>API监控：只监控经过网关的请求，以及网关本身的一些性能指标（例如，gc等）；</li>
<li>限流：与监控配合，进行限流操作；</li>
<li>API日志统一收集：类似于一个aspect切面，记录接口的进入和出去时的相关日志</li>
<li>。。。后续补充</li>
</ul>
<p><strong>4、技术选型</strong></p>
<p>笔者准备自建一个轻量级的服务网关，技术选型如下：</p>
<ul>
<li>开发语言：java + groovy，groovy的好处是网关服务不需要重启就可以动态的添加filter来实现一些功能；  </li>
<li>微服务基础框架：springboot；  </li>
<li>网关基础组件：netflix zuul；  </li>
<li>服务注册中心：consul；   </li>
<li>权限校验：jwt；  </li>
<li>API监控：prometheus + grafana；  </li>
<li>API统一日志收集：logback + ELK；  </li>
<li>压力测试：Jmeter；  </li>
<li>。。。后续补充  </li>
<li>在后续的介绍中，会逐渐介绍各个知识点，并完成一个轻量级的服务网关！！！  </li>
</ul>
<h1 id="Spring-Cloud-Zuul"><a href="#Spring-Cloud-Zuul" class="headerlink" title="Spring Cloud Zuul"></a>Spring Cloud Zuul</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><strong>新建项目</strong> <code>spring-cloud-zuul-service</code></p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="开启服务注册"><a href="#开启服务注册" class="headerlink" title="开启服务注册"></a>开启服务注册</h3><p>在程序的启动类 <code>ZuulApplication</code> 通过 <code>@EnableZuulProxy</code> 开启 Zuul 服务网关</p>
<pre><code class="java">package io.ymq.example;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;

@EnableZuulProxy
@SpringBootApplication
public class ZuulApplication {

    public static void main(String[] args) {
        SpringApplication.run(ZuulApplication.class, args);
    }
}
</code></pre>
<h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><p>配置文件 <code>application.yml</code></p>
<pre><code class="sh">spring:
  application:
    name: zuul-service

server:
  port: 9000

zuul:
  routes:
    blog:
        path: /ymq/**
        url: http://www.ymq.io/
</code></pre>
<h3 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h3><p><strong>配置说明：</strong></p>
<p>浏览器访问:<a href="http://127.0.0.1:9000/ymq" target="_blank" rel="noopener">http://127.0.0.1:9000/ymq</a> 重定向到我的博客</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/zuul/2.png" alt="浏览器访问"></p>
<h2 id="服务转发"><a href="#服务转发" class="headerlink" title="服务转发"></a>服务转发</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>项目继续改造，添加依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>配置文件 <code>application.yml</code></p>
<pre><code class="sh">zuul:
  routes:
    api:
        path: /**
        serviceId: eureka-provider

eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
</code></pre>
<p><strong>配置说明：</strong></p>
<p>浏览器访问:<a href="http://127.0.0.1:9000/" target="_blank" rel="noopener">http://127.0.0.1:9000/</a> ,Zuul 会去 Eureka 服务注册中心，找到<code>eureka-provider</code>服务以均衡负载的方式访问</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在开始测试服务之前，我们先拿之前两篇博客，构建的两个微服务代码为基础，进行下面的操作，主要使用下面几个工程：</p>
<p><strong>建议先阅读以下两篇文章</strong></p>
<p><a href="http://www.ymq.io/2017/12/06/spring-cloud-feign/" target="_blank" rel="noopener">Spring Cloud（四） 服务提供者 Eureka + 服务消费者 Feign</a><br><a href="http://www.ymq.io/2017/12/05/spring-cloud-ribbon-rest/" target="_blank" rel="noopener">Spring Cloud（三） 服务提供者 Eureka + 服务消费者（rest + Ribbon）</a>  </p>
<ul>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider</a></li>
</ul>
<p>复制项目<code>spring-cloud-eureka-provider</code> 改为<code>spring-cloud-eureka-provider-2</code>  为了更好的体现 Zuul 访问服务负载均衡</p>
<p><strong>修改</strong> <code>EurekaProviderApplication.java</code>  home 方法的返回值</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient
@RestController
public class EurekaProviderApplication {

    @Value(&quot;${server.port}&quot;)
    String port;

    @RequestMapping(&quot;/&quot;)
    public String home() {
        return &quot;Hello Zuul ,port:&quot; + port;
    }

    public static void main(String[] args) {
        SpringApplication.run(EurekaProviderApplication.class, args);
    }
}
</code></pre>
<p><strong>修改</strong> <code>application.yml</code> 修改一下提供服务的端口,<code>8762</code> 改成8763</p>
<pre><code class="sh">server:
  port: 8763
</code></pre>
<h3 id="测试服务"><a href="#测试服务" class="headerlink" title="测试服务"></a>测试服务</h3><p>依次启动四个服务：<code>spring-cloud-eureka-service</code>,<code>spring-cloud-eureka-provider</code>,<code>spring-cloud-eureka-provider-2</code>,<code>spring-cloud-zuul-service</code></p>
<p><strong>查看 eureka 监控，看服务是否都注册成功</strong></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/zuul/3.png" alt="浏览器访问"></p>
<p><strong>浏览器访问</strong></p>
<p>访问:<a href="http://127.0.0.1:9000/" target="_blank" rel="noopener">http://127.0.0.1:9000/</a> ,Zuul 会去 Eureka 服务注册中心，找到<code>eureka-provider</code>服务以均衡负载的方式访问</p>
<p><code>F5 刷新</code></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/zuul/4.png" alt="F5刷新浏览器访问"><br><img src="http://www.ymq.io/images/2017/SpringCloud/zuul/5.png" alt="F5刷新浏览器访问"></p>
<h3 id="网关的默认路由规则"><a href="#网关的默认路由规则" class="headerlink" title="网关的默认路由规则"></a>网关的默认路由规则</h3><p>spring cloud zuul 默认情况下，<code>Zuul</code>会代理所有注册到<code>Eureka Server</code>的微服务，并且Zuul的路由规则如下：<a href="">http://ZUUL_HOST:ZUUL_PORT/</a> 微服务在<code>Eureka</code>上的<code>serviceId/**</code>会被转发到<code>serviceId</code>对应的微服务。</p>
<p>我们注释 <code>spring-cloud-zuul-service</code>项目中关于路由的配置：</p>
<pre><code class="sh">#zuul:
#  routes:
#    api:
#        path: /**
#        serviceId: eureka-provider
</code></pre>
<p><strong>浏览器访问</strong></p>
<p>访问:<a href="http://127.0.0.1:9000/eureka-provider/" target="_blank" rel="noopener">http://127.0.0.1:9000/eureka-provider/</a> ,Zuul 会去 Eureka 服务注册中心，找到<code>eureka-provider</code>服务以均衡负载的方式访问</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/zuul/6.png" alt="F5刷新浏览器访问"><br><img src="http://www.ymq.io/images/2017/SpringCloud/zuul/7.png" alt="F5刷新浏览器访问"></p>
<h2 id="ZuulFilter"><a href="#ZuulFilter" class="headerlink" title="ZuulFilter"></a>ZuulFilter</h2><p>在下一章，会深入介绍 Zuul 高级功能使用，<code>ZuulFilter</code> ,支持下鹏磊，关注下屏幕下方的微信公众号</p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><ul>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider-2" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider-2</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-zuul-service" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-zuul-service</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cloud（五）断路器监控(Hystrix Dashboard)]]></title>
      <url>/2017/12/23/2017-12-07-spring-cloud-hystrix-dashboard/</url>
      <content type="html"><![CDATA[<p>在上两篇文章中讲了，服务提供者 Eureka + 服务消费者 Feign，服务提供者 Eureka + 服务消费者（rest + Ribbon），本篇文章结合，上两篇文章中代码进行修改加入 断路器监控(Hystrix Dashboard)</p>
<p>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p>
<p>针对上述问题，在Spring Cloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。</p>
<a id="more"></a>
<h1 id="什么是断路器"><a href="#什么是断路器" class="headerlink" title="什么是断路器"></a>什么是断路器</h1><p>断路器模式源于Martin Fowler的Circuit Breaker一文。“断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，防止发生过载、发热、甚至起火等严重后果。</p>
<p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p>
<h1 id="断路器示意图"><a href="#断路器示意图" class="headerlink" title="断路器示意图"></a>断路器示意图</h1><p>SpringCloud Netflix实现了断路器库的名字叫Hystrix. 在微服务架构下，通常会有多个层次的服务调用. 下面是微服架构下, 浏览器端通过API访问后台微服务的一个示意图：</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/hystrix/8.png" alt=" hystrix 1"></p>
<p>一个微服务的超时失败可能导致瀑布式连锁反映，下图中，Hystrix通过自主反馈实现的断路器， 防止了这种情况发生。</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/hystrix/9.png" alt=" hystrix 2"></p>
<p>图中的服务B因为某些原因失败，变得不可用，所有对服务B的调用都会超时。当对B的调用失败达到一个特定的阀值(5秒之内发生20次失败是Hystrix定义的缺省值), 链路就会被处于open状态， 之后所有所有对服务B的调用都不会被执行， 取而代之的是由断路器提供的一个表示链路open的Fallback消息.  Hystrix提供了相应机制，可以让开发者定义这个Fallbak消息.</p>
<p>open的链路阻断了瀑布式错误， 可以让被淹没或者错误的服务有时间进行修复。这个fallback可以是另外一个Hystrix保护的调用, 静态数据，或者合法的空值. Fallbacks可以组成链式结构，所以，最底层调用其它业务服务的第一个Fallback返回静态数据.</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在开始加入断路器之前，我们先拿之前两篇博客，构建的两个微服务代码为基础，进行下面的操作，主要使用下面几个工程：</p>
<p><strong>建议先阅读以下两篇文章</strong></p>
<p><a href="http://www.ymq.io/2017/12/06/spring-cloud-feign/" target="_blank" rel="noopener">Spring Cloud（四） 服务提供者 Eureka + 服务消费者 Feign</a><br><a href="http://www.ymq.io/2017/12/05/spring-cloud-ribbon-rest/" target="_blank" rel="noopener">Spring Cloud（三） 服务提供者 Eureka + 服务消费者（rest + Ribbon）</a>  </p>
<ul>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider</a></li>
</ul>
<p><strong>主要修改以下项目</strong></p>
<ul>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-feign-consumer" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-feign-consumer</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-ribbon-consumer" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-ribbon-consumer</a></li>
</ul>
<h2 id="Ribbon-Hystrix"><a href="#Ribbon-Hystrix" class="headerlink" title="Ribbon Hystrix"></a>Ribbon Hystrix</h2><p><strong>首先启动，<code>spring-cloud-eureka-service</code>,<code>spring-cloud-eureka-provider</code> 项目</strong></p>
<h3 id="修改依赖"><a href="#修改依赖" class="headerlink" title="修改依赖"></a>修改依赖</h3><p>复制 <code>spring-cloud-ribbon-consumer</code> 项目,修改名称为<code>spring-cloud-ribbon-consumer-hystrix</code> 在项目 <code>pom.xml</code>中引入需要的依赖内容：</p>
<pre><code class="xml">&lt;!-- hystrix 断路器 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="开启服务注册"><a href="#开启服务注册" class="headerlink" title="开启服务注册"></a>开启服务注册</h3><p>在程序的启动类 <code>RibbonConsumerApplication</code> 通过 <code>@EnableHystrix</code> 开启 Hystrix 断路器监控</p>
<pre><code class="java">package io.ymq.example.ribbon.consumer.hystrix;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@EnableHystrix
@EnableDiscoveryClient
@SpringBootApplication
public class RibbonConsumerApplication {

    @LoadBalanced
    @Bean
    RestTemplate restTemplate() {
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(RibbonConsumerApplication.class, args);
    }
}
</code></pre>
<h3 id="消费提供者方法"><a href="#消费提供者方法" class="headerlink" title="消费提供者方法"></a>消费提供者方法</h3><p>修改 <code>ConsumerController</code> 类的，<code>hello</code> 方法，加上注解<code>@HystrixCommand(fallbackMethod = &quot;defaultStores&quot;)</code>  该注解对该方法创建了熔断器的功能<br>,并指定了<code>defaultStores</code>熔断方法，熔断方法直接返回了一个字符串， <code>&quot;feign + hystrix ,提供者服务挂了&quot;</code></p>
<p>@HystrixCommand 表明该方法为hystrix包裹，可以对依赖服务进行隔离、降级、快速失败、快速重试等等hystrix相关功能<br>该注解属性较多，下面讲解其中几个</p>
<ul>
<li>fallbackMethod 降级方法</li>
<li>commandProperties 普通配置属性，可以配置HystrixCommand对应属性，例如采用线程池还是信号量隔离、熔断器熔断规则等等</li>
<li>ignoreExceptions 忽略的异常，默认HystrixBadRequestException不计入失败</li>
<li>groupKey() 组名称，默认使用类名称</li>
<li>commandKey 命令名称，默认使用方法名</li>
</ul>
<pre><code class="java">package io.ymq.example.ribbon.consumer.hystrix;

import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

/**
 * 描述:调用提供者的 `home` 方法
 *
 * @author yanpenglei
 * @create 2017-12-05 18:53
 **/
@RestController
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;

    @HystrixCommand(fallbackMethod = &quot;defaultStores&quot;)
    @GetMapping(value = &quot;/hello&quot;)
    public String hello() {
        return restTemplate.getForEntity(&quot;http://eureka-provider/&quot;, String.class).getBody();
    }

    public String defaultStores() {
        return &quot;feign + hystrix ,提供者服务挂了&quot;;
    }

}
</code></pre>
<h3 id="测试断路器"><a href="#测试断路器" class="headerlink" title="测试断路器"></a>测试断路器</h3><p>启动工程后</p>
<ul>
<li>访问：<a href="http://127.0.0.1:9000/hello" target="_blank" rel="noopener">http://127.0.0.1:9000/hello</a> ,发现一切正常</li>
</ul>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/hystrix/1.png" alt="eureka-provider 提供者服务响应"></p>
<p><strong>停止 eureka-provider  服务</strong></p>
<ul>
<li>再次访问<a href="http://127.0.0.1:9000/" target="_blank" rel="noopener">http://127.0.0.1:9000/</a> ,断路器已经生效</li>
</ul>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/hystrix/2.png" alt="feign + hystrix ,提供者服务挂了"></p>
<h2 id="Feign-Hystrix"><a href="#Feign-Hystrix" class="headerlink" title="Feign Hystrix"></a>Feign Hystrix</h2><p>在 Feign中使用断路器</p>
<p><strong>首先启动，<code>spring-cloud-eureka-service</code>,<code>spring-cloud-eureka-provider</code> 项目</strong></p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>复制<code>spring-cloud-feign-consumer</code> 项目,修改名称为<code>spring-cloud-feign-consumer-hystrix</code> 修改配置文件，</p>
<p>Feign是自带断路器的，在D版本的Spring Cloud中，它没有默认打开。需要在配置文件中配置打开它</p>
<pre><code class="sh">feign:
  hystrix:
    enabled: true
</code></pre>
<h3 id="开启服务注册-1"><a href="#开启服务注册-1" class="headerlink" title="开启服务注册"></a>开启服务注册</h3><p>修改 HomeClient 类 ，<code>@FeignClient</code> 注解，加上fallback的指定类就行了</p>
<p>在程序的启动类 <code>RibbonConsumerApplication</code> 通过 <code>@EnableHystrix</code> 开启 Hystrix</p>
<pre><code class="java">package io.ymq.example.feign.consumer.hystrix;

import org.springframework.cloud.netflix.feign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

/**
 * 描述: 指定这个接口所要调用的 提供者服务名称 &quot;eureka-provider&quot;
 *
 * @author yanpenglei
 * @create 2017-12-06 15:13
 **/
@FeignClient(value =&quot;eureka-provider&quot;,fallbackFactory = HystrixClientFallbackFactory.class)
public interface  HomeClient {

    @GetMapping(&quot;/&quot;)
    String consumer();
}
</code></pre>
<p><strong>新加的类 <code>HystrixClientFallbackFactory</code></strong></p>
<pre><code class="java">package io.ymq.example.feign.consumer.hystrix;

import feign.hystrix.FallbackFactory;
import org.springframework.stereotype.Component;

/**
 * 描述:
 *
 * @author yanpenglei
 * @create 2017-12-07 20:37
 **/
@Component
public class HystrixClientFallbackFactory implements FallbackFactory&lt;HomeClient&gt; {

    @Override
    public HomeClient create(Throwable throwable) {
        return () -&gt; &quot;feign + hystrix ,提供者服务挂了&quot;;
    }
}
</code></pre>
<h3 id="测试断路器-1"><a href="#测试断路器-1" class="headerlink" title="测试断路器"></a>测试断路器</h3><p>启动工程后</p>
<ul>
<li>访问：<a href="http://127.0.0.1:9000/hello" target="_blank" rel="noopener">http://127.0.0.1:9000/hello</a> ,发现一切正常</li>
</ul>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/hystrix/3.png" alt="eureka-provider 提供者服务响应"></p>
<p><strong>停止 eureka-provider  服务</strong></p>
<ul>
<li>再次访问<a href="http://127.0.0.1:9000/hello" target="_blank" rel="noopener">http://127.0.0.1:9000/hello</a> ,断路器已经生效</li>
</ul>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/hystrix/4.png" alt="feign + hystrix ,提供者服务挂了"></p>
<h2 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix Dashboard"></a>Hystrix Dashboard</h2><h3 id="Hystrix-Dashboard简介"><a href="#Hystrix-Dashboard简介" class="headerlink" title="Hystrix Dashboard简介"></a>Hystrix Dashboard简介</h3><p>在微服务架构中为例保证程序的可用性，防止程序出错导致网络阻塞，出现了断路器模型。断路器的状况反应了一个程序的可用性和健壮性，它是一个重要指标。Hystrix Dashboard是作为断路器状态的一个组件，提供了数据监控和友好的图形化界面。</p>
<h3 id="改造项目"><a href="#改造项目" class="headerlink" title="改造项目"></a>改造项目</h3><p>修改 <code>spring-cloud-ribbon-consumer-hystrix</code>  在它的基础上进行改造。 Feign的改造和这一样。</p>
<p>在pom的工程文件引入相应的依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>修改 <code>RibbonConsumerApplication</code> 类</p>
<p>在程序的入口<code>RibbonConsumerApplication</code>类，加上@EnableHystrix注解开启断路器，这个是必须的，并且需要在程序中声明断路点@HystrixCommand；加上@EnableHystrixDashboard注解，开启HystrixDashboard</p>
<pre><code class="java">package io.ymq.example.ribbon.consumer.hystrix;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@EnableHystrix
@EnableDiscoveryClient
@EnableHystrixDashboard
@SpringBootApplication
public class RibbonConsumerApplication {

    @LoadBalanced
    @Bean
    RestTemplate restTemplate() {
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(RibbonConsumerApplication.class, args);
    }
}
</code></pre>
<p>声明断路点 <code>@HystrixCommand(fallbackMethod = &quot;defaultStores&quot;)</code>  </p>
<pre><code class="java">package io.ymq.example.ribbon.consumer.hystrix;

import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

/**
 * 描述:调用提供者的 `home` 方法
 *
 * @author yanpenglei
 * @create 2017-12-05 18:53
 **/
@RestController
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;

    @HystrixCommand(fallbackMethod = &quot;defaultStores&quot;)
    @GetMapping(value = &quot;/hello&quot;)
    public String hello() {
        return restTemplate.getForEntity(&quot;http://eureka-provider/&quot;, String.class).getBody();
    }

    public String defaultStores() {
        return &quot;feign + hystrix Dashboard ,提供者服务挂了&quot;;
    }

}
</code></pre>
<p>@HystrixCommand 表明该方法为hystrix包裹，可以对依赖服务进行隔离、降级、快速失败、快速重试等等hystrix相关功能<br>该注解属性较多，下面讲解其中几个</p>
<ul>
<li>fallbackMethod 降级方法</li>
<li>commandProperties 普通配置属性，可以配置HystrixCommand对应属性，例如采用线程池还是信号量隔离、熔断器熔断规则等等</li>
<li>ignoreExceptions 忽略的异常，默认HystrixBadRequestException不计入失败</li>
<li>groupKey() 组名称，默认使用类名称</li>
<li>commandKey 命令名称，默认使用方法名</li>
</ul>
<h3 id="测试-Hystrix-Dashboard"><a href="#测试-Hystrix-Dashboard" class="headerlink" title="测试 Hystrix Dashboard"></a>测试 Hystrix Dashboard</h3><p>运行工程</p>
<p><strong>停止 eureka-provider 服务</strong></p>
<ul>
<li>访问<a href="http://127.0.0.1:9000/hello" target="_blank" rel="noopener">http://127.0.0.1:9000/hello</a> ,断路器已经生效</li>
</ul>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/hystrix/5.png" alt="feign + hystrix Dashboard ,提供者服务挂了"></p>
<p><strong>Dashboard 监控</strong></p>
<ul>
<li>可以访问 <a href="http://127.0.0.1:9090/hystrix" target="_blank" rel="noopener">http://127.0.0.1:9090/hystrix.stream</a> ,获取dashboard信息，默认最大打开5个终端获取监控信息，可以增加delay参数指定获取监控数据间隔时间</li>
</ul>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/hystrix/6.png" alt=" hystrix stream"></p>
<p>在界面依次输入：<code>http://127.0.0.1:9090/hystrix</code> 、<code>2000</code> 、<code>hello</code> 点确定。可以访问以下，图形化监控页面</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/hystrix/7.png" alt=" hystrix 图形化监控页面"></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><ul>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-hystrix/spring-cloud-ribbon-consumer-hystrix" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-hystrix/spring-cloud-ribbon-consumer-hystrix</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-hystrix/spring-cloud-feign-consumer-hystrix" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-hystrix/spring-cloud-feign-consumer-hystrix</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-hystrix/spring-cloud-ribbon-consumer-hystrix-dashboard" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-hystrix/spring-cloud-ribbon-consumer-hystrix-dashboard</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cloud（四）服务提供者 Eureka + 服务消费者 Feign]]></title>
      <url>/2017/12/23/2017-12-06-spring-cloud-feign/</url>
      <content type="html"><![CDATA[<p>上一篇文章，讲述了如何通过RestTemplate+Ribbon去消费服务，这篇文章主要讲述如何通过Feign去消费服务。</p>
<h1 id="一、Feign简介"><a href="#一、Feign简介" class="headerlink" title="一、Feign简介"></a>一、Feign简介</h1><p>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。</p>
<p>Feign 具有如下特性：</p>
<ul>
<li>可插拔的注解支持，包括Feign注解和JAX-RS注解</li>
<li>支持可插拔的HTTP编码器和解码器</li>
<li>支持Hystrix和它的Fallback</li>
<li>支持Ribbon的负载均衡</li>
<li><p>支持HTTP请求和响应的压缩 Feign是一个声明式的Web Service客户端，它的目的就是让Web Service调用更加简单。它整合了Ribbon和Hystrix，从而不再需要显式地使用这两个组件。Feign还提供了HTTP请求的模板，通过编写简单的接口和注解，就可以定义好HTTP请求的参数、格式、地址等信息。接下来，Feign会完全代理HTTP的请求，我们只需要像调用方法一样调用它就可以完成服务请求。</p>
<a id="more"></a>
</li>
</ul>
<p>简而言之：Feign能干Ribbon和Hystrix的事情，但是要用Ribbon和Hystrix自带的注解必须要引入相应的jar包才可以。</p>
<h2 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h2><p><strong>提供服务注册和发现服务</strong></p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在项目 <code>spring-cloud-eureka-service</code> <code>pom.xml</code>中引入需要的依赖内容：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="开启服务注册"><a href="#开启服务注册" class="headerlink" title="开启服务注册"></a>开启服务注册</h3><p>通过 <code>@EnableEurekaServer</code> 注解启动一个服务注册中心提供给其他应用进行对话,这个注解需要在springboot工程的启动application类上加</p>
<pre><code class="java">package io.ymq.example.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class EurekaApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
</code></pre>
<h3 id="配置-Eureka-服务"><a href="#配置-Eureka-服务" class="headerlink" title="配置 Eureka 服务"></a>配置 Eureka 服务</h3><p>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在<code>application.yml</code>配置文件中增加如下信息：</p>
<pre><code class="sh">registerWithEureka: false
fetchRegistry: false
</code></pre>
<p>完整配置</p>
<pre><code class="sh">server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
</code></pre>
<h3 id="启动服务注册中心"><a href="#启动服务注册中心" class="headerlink" title="启动服务注册中心"></a>启动服务注册中心</h3><p>启动工程后，访问：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a></p>
<p>可以看到下面的页面，其中还没有发现任何服务。</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/feign/1.png" alt=" System Status "></p>
<h2 id="Eureka-Provider"><a href="#Eureka-Provider" class="headerlink" title="Eureka Provider"></a>Eureka Provider</h2><p><strong>服务提供者</strong></p>
<ul>
<li>将自身服务注册到 <code>Eureka Service</code>，从而使服务消费方能够找到</li>
</ul>
<h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在项目 <code>spring-cloud-eureka-provider</code> <code>pom.xml</code>中引入需要的依赖内容：</p>
<pre><code class="xml">&lt;!-- spring boot eureka server --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="开启服务注册-1"><a href="#开启服务注册-1" class="headerlink" title="开启服务注册"></a>开启服务注册</h3><p>在应用主类中通过加上 @EnableEurekaClient，但只有Eureka可用，你也可以使用@EnableDiscoveryClient。需要配置才能找到Eureka服务器</p>
<pre><code class="java">package io.ymq.example.eureka.provider;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@EnableEurekaClient
@RestController
public class EurekaProviderApplication {

    @Value(&quot;${server.port}&quot;)
    String port;

    @RequestMapping(&quot;/&quot;)
    public String home() {
        return &quot;Hello world ,port:&quot; + port;
    }

    public static void main(String[] args) {
        SpringApplication.run(EurekaProviderApplication.class, args);
    }
}
</code></pre>
<h3 id="配置-Eureka-Server-服务"><a href="#配置-Eureka-Server-服务" class="headerlink" title="配置 Eureka Server 服务"></a>配置 Eureka Server 服务</h3><p>需要配置才能找到Eureka服务器。例：</p>
<p>完整配置 <code>application.yml</code></p>
<pre><code class="sh">eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/

spring:
  application:
    name: eureka-provider

server:
  port: 8762
</code></pre>
<h3 id="启动提供者"><a href="#启动提供者" class="headerlink" title="启动提供者"></a>启动提供者</h3><p>启动该工程后，再次访问启动工程后：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a></p>
<p>可以如下图内容，我们定义的服务被成功注册了。</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/feign/2.png" alt=" eureka-provider"></p>
<h2 id="多个-Eureka-Provider"><a href="#多个-Eureka-Provider" class="headerlink" title="多个 Eureka Provider"></a>多个 Eureka Provider</h2><p>修改 <code>spring-cloud-eureka-provider</code> 配置文件<code>application.yml</code> 里的端口：<code>8762</code> 改成 <code>8763</code> maven 打包 后发布</p>
<p><strong>maven 打包</strong></p>
<pre><code class="sh">F:\spring-cloud-examples\spring-cloud-eureka-provider&gt; mvn clean package

....
Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO]
[INFO] --- maven-jar-plugin:2.6:jar (default-jar) @ spring-cloud-eureka-provider ---
[INFO] Building jar: F:\spring-cloud-examples\spring-cloud-eureka-provider\target\spring-cloud-eureka-provider-0.0.1-SNAPSHOT.jar
[INFO]
[INFO] --- spring-boot-maven-plugin:1.5.9.RELEASE:repackage (default) @ spring-cloud-eureka-provider ---
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 23.848 s
[INFO] Finished at: 2017-12-05T20:26:25+08:00
[INFO] Final Memory: 47M/421M
[INFO] ------------------------------------------------------------------------
F:\spring-cloud-examples\spring-cloud-eureka-provider&gt;
</code></pre>
<p><strong>把 maven打好的包，放入不同的目录，本地发布</strong></p>
<pre><code class="sh">java -jar spring-cloud-eureka-provider-0.0.1-SNAPSHOT.jar
</code></pre>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/feign/3.png" alt="发布 eureka-provider 8762 端口"></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/feign/4.png" alt="发布 eureka-provider 8763 端口"></p>
<h3 id="查看提供者服务"><a href="#查看提供者服务" class="headerlink" title="查看提供者服务"></a>查看提供者服务</h3><p>启动该工程后，再次访问启动工程后：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/feign/5.png" alt="查看提供者服务"></p>
<h2 id="Feign-Consumer"><a href="#Feign-Consumer" class="headerlink" title="Feign Consumer"></a>Feign Consumer</h2><p><strong>服务消费者</strong></p>
<h3 id="添加依赖-2"><a href="#添加依赖-2" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在项目 <code>spring-cloud-feign-consumer</code> <code>pom.xml</code>中引入需要的依赖内容：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="开启服务负载均衡"><a href="#开启服务负载均衡" class="headerlink" title="开启服务负载均衡"></a>开启服务负载均衡</h3><p>在工程的启动类中,通过<code>@EnableFeignClients</code> 注解开启Feign的功能：</p>
<pre><code class="java">package io.ymq.example.feign.consumer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.feign.EnableFeignClients;

@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
public class FeignConsumerApplication {

    public static void main(String[] args) {
        SpringApplication.run(FeignConsumerApplication.class, args);
    }
}
</code></pre>
<h3 id="定义一个Feign接口"><a href="#定义一个Feign接口" class="headerlink" title="定义一个Feign接口"></a>定义一个Feign接口</h3><p>通过<code>@FeignClient（“服务名”）</code>，来指定调用哪个服务。比如在代码中调用了<code>eureka-provider</code>服务的 <code>/</code> 接口，<code>/</code> 就是调用：服务提供者项目：<code>spring-cloud-eureka-provider</code>  <code>home()</code> 方法，代码如下：</p>
<pre><code class="java">package io.ymq.example.feign.consumer;

import org.springframework.cloud.netflix.feign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

/**
 * 描述: 指定这个接口所要调用的 提供者服务名称 &quot;eureka-provider&quot;
 *
 * @author yanpenglei
 * @create 2017-12-06 15:13
 **/
@FeignClient(&quot;eureka-provider&quot;)
public interface  HomeClient {

    @GetMapping(&quot;/&quot;)
    String consumer();
}
</code></pre>
<h3 id="消费提供者方法"><a href="#消费提供者方法" class="headerlink" title="消费提供者方法"></a>消费提供者方法</h3><p>写一个 <code>controller</code>，调用提供者的 <code>home</code> 方法</p>
<pre><code>package io.ymq.example.feign.consumer;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 描述:调用提供者的 `home` 方法
 *
 * @author yanpenglei
 * @create 2017-12-06 15:26
 **/
@RestController
public class ConsumerController {

    @Autowired
    private HomeClient homeClient;

    @GetMapping(value = &quot;/hello&quot;)
    public String hello() {
        return  homeClient.consumer();
    }
}
</code></pre><h3 id="配置-Feign-服务"><a href="#配置-Feign-服务" class="headerlink" title="配置 Feign 服务"></a>配置 Feign 服务</h3><p>完整配置 <code>application.yml</code></p>
<pre><code class="sh">eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/

spring:
  application:
    name: feign-consumer

server:
  port: 9000
</code></pre>
<h3 id="启动消费者"><a href="#启动消费者" class="headerlink" title="启动消费者"></a>启动消费者</h3><p>启动该工程后，再次访问：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a> </p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/feign/6.png" alt="查看 Ribbon 注册状态"></p>
<h3 id="负载均衡响应"><a href="#负载均衡响应" class="headerlink" title="负载均衡响应"></a>负载均衡响应</h3><p><strong>浏览器 F5 刷新，发现已经实现负载均衡</strong></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/feign/7.png" alt="测试提供者，负载均衡响应"></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/feign/8.png" alt="测试提供者，负载均衡响应"></p>
<p><strong>注意：spring-cloud-eureka-provider</strong> 项目，改成不同端口发布两次</p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><ul>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-feign-consumer" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-feign-consumer</a></li>
</ul>
<p>出处：<a href="http://www.ymq.io" target="_blank" rel="noopener">http://www.ymq.io</a><br>转自：鹏磊</p>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cloud（三）服务提供者 Eureka + 服务消费者（rest + Ribbon）]]></title>
      <url>/2017/12/23/2017-12-05-spring-cloud-ribbon-rest/</url>
      <content type="html"><![CDATA[<p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。</p>
<a id="more"></a>
<h1 id="Ribbon是什么？"><a href="#Ribbon是什么？" class="headerlink" title="Ribbon是什么？"></a>Ribbon是什么？</h1><p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。</p>
<h1 id="LB方案分类"><a href="#LB方案分类" class="headerlink" title="LB方案分类"></a>LB方案分类</h1><p>目前主流的LB方案可分成两类：一种是集中式LB, 即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；另一种是进程内LB，将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于后者，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p>
<h1 id="Ribbon的主要组件与工作流程"><a href="#Ribbon的主要组件与工作流程" class="headerlink" title="Ribbon的主要组件与工作流程"></a>Ribbon的主要组件与工作流程</h1><p>微服务架构的核心思想是，一个应用是由多个小的、相互独立的、微服务组成，这些服务运行在自己的进程中，开发和发布都没有依赖。<br>不同服务通过一些轻量级交互机制来通信，例如 RPC、HTTP 等，服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。<br>简单的来说，一个系统的不同模块转变成不同的服务！而且服务可以使用不同的技术加以实现！</p>
<h1 id="Ribbon的核心组件"><a href="#Ribbon的核心组件" class="headerlink" title="Ribbon的核心组件"></a>Ribbon的核心组件</h1><p><code>均为接口类型,有以下几个：</code></p>
<p><strong>ServerList</strong> </p>
<ul>
<li>用于获取地址列表。它既可以是静态的(提供一组固定的地址)，也可以是动态的(从注册中心中定期查询地址列表)。</li>
</ul>
<p><strong>ServerListFilter</strong> </p>
<ul>
<li>仅当使用动态ServerList时使用，用于在原始的服务列表中使用一定策略过虑掉一部分地址。</li>
</ul>
<p><strong>IRule</strong> </p>
<ul>
<li>选择一个最终的服务地址作为LB结果。选择策略有轮询、根据响应时间加权、断路器(当Hystrix可用时)等。</li>
</ul>
<p>Ribbon在工作时首选会通过ServerList来获取所有可用的服务列表，然后通过ServerListFilter过虑掉一部分地址，最后在剩下的地址中通过IRule选择出一台服务器作为最终结果。</p>
<h1 id="Ribbon提供的主要负载均衡策略介绍"><a href="#Ribbon提供的主要负载均衡策略介绍" class="headerlink" title="Ribbon提供的主要负载均衡策略介绍"></a>Ribbon提供的主要负载均衡策略介绍</h1><p><strong>简单轮询负载均衡（RoundRobin）</strong></p>
<p>以轮询的方式依次将请求调度不同的服务器，即每次调度执行i = (i + 1) mod n，并选出第i台服务器。</p>
<p><strong>随机负载均衡 （Random）</strong></p>
<p>随机选择状态为UP的Server</p>
<p><strong>加权响应时间负载均衡 （WeightedResponseTime）</strong></p>
<p>根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。</p>
<p><strong>区域感知轮询负载均衡（ZoneAvoidanceRule）</strong></p>
<p>复合判断server所在区域的性能和server的可用性选择server</p>
<h2 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h2><p><strong>提供服务注册和发现服务</strong></p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在项目 <code>spring-cloud-eureka-service</code> <code>pom.xml</code>中引入需要的依赖内容：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="开启服务注册"><a href="#开启服务注册" class="headerlink" title="开启服务注册"></a>开启服务注册</h3><p>通过 <code>@EnableEurekaServer</code> 注解启动一个服务注册中心提供给其他应用进行对话,这个注解需要在springboot工程的启动application类上加</p>
<pre><code class="java">package io.ymq.example.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class EurekaApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
</code></pre>
<h3 id="配置-Eureka-服务"><a href="#配置-Eureka-服务" class="headerlink" title="配置 Eureka 服务"></a>配置 Eureka 服务</h3><p>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在<code>application.yml</code>配置文件中增加如下信息：</p>
<pre><code class="sh">registerWithEureka: false
fetchRegistry: false
</code></pre>
<p>完整配置</p>
<pre><code class="sh">server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
</code></pre>
<h3 id="启动服务注册中心"><a href="#启动服务注册中心" class="headerlink" title="启动服务注册中心"></a>启动服务注册中心</h3><p>启动工程后，访问：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a></p>
<p>可以看到下面的页面，其中还没有发现任何服务。</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/ribbon/1.png" alt=" System Status "></p>
<h2 id="Eureka-Provider"><a href="#Eureka-Provider" class="headerlink" title="Eureka Provider"></a>Eureka Provider</h2><p><strong>服务提供者</strong></p>
<ul>
<li>将自身服务注册到 <code>Eureka Service</code>，从而使服务消费方能够找到</li>
</ul>
<h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在项目 <code>spring-cloud-eureka-provider</code> <code>pom.xml</code>中引入需要的依赖内容：</p>
<pre><code class="xml">&lt;!-- spring boot eureka server --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="开启服务注册-1"><a href="#开启服务注册-1" class="headerlink" title="开启服务注册"></a>开启服务注册</h3><p>在应用主类中通过加上 @EnableEurekaClient，但只有Eureka可用，你也可以使用@EnableDiscoveryClient。需要配置才能找到Eureka服务器</p>
<pre><code class="java">package io.ymq.example.eureka.provider;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@EnableEurekaClient
@RestController
public class EurekaProviderApplication {

    @Value(&quot;${server.port}&quot;)
    String port;

    @RequestMapping(&quot;/&quot;)
    public String home() {
        return &quot;Hello world ,port:&quot; + port;
    }

    public static void main(String[] args) {
        SpringApplication.run(EurekaProviderApplication.class, args);
    }
}
</code></pre>
<h3 id="配置-Eureka-Server-服务"><a href="#配置-Eureka-Server-服务" class="headerlink" title="配置 Eureka Server 服务"></a>配置 Eureka Server 服务</h3><p>需要配置才能找到Eureka服务器。例：</p>
<p>完整配置 <code>application.yml</code></p>
<pre><code class="sh">eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/

spring:
  application:
    name: eureka-provider

server:
  port: 8762
</code></pre>
<h3 id="启动提供者"><a href="#启动提供者" class="headerlink" title="启动提供者"></a>启动提供者</h3><p>启动该工程后，再次访问启动工程后：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a></p>
<p>可以如下图内容，我们定义的服务被成功注册了。</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/ribbon/2.png" alt=" eureka-provider"></p>
<h2 id="多个-Eureka-Provider"><a href="#多个-Eureka-Provider" class="headerlink" title="多个 Eureka Provider"></a>多个 Eureka Provider</h2><p>修改 <code>spring-cloud-eureka-provider</code> 配置文件<code>application.yml</code> 里的端口：<code>8762</code> 改成 <code>8763</code> maven 打包 后发布</p>
<p><strong>maven 打包</strong></p>
<pre><code class="sh">F:\spring-cloud-examples\spring-cloud-eureka-provider&gt; mvn clean package

....
Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO]
[INFO] --- maven-jar-plugin:2.6:jar (default-jar) @ spring-cloud-eureka-provider ---
[INFO] Building jar: F:\spring-cloud-examples\spring-cloud-eureka-provider\target\spring-cloud-eureka-provider-0.0.1-SNAPSHOT.jar
[INFO]
[INFO] --- spring-boot-maven-plugin:1.5.9.RELEASE:repackage (default) @ spring-cloud-eureka-provider ---
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 23.848 s
[INFO] Finished at: 2017-12-05T20:26:25+08:00
[INFO] Final Memory: 47M/421M
[INFO] ------------------------------------------------------------------------
F:\spring-cloud-examples\spring-cloud-eureka-provider&gt;
</code></pre>
<p><strong>把 maven打好的包，放入不同的目录，本地发布</strong></p>
<pre><code class="sh">java -jar spring-cloud-eureka-provider-0.0.1-SNAPSHOT.jar
</code></pre>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/ribbon/3.png" alt="发布 eureka-provider 8762 端口"></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/ribbon/4.png" alt="发布 eureka-provider 8763 端口"></p>
<h3 id="查看提供者服务"><a href="#查看提供者服务" class="headerlink" title="查看提供者服务"></a>查看提供者服务</h3><p>启动该工程后，再次访问启动工程后：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/ribbon/5.png" alt="查看提供者服务"></p>
<h2 id="Ribbon-Consumer"><a href="#Ribbon-Consumer" class="headerlink" title="Ribbon Consumer"></a>Ribbon Consumer</h2><p><strong>服务消费者</strong></p>
<h3 id="添加依赖-2"><a href="#添加依赖-2" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在项目 <code>spring-cloud-ribbon-consumer</code> <code>pom.xml</code>中引入需要的依赖内容：</p>
<pre><code class="xml">&lt;!-- 客户端负载均衡 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- eureka客户端 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="开启服务负载均衡"><a href="#开启服务负载均衡" class="headerlink" title="开启服务负载均衡"></a>开启服务负载均衡</h3><p>在工程的启动类中,通过@EnableDiscoveryClient向服务中心注册；并且向程序的ioc注入一个bean: restTemplate;并通过@LoadBalanced注解表明这个restRemplate开启负载均衡的功能。</p>
<pre><code class="java">package io.ymq.example.ribbon.consumer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@EnableDiscoveryClient
@SpringBootApplication
public class RibbonConsumerApplication {

    @LoadBalanced
    @Bean
    RestTemplate restTemplate() {
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(RibbonConsumerApplication.class, args);
    }
}
</code></pre>
<h3 id="消费提供者方法"><a href="#消费提供者方法" class="headerlink" title="消费提供者方法"></a>消费提供者方法</h3><p>写一个 <code>controller</code>，调用提供者的 <code>home</code> 方法</p>
<pre><code>package io.ymq.example.ribbon.consumer;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

/**
 * 描述:调用提供者的 `home` 方法
 *
 * @author yanpenglei
 * @create 2017-12-05 18:53
 **/
@RestController
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping(value = &quot;/hello&quot;)
    public String hello() {
        return restTemplate.getForEntity(&quot;http://eureka-provider/&quot;, String.class).getBody();
    }
}
</code></pre><h3 id="配置-Ribbon-服务"><a href="#配置-Ribbon-服务" class="headerlink" title="配置 Ribbon 服务"></a>配置 Ribbon 服务</h3><p>完整配置 <code>application.yml</code></p>
<pre><code class="sh">eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/

spring:
  application:
    name: ribbon-consumer

server:
  port: 9000
</code></pre>
<h3 id="启动消费者"><a href="#启动消费者" class="headerlink" title="启动消费者"></a>启动消费者</h3><p>启动该工程后，再次访问：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a> </p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/ribbon/6.png" alt="查看 Ribbon 注册状态"></p>
<h3 id="负载均衡响应"><a href="#负载均衡响应" class="headerlink" title="负载均衡响应"></a>负载均衡响应</h3><p><strong>浏览器 F5 刷新，发现已经实现负载均衡</strong></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/ribbon/7.png" alt="测试提供者，负载均衡响应"></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/ribbon/8.png" alt="测试提供者，负载均衡响应"></p>
<p><strong>注意：spring-cloud-eureka-provider</strong> 项目，改成不同端口发布两次</p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><ul>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-ribbon-consumer" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-ribbon-consumer</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cloud（二）Consul 服务治理实现]]></title>
      <url>/2017/12/23/2017-11-26-spring-cloud-consul/</url>
      <content type="html"><![CDATA[<p>Spring Cloud Consul 项目是针对Consul的服务治理实现。Consul是一个分布式高可用的系统，具有分布式、高可用、高扩展性。</p>
<h1 id="Consul-简介"><a href="#Consul-简介" class="headerlink" title="Consul 简介"></a>Consul 简介</h1><p>Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，Consul的方案更“一站式”<br>，内置了服务注册与发现框 架、<strong>具有以下性质：</strong></p>
<ul>
<li>分布一致性协议实现、</li>
<li>健康检查、</li>
<li>Key/Value存储、</li>
<li>多数据中心方案，</li>
</ul>
<p>不再需要依赖其他工具（比如ZooKeeper等）。</p>
<a id="more"></a>
<p>使用起来也较 为简单。Consul使用Go语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与Docker等轻量级容器可无缝配合 。<br>基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对.<br>一致性协议采用 Raft 算法,用来保证服务的高可用. 使用 GOSSIP 协议管理成员和广播消息, 并且支持 ACL 访问控制.</p>
<h2 id="Consul-的使用场景"><a href="#Consul-的使用场景" class="headerlink" title="Consul 的使用场景"></a>Consul 的使用场景</h2><ul>
<li>docker 实例的注册与配置共享</li>
<li>coreos 实例的注册与配置共享</li>
<li>vitess 集群</li>
<li>SaaS 应用的配置共享</li>
<li>与 confd 服务集成，动态生成 nginx 和 haproxy 配置文件</li>
</ul>
<h2 id="Consul-的优势"><a href="#Consul-的优势" class="headerlink" title="Consul 的优势"></a>Consul 的优势</h2><p>使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言, zookeeper 采用的是 Paxos, 而 etcd 使用的则是 Raft.<br>支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等. zookeeper 和 etcd 均不提供多数据中心功能的支持.<br>支持健康检查. etcd 不提供此功能.<br>支持 http 和 dns 协议接口. zookeeper 的集成较为复杂, etcd 只支持 http 协议.<br>官方提供web管理界面, etcd 无此功能.</p>
<h2 id="Consul-的角色"><a href="#Consul-的角色" class="headerlink" title="Consul 的角色"></a>Consul 的角色</h2><p>client: 客户端, 无状态, 将 HTTP 和 DNS 接口请求转发给局域网内的服务端集群.server: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其他数据中心通讯. 每个数据中心的 server 数量推荐为 3 个或是 5 个.</p>
<p>由于Spring Cloud Consul项目的实现，我们可以轻松的将基于Spring Boot的微服务应用注册到Consul上，并通过此实现微服务架构中的服务治理。</p>
<h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><p><strong>参考</strong></p>
<ul>
<li><a href="http://cloud.spring.io/spring-cloud-consul/" target="_blank" rel="noopener">Spring Cloud 官方文档</a> </li>
<li><a href="https://www.consul.io/intro/getting-started/install.html" target="_blank" rel="noopener">Consul 官方文档 </a></li>
</ul>
<p>要想利用Consul提供的服务实现服务的注册与发现，我们需要搭建Consul Cluster 环境。</p>
<p>在Consul方案中，每个提供服务的节点上都要部署和运行Consul的agent，所有运行Consul agent节点的集合构成Consul Cluster。</p>
<p>Consul agent有两种运行模式：Server和Client。这里的Server和Client只是Consul集群层面的区分，与搭建在Cluster之上 的应用服务无关。</p>
<p>以Server模式运行的Consul agent节点用于维护Consul集群的状态，官方建议每个Consul Cluster至少有3个或以上的运行在Server mode的Agent，Client节点不限。</p>
<p><strong>环境配置如下:</strong></p>
<p>Centos 7.3</p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>IP</th>
<th>作用</th>
<th>是否允许远程访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>node1</td>
<td>192.168.252.121</td>
<td>consul server</td>
<td>是</td>
</tr>
<tr>
<td>node2</td>
<td>192.168.252.122</td>
<td>consul client</td>
<td>否</td>
</tr>
<tr>
<td>node3</td>
<td>192.168.252.123</td>
<td>consul client</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>关闭防火墙</strong></p>
<pre><code class="sh">systemctl stop firewalld.service
</code></pre>
<p>Consul 最新版的下载地址:<br><a href="https://releases.hashicorp.com/consul/1.0.1/consul_1.0.1_linux_amd64.zip" target="_blank" rel="noopener">https://releases.hashicorp.com/consul/1.0.1/consul_1.0.1_linux_amd64.zip</a></p>
<p><strong>下载，然后unzip 解压，得到唯一，一个可执行文件</strong></p>
<pre><code class="sh">cd /opt/
wget https://releases.hashicorp.com/consul/1.0.1/consul_1.0.1_linux_amd64.zip
unzip consul_1.0.1_linux_amd64.zip
cp consul /usr/local/bin/
</code></pre>
<p><strong>查看是否安装成功</strong></p>
<pre><code class="sh">[root@node1 opt]# consul
</code></pre>
<p>出现如下结果，表示安装成功</p>
<pre><code class="sh">Usage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]

Available commands are:
    agent          Runs a Consul agent
    catalog        Interact with the catalog
    event          Fire a new event
    exec           Executes a command on Consul nodes
    force-leave    Forces a member of the cluster to enter the &quot;left&quot; state
    info           Provides debugging information for operators.
    join           Tell Consul agent to join cluster
    keygen         Generates a new encryption key
    keyring        Manages gossip layer encryption keys
    kv             Interact with the key-value store
    leave          Gracefully leaves the Consul cluster and shuts down
    lock           Execute a command holding a lock
    maint          Controls node or service maintenance mode
    members        Lists the members of a Consul cluster
    monitor        Stream logs from a Consul agent
    operator       Provides cluster-level tools for Consul operators
    reload         Triggers the agent to reload configuration files
    rtt            Estimates network round trip time between nodes
    snapshot       Saves, restores and inspects snapshots of Consul server state
    validate       Validate config files/directories
    version        Prints the Consul version
    watch          Watch for changes in Consul
</code></pre>
<p><strong>检查版本</strong></p>
<pre><code class="sh">[root@node1 opt]# consul version
</code></pre>
<pre><code class="sh">Consul v1.0.1
Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol &gt;2 when speaking to compatible agents)
</code></pre>
<h2 id="Consul常用命令"><a href="#Consul常用命令" class="headerlink" title="Consul常用命令"></a>Consul常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>agent</td>
<td>运行一个consul agent</td>
<td>consul agent -dev</td>
</tr>
<tr>
<td>join</td>
<td>将agent加入到consul集群</td>
<td>consul join IP</td>
</tr>
<tr>
<td>members</td>
<td>列出consul cluster集群中的members</td>
<td>consul members</td>
</tr>
<tr>
<td>leave</td>
<td>将节点移除所在集群</td>
<td>consul leave</td>
</tr>
</tbody>
</table>
<h2 id="consul-agent-命令的常用选项"><a href="#consul-agent-命令的常用选项" class="headerlink" title="consul agent 命令的常用选项"></a>consul agent 命令的常用选项</h2><p><strong>-data-dir</strong></p>
<ul>
<li>作用：指定agent储存状态的数据目录</li>
<li>这是所有agent都必须的</li>
<li>对于server尤其重要，因为他们必须持久化集群的状态</li>
</ul>
<p><strong>-config-dir</strong></p>
<ul>
<li>作用：指定service的配置文件和检查定义所在的位置</li>
<li>通常会指定为”某一个路径/consul.d”（通常情况下，.d表示一系列配置文件存放的目录）</li>
</ul>
<p><strong>-config-file</strong></p>
<ul>
<li>作用：指定一个要装载的配置文件</li>
<li>该选项可以配置多次，进而配置多个配置文件（后边的会合并前边的，相同的值覆盖）</li>
</ul>
<p><strong>-dev</strong></p>
<ul>
<li>作用：创建一个开发环境下的server节点</li>
<li>该参数配置下，不会有任何持久化操作，即不会有任何数据写入到磁盘</li>
<li>这种模式不能用于生产环境（因为第二条）</li>
</ul>
<p><strong>-bootstrap-expect</strong></p>
<ul>
<li>作用：该命令通知consul server我们现在准备加入的server节点个数，该参数是为了延迟日志复制的启动直到我们指定数量的server节点成功的加入后启动。</li>
</ul>
<p><strong>-node</strong></p>
<ul>
<li>作用：指定节点在集群中的名称</li>
<li>该名称在集群中必须是唯一的（默认采用机器的host）</li>
<li>推荐：直接采用机器的IP</li>
</ul>
<p><strong>-bind</strong></p>
<ul>
<li>作用：指明节点的IP地址</li>
<li>有时候不指定绑定IP，会报<code>Failed to get advertise address: Multiple private IPs found. Please configure one.</code> 的异常</li>
</ul>
<p><strong>-server</strong></p>
<ul>
<li>作用：指定节点为server</li>
<li>每个数据中心（DC）的server数推荐至少为1，至多为5</li>
<li>所有的server都采用raft一致性算法来确保事务的一致性和线性化，事务修改了集群的状态，且集群的状态保存在每一台server上保证可用性</li>
<li>server也是与其他DC交互的门面（gateway）</li>
</ul>
<p><strong>-client</strong></p>
<ul>
<li>作用：指定节点为client，指定客户端接口的绑定地址，包括：HTTP、DNS、RPC</li>
<li>默认是127.0.0.1，只允许回环接口访问</li>
<li>若不指定为-server，其实就是-client</li>
</ul>
<p><strong>-join</strong></p>
<ul>
<li>作用：将节点加入到集群</li>
</ul>
<p><strong>-datacenter</strong>（老版本叫-dc，-dc已经失效）</p>
<ul>
<li>作用：指定机器加入到哪一个数据中心中</li>
</ul>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>我们尝试一下：</p>
<p><code>-dev表示开发模式运行，使用-client 参数可指定允许客户端使用什么ip去访问，例如-client 192.168.252.121 表示可以使用</code></p>
<p><a href="http://192.168.252.121:8500/ui/" target="_blank" rel="noopener">http://192.168.252.121:8500/ui/ 去访问。</a></p>
<pre><code class="sh">consul agent -dev -client 192.168.252.121
</code></pre>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/consul/1.png" alt="Consul Cluster"></p>
<h2 id="Consul-的高可用"><a href="#Consul-的高可用" class="headerlink" title="Consul 的高可用"></a>Consul 的高可用</h2><p>Consul Cluster集群架构图如下： </p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/consul/2.png" alt="Consul Cluster集群架构"></p>
<p>这边准备了三台Centos 7.3的虚拟机，主机规划如下，供参考： </p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>IP</th>
<th>作用</th>
<th>是否允许远程访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>node1</td>
<td>192.168.252.121</td>
<td>consul server</td>
<td>是</td>
</tr>
<tr>
<td>node2</td>
<td>192.168.252.122</td>
<td>consul client</td>
<td>否</td>
</tr>
<tr>
<td>node3</td>
<td>192.168.252.123</td>
<td>consul client</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><p>命令参数，参看上面详细介绍</p>
<p><strong>在 node1 机器上启动 Consul</strong></p>
<pre><code class="sh">cd /opt/
mkdir data
consul agent -data-dir /opt/data -node=192.168.252.121 -bind=0.0.0.0 -datacenter=dc1 -ui -client=192.168.252.121 -server -bootstrap-expect 1 &gt; /dev/null 2&gt;&amp;1 &amp;
</code></pre>
<p><strong>在 node2 机器上启动 Consul,并且将node2节点加入到node1节点上</strong></p>
<pre><code class="sh">cd /opt/
mkdir data
consul agent -data-dir /opt/data -node=192.168.252.122 -bind=0.0.0.0 -datacenter=dc1 -ui -client=192.168.252.122 -join=192.168.252.121 &gt; /dev/null 2&gt;&amp;1 &amp;
</code></pre>
<p><strong>在 node3 机器上启动 Consul,并且将node3节点加入到node1节点上</strong></p>
<pre><code class="sh">cd /opt/
mkdir data
consul agent -data-dir /opt/data -node=192.168.252.123 -bind=0.0.0.0 -datacenter=dc1 -ui  -client=192.168.252.123 -join=192.168.252.121 &gt; /dev/null 2&gt;&amp;1 &amp;
</code></pre>
<p>在node1上查看当前集群节点：</p>
<pre><code class="sh">consul members -rpc-addr=192.168.252.123:8400  

consul leave -rpc-addr=192.168.252.123:8400
</code></pre>
<p><a href="http://192.168.252.121:8500/ui/" target="_blank" rel="noopener">http://192.168.252.121:8500/ui/ 去访问。</a></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/consul/3.png" alt="Consul Cluster集群 nodes"></p>
<h1 id="GitHub-代码"><a href="#GitHub-代码" class="headerlink" title="GitHub:代码"></a>GitHub:代码</h1><p>代码我已放到 Github ，导入<code>spring-cloud-consul-client</code> 项目 </p>
<p>github <a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-consul-client" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-consul-client</a></p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>在项目 <code>spring-cloud-consul</code> <code>pom.xml</code>中引入需要的依赖内容：</p>
<pre><code class="xml">&lt;!-- spring cloud starter consul discovery --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="开启服务注册"><a href="#开启服务注册" class="headerlink" title="开启服务注册"></a>开启服务注册</h2><p>客户端注册Consul时，它提供有关自身的元数据，如主机和端口，ID，名称和标签。默认情况下，将创建一个HTTP 检查，每隔10秒Consul命中/health端点。如果健康检查失败，则服务实例被标记为关键。</p>
<pre><code class="java">package io.ymq.example.consul;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@EnableDiscoveryClient
@RestController
public class ConsulApplication {

    @RequestMapping(&quot;/&quot;)
    public String home() {
        return &quot;Hello world&quot;;
    }

    public static void main(String[] args) {
        SpringApplication.run(ConsulApplication.class, args);
    }
}
</code></pre>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>在<code>application.yml</code>配置文件中增加如下信息：如果Consul客户端位于localhost:8500以外，则需要配置来定位客户端</p>
<pre><code class="sh">spring:
  application:
    name: consul-client
  cloud:
    consul:
      host: 192.168.252.121
      port: 8500
      discovery:
        healthCheckPath: /
        healthCheckInterval: 5s
</code></pre>
<p>如果Consul客户端位于localhost:8500以外的位置，则需要配置来定位客户端。例：</p>
<pre><code>host: 192.168.252.121
port: 8500
</code></pre><p><strong>HTTP健康检查路径</strong></p>
<p>“10s”和“1m”分别表示10秒和1分</p>
<pre><code>discovery:
    healthCheckPath: ${management.context-path}/health
    healthCheckInterval: 15s
</code></pre><h2 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h2><p><img src="http://www.ymq.io/images/2017/SpringCloud/consul/4.png" alt="Consul Cluster 集群 服务注册情况"></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/consul/5.png" alt="Consul Cluster集群 服务注册情况"></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>代码我已放到 Github ，导入<code>spring-cloud-consul-client</code> 项目 </p>
<p>github <a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-consul-client" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-consul-client</a></p>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cloud（一）服务的注册与发现（Eureka）]]></title>
      <url>/2017/12/23/2017-11-22-spring-cloud-eureka/</url>
      <content type="html"><![CDATA[<p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p>
<h1 id="Spring-Cloud简介"><a href="#Spring-Cloud简介" class="headerlink" title="Spring Cloud简介"></a>Spring Cloud简介</h1><p>Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud0 CloudFoundry、Spring Cloud AWS、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。</p>
<h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><p>微服务(Microservices Architecture)是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。</p>
<p>微服务的概念源于2014年3月Martin Fowler所写的章“Microservices”<a href="http://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">http://martinfowler.com/articles/microservices.html</a></p>
<a id="more"></a>
<h2 id="微服务架构（Microservices-Architecture）"><a href="#微服务架构（Microservices-Architecture）" class="headerlink" title="微服务架构（Microservices Architecture）"></a>微服务架构（Microservices Architecture）</h2><p>微服务架构的核心思想是，一个应用是由多个小的、相互独立的、微服务组成，这些服务运行在自己的进程中，开发和发布都没有依赖。不同服务通过一些轻量级交互机制来通信，例如 RPC、HTTP 等，服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。简单的来说，一个系统的不同模块转变成不同的服务！而且服务可以使用不同的技术加以实现！</p>
<h2 id="微服务设计"><a href="#微服务设计" class="headerlink" title="微服务设计"></a>微服务设计</h2><p>那我们在微服务中应该怎样设计呢。以下是微服务的设计指南：</p>
<ul>
<li><p>职责单一原则（Single Responsibility Principle）：把某一个微服务的功能聚焦在特定业务或者有限的范围内会有助于敏捷开发和服务的发布。</p>
</li>
<li><p>设计阶段就需要把业务范围进行界定。</p>
</li>
<li><p>需要关心微服务的业务范围，而不是服务的数量和规模尽量小。数量和规模需要依照业务功能而定。</p>
</li>
<li><p>于SOA不同，某个微服务的功能、操作和消息协议尽量简单。</p>
</li>
<li><p>项目初期把服务的范围制定相对宽泛，随着深入，进一步重构服务，细分微服务是个很好的做法。</p>
</li>
</ul>
<h2 id="关于微服务架构的取舍"><a href="#关于微服务架构的取舍" class="headerlink" title="关于微服务架构的取舍"></a>关于微服务架构的取舍</h2><ul>
<li><p>在合适的项目，合适的团队，采用微服务架构收益会大于成本。</p>
</li>
<li><p>微服务架构有很多吸引人的地方，但在拥抱微服务之前，也需要认清它所带来的挑战。</p>
</li>
<li><p>需要避免为了“微服务”而“微服务”。</p>
</li>
<li><p>微服务架构引入策略 – 对传统企业而言，开始时可以考虑引入部分合适的微服务架构原则对已有系统进行改造或新建微服务应用，逐步探索及积累微服务架构经验，而非全盘实施微服务架构。</p>
</li>
</ul>
<p><a href="http://www.ymq.io/2017/09/17/MicroServices/#微服务架构microservices-architecture" target="_blank" rel="noopener">更多关于微服务架构内容-请参考我的另一篇文章：《什什么是微服务架构？》 </a></p>
<h1 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h1><p>由于Spring Cloud为服务治理做了一层抽象接口，所以在Spring Cloud应用中可以支持多种不同的服务治理框架，比如：Netflix Eureka、Consul、Zookeeper。在Spring Cloud服务治理抽象层的作用下，我们可以无缝地切换服务治理实现，并且不影响任何其他的服务注册、服务发现、服务调用等逻辑。</p>
<h1 id="Spring-Cloud-Eureka"><a href="#Spring-Cloud-Eureka" class="headerlink" title="Spring Cloud Eureka"></a>Spring Cloud Eureka</h1><p>Spring Cloud Eureka来实现服务治理。</p>
<p>Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。</p>
<h2 id="Eureka-Server-eureka-server"><a href="#Eureka-Server-eureka-server" class="headerlink" title="Eureka Server  (eureka server)"></a>Eureka Server  (eureka server)</h2><p>提供服务注册和发现</p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在项目 <code>spring-cloud-eureka-service</code> <code>pom.xml</code>中引入需要的依赖内容：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="开启服务注册"><a href="#开启服务注册" class="headerlink" title="开启服务注册"></a>开启服务注册</h3><p>通过 <code>@EnableEurekaServer</code> 注解启动一个服务注册中心提供给其他应用进行对话,这个注解需要在springboot工程的启动application类上加</p>
<pre><code class="java">package io.ymq.example.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class EurekaApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
</code></pre>
<h3 id="配置-Eureka-服务"><a href="#配置-Eureka-服务" class="headerlink" title="配置 Eureka 服务"></a>配置 Eureka 服务</h3><p>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在<code>application.yml</code>配置文件中增加如下信息：</p>
<pre><code class="sh">registerWithEureka: false
fetchRegistry: false
</code></pre>
<p>完整配置</p>
<pre><code class="sh">server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
</code></pre>
<h3 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h3><p>启动工程后，访问：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a></p>
<p>可以看到下面的页面，其中还没有发现任何服务。</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/1.jpg" alt=" System Status "></p>
<h2 id="Service-Provider-eureka-client"><a href="#Service-Provider-eureka-client" class="headerlink" title="Service Provider (eureka client)"></a>Service Provider (eureka client)</h2><ul>
<li><p>服务提供方</p>
</li>
<li><p>将自身服务注册到 Eureka，从而使服务消费方能够找到</p>
</li>
</ul>
<h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在项目 <code>spring-cloud-eureka-client</code> <code>pom.xml</code>中引入需要的依赖内容：</p>
<pre><code class="xml">&lt;!-- spring boot eureka server --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="开启服务注册-1"><a href="#开启服务注册-1" class="headerlink" title="开启服务注册"></a>开启服务注册</h3><p>在应用主类中通过加上 @EnableEurekaClient，但只有Eureka可用，你也可以使用@EnableDiscoveryClient。需要配置才能找到Eureka服务器</p>
<pre><code class="java">package io.ymq.example.eureka.client;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@EnableEurekaClient
@RestController
public class EurekaClientApplication {

    @RequestMapping(&quot;/&quot;)
    public String home() {
        return &quot;Hello world&quot;;
    }

    public static void main(String[] args) {
        SpringApplication.run(EurekaClientApplication.class, args);
    }
}
</code></pre>
<h3 id="配置-Eureka-服务-1"><a href="#配置-Eureka-服务-1" class="headerlink" title="配置 Eureka 服务"></a>配置 Eureka 服务</h3><p>需要配置才能找到Eureka服务器。例：</p>
<p>完整配置</p>
<pre><code class="sh">eureka:
  instance:
    hostname: localhost
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/

spring:
  application:
    name: Eureka-Service
</code></pre>
<p>其中<code>defaultZone</code>是一个魔术字符串后备值，为任何不表示首选项的客户端提供服务URL（即它是有用的默认值）。<br>通过<code>spring.application.name</code>属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问</p>
<h3 id="使用-EurekaClient"><a href="#使用-EurekaClient" class="headerlink" title="使用 EurekaClient"></a>使用 EurekaClient</h3><p>启动该工程后，再次访问启动工程后：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a></p>
<p>可以如下图内容，我们定义的服务被成功注册了。</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/2.jpg" alt=" DS Replicas"></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><ul>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-client" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-client</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cloud（七）服务网关 Zuul Filter 使用]]></title>
      <url>/2017/12/23/2017-12-11-spring-cloud-zuul-filter/</url>
      <content type="html"><![CDATA[<p>上一篇文章中，讲了Zuul 转发，动态路由，负载均衡，等等一些Zuul 的特性，这个一篇文章，讲Zuul Filter 使用，关于网关的作用，这里就不再次赘述了，重点是zuul的Filter ，我们可以实现安全控制，比如，只有请求参数中有token和密码的客户端才能访问服务端的资源。那么如何来实现Filter了？</p>
<a id="more"></a>
<h1 id="Spring-Cloud-Zuul"><a href="#Spring-Cloud-Zuul" class="headerlink" title="Spring Cloud Zuul"></a>Spring Cloud Zuul</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始测试服务之前，我们先拿之前两篇博客，构建的两个微服务代码为基础，进行下面的操作，主要使用下面几个工程：</p>
<p><strong>建议先阅读以下文章</strong></p>
<p><a href="http://www.ymq.io/2017/12/10/spring-cloud-zuul/" target="_blank" rel="noopener">Spring Cloud（六）服务网关 zuul 快速入门-http://www.ymq.io/2017/12/10/spring-cloud-zuul/</a>  </p>
<ul>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider-2" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider-2</a></li>
</ul>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><strong>新建项目</strong> <code>spring-cloud-zuul-filter</code></p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="开启服务注册"><a href="#开启服务注册" class="headerlink" title="开启服务注册"></a>开启服务注册</h3><p>在程序的启动类 <code>ZuulFilterApplication</code> 通过 <code>@EnableZuulProxy</code> 开启 Zuul 服务网关</p>
<pre><code class="java">package io.ymq.example.zuul.filter;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.annotation.Bean;

@EnableZuulProxy
@SpringBootApplication
public class ZuulFilterApplication {

    public static void main(String[] args) {
        SpringApplication.run(ZuulFilterApplication.class, args);
    }
}
</code></pre>
<h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><p>配置文件 <code>application.yml</code></p>
<pre><code class="sh">spring:
  application:
    name: zuul-service-filter

server:
  port: 9000

zuul:
  routes:
    api:
        path: /**
        serviceId: eureka-provider

eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
</code></pre>
<h3 id="TokenFilter"><a href="#TokenFilter" class="headerlink" title="TokenFilter"></a>TokenFilter</h3><p><code>ZuulFilter</code> 是Zuul中核心组件，通过继承该抽象类，覆写几个关键方法达到自定义调度请求的作用</p>
<p><strong>TokenFilter 过滤器</strong></p>
<pre><code class="java">package io.ymq.example.zuul.filter;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.http.HttpServletRequest;

/**
 * 描述: 过滤器 token
 *
 * @author yanpenglei
 * @create 2017-12-11 14:38
 **/
public class TokenFilter extends ZuulFilter {

    private final Logger LOGGER = LoggerFactory.getLogger(TokenFilter.class);

    @Override
    public String filterType() {
        return &quot;pre&quot;; // 可以在请求被路由之前调用
    }

    @Override
    public int filterOrder() {
        return 0; // filter执行顺序，通过数字指定 ,优先级为0，数字越大，优先级越低
    }

    @Override
    public boolean shouldFilter() {
        return true;// 是否执行该过滤器，此处为true，说明需要过滤
    }

    @Override
    public Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();

        LOGGER.info(&quot;---&gt;&gt;&gt; TokenFilter {},{}&quot;, request.getMethod(), request.getRequestURL().toString());

        String token = request.getParameter(&quot;token&quot;);// 获取请求的参数

        if (StringUtils.isNotBlank(token)) {
            ctx.setSendZuulResponse(true); //对请求进行路由
            ctx.setResponseStatusCode(200);
            ctx.set(&quot;isSuccess&quot;, true);
            return null;
        } else {
            ctx.setSendZuulResponse(false); //不对其进行路由
            ctx.setResponseStatusCode(400);
            ctx.setResponseBody(&quot;token is empty&quot;);
            ctx.set(&quot;isSuccess&quot;, false);
            return null;
        }
    }

}
</code></pre>
<h3 id="PasswordFilter"><a href="#PasswordFilter" class="headerlink" title="PasswordFilter"></a>PasswordFilter</h3><p><code>ZuulFilter</code> 是Zuul中核心组件，通过继承该抽象类，覆写几个关键方法达到自定义调度请求的作用</p>
<p><strong>PasswordFilter 过滤器</strong></p>
<pre><code class="java">package io.ymq.example.zuul.filter;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.http.HttpServletRequest;

/**
 * 描述: 过滤器 Password
 *
 * @author yanpenglei
 * @create 2017-12-11 15:40
 **/
public class PasswordFilter extends ZuulFilter {

    private final Logger LOGGER = LoggerFactory.getLogger(TokenFilter.class);

    @Override
    public String filterType() {
        return &quot;post&quot;; // 请求处理完成后执行的filter
    }

    @Override
    public int filterOrder() {
        return 1; // 优先级为0，数字越大，优先级越低
    }

    @Override
    public boolean shouldFilter() {
        RequestContext ctx = RequestContext.getCurrentContext();
        return (boolean) ctx.get(&quot;isSuccess&quot;);
        // 判断上一个过滤器结果为true，否则就不走下面过滤器，直接跳过后面的所有过滤器并返回 上一个过滤器不通过的结果。
    }

    @Override
    public Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();

        LOGGER.info(&quot;---&gt;&gt;&gt; PasswordFilter {},{}&quot;, request.getMethod(), request.getRequestURL().toString());

        String username = request.getParameter(&quot;password&quot;);
        if (null != username &amp;&amp; username.equals(&quot;123456&quot;)) {
            ctx.setSendZuulResponse(true);
            ctx.setResponseStatusCode(200);
            ctx.set(&quot;isSuccess&quot;, true);
            return null;
        } else {
            ctx.setSendZuulResponse(false);
            ctx.setResponseStatusCode(400);
            ctx.setResponseBody(&quot;The password cannot be empty&quot;);
            ctx.set(&quot;isSuccess&quot;, false);
            return null;
        }
    }
}
</code></pre>
<h3 id="开启过滤器"><a href="#开启过滤器" class="headerlink" title="开启过滤器"></a>开启过滤器</h3><p>在程序的启动类 <code>ZuulFilterApplication</code> 添加 Bean</p>
<pre><code class="java">@Bean
public TokenFilter tokenFilter() {
    return new TokenFilter();
}

@Bean
public PasswordFilter PasswordFilter() {
    return new PasswordFilter();
}
</code></pre>
<h3 id="filterType"><a href="#filterType" class="headerlink" title="filterType"></a>filterType</h3><p><strong>filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下:</strong> </p>
<ul>
<li>pre：路由之前</li>
<li>routing：路由之时</li>
<li>post： 路由之后</li>
<li>error：发送错误调用</li>
<li>filterOrder：过滤的顺序</li>
<li>shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。</li>
<li>run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。</li>
</ul>
<h3 id="测试服务"><a href="#测试服务" class="headerlink" title="测试服务"></a>测试服务</h3><p>依次启动四个服务：<code>spring-cloud-eureka-service</code>,<code>spring-cloud-eureka-provider</code>,<code>spring-cloud-eureka-provider-2</code>,<code>spring-cloud-zuul-service</code></p>
<p><strong>查看 eureka 监控，看服务是否都注册成功</strong></p>
<p>访问:<a href="http://127.0.0.1:8761/" target="_blank" rel="noopener">http://127.0.0.1:8761/</a></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/zuulFilter/1.png" alt="浏览器访问"></p>
<p><strong>步骤一</strong> 提示 <code>token is empty</code> </p>
<p>访问:<a href="http://127.0.0.1:9000/" target="_blank" rel="noopener">http://127.0.0.1:9000/</a></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/zuulFilter/2.png" alt="token is empty"></p>
<p><strong>步骤二</strong> 加上token <code>?token=token-uuid</code> ，已经验证通过了，提示 <code>The password cannot be empty</code> </p>
<p>访问:<a href="http://127.0.0.1:9000/?token=token-uuid" target="_blank" rel="noopener">http://127.0.0.1:9000/?token=token-uuid</a></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/zuulFilter/3.png" alt="The password cannot be empty"></p>
<p><strong>步骤三</strong> 加上token 和 password <code>&amp;password=123456</code> ，已经验证通过</p>
<p>访问:<a href="http://127.0.0.1:9000/?token=token-uuid&amp;password=123456" target="_blank" rel="noopener">http://127.0.0.1:9000/?token=token-uuid&amp;password=123456</a></p>
<p>F5 刷新，每次都验证通过，并且负载均衡</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/zuulFilter/4.png" alt="Hello Zuul ,port:8763"></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/zuulFilter/5.png" alt="THello world ,port:8762"></p>
<h3 id="zuul-执行流程"><a href="#zuul-执行流程" class="headerlink" title="zuul 执行流程"></a>zuul 执行流程</h3><p><img src="http://www.ymq.io/images/2017/SpringCloud/zuulFilter/6.png" alt="执行流程图"></p>
<p><strong>Zuul</strong>大部分功能都是通过过滤器来实现的。Zuul中定义了四种标准过滤器类型，这些过滤器类型对应于请求的典型生命周期。</p>
<p><strong>PRE：</strong>这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。</p>
<p><strong>ROUTING：</strong>这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用Apache HttpClient或Netfilx Ribbon请求微服务。</p>
<p><strong>OST：</strong>这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。</p>
<p><strong>ERROR：</strong>在其他阶段发生错误时执行该过滤器。</p>
<p>除了默认的过滤器类型，Zuul还允许我们创建自定义的过滤器类型。例如，我们可以定制一种STATIC类型的过滤器，直接在Zuul中生成响应，而不将请求转发到后端的微服务。</p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><ul>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider-2" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-provider-2</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-zuul-filter" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-zuul-filter</a></li>
</ul>
<p>出处：<a href="http://www.ymq.io" target="_blank" rel="noopener">http://www.ymq.io</a><br>转自：鹏磊</p>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cloud（八）高可用的分布式配置中心 Spring Cloud Config]]></title>
      <url>/2017/12/23/2017-12-13-spring-cloud-config/</url>
      <content type="html"><![CDATA[<p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client，业界也有些知名的同类开源产品，比如百度的disconf。</p>
<p>相比较同类产品，SpringCloudConfig最大的优势是和Spring无缝集成，支持Spring里面Environment和PropertySource的接口，对于已有的Spring应用程序的迁移成本非常低，在配置获取的接口上是完全一致，结合SpringBoot可使你的项目有更加统一的标准（包括依赖版本和约束规范），避免了应为集成不同开软件源造成的依赖版本冲突。</p>
<a id="more"></a>
<h1 id="Spring-Cloud-Config-简介"><a href="#Spring-Cloud-Config-简介" class="headerlink" title="Spring Cloud Config 简介"></a>Spring Cloud Config 简介</h1><p>SpringCloudConfig就是我们通常意义上的配置中心，把应用原本放在本地文件的配置抽取出来放在中心服务器，从而能够提供更好的管理、发布能力。SpringCloudConfig分服务端和客户端，服务端负责将git（svn）中存储的配置文件发布成REST接口，客户端可以从服务端REST接口获取配置。但客户端并不能主动感知到配置的变化，从而主动去获取新的配置，这需要每个客户端通过POST方法触发各自的/refresh。</p>
<p>SpringCloudBus通过一个轻量级消息代理连接分布式系统的节点。这可以用于广播状态更改（如配置更改）或其他管理指令。SpringCloudBus提供了通过POST方法访问的endpoint/bus/refresh，这个接口通常由git的钩子功能调用，用以通知各个SpringCloudConfig的客户端去服务端更新配置。</p>
<p>注意：这是工作的流程图，实际的部署中SpringCloudBus并不是一个独立存在的服务，这里单列出来是为了能清晰的显示出工作流程。</p>
<p>下图是SpringCloudConfig结合SpringCloudBus实现分布式配置的工作流</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/config/1.png" alt="SpringCloudConfig结合SpringCloudBus实现分布式配置的工作流"></p>
<h1 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h1><h2 id="config-Server"><a href="#config-Server" class="headerlink" title="config Server"></a>config Server</h2><p><strong>新建项目</strong> <code>spring-cloud-config-server</code></p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="开启服务注册"><a href="#开启服务注册" class="headerlink" title="开启服务注册"></a>开启服务注册</h2><p>在程序的启动类 <code>ConfigApplication</code> 通过 <code>@EnableConfigServer</code> 开启 SpringCloudConfig 服务端</p>
<pre><code class="java">package io.ymq.example.config.server;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@EnableConfigServer
@SpringBootApplication
public class ConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConfigApplication.class, args);
    }
}
</code></pre>
<h2 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h2><p>配置文件 <code>application.properties</code></p>
<pre><code class="sh">spring.application.name=config-server
server.port=8888
spring.cloud.config.label=master
spring.cloud.config.server.git.uri=https://github.com/souyunku/spring-cloud-config.git
spring.cloud.config.server.git.search-paths=spring-cloud-config

#spring.cloud.config.server.git.username=your username
#spring.cloud.config.server.git.password=your password
</code></pre>
<ul>
<li>spring.cloud.config.server.git.uri：配置git仓库地址</li>
<li>spring.cloud.config.server.git.searchPaths：配置仓库路径</li>
<li>spring.cloud.config.label：配置仓库的分支</li>
<li>spring.cloud.config.server.git.username：访问git仓库的用户名</li>
<li>spring.cloud.config.server.git.password：访问git仓库的用户密码</li>
</ul>
<p>Git仓库如果是私有仓库需要填写用户名密码，示例是公开仓库，所以不配置密码。</p>
<p><strong>远程Git仓库</strong></p>
<p><code>spring-cloud-config</code> 文件夹下有 <code>application-dev.properties</code>,<code>application-test.properties</code> 三个文件，内容依次是：<code>content=hello dev</code>,<code>content=hello test</code>,<code>content=hello pre</code></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/config/2.png" alt="远程Git仓库"></p>
<h2 id="测试服务"><a href="#测试服务" class="headerlink" title="测试服务"></a>测试服务</h2><p>启动程序 <code>ConfigApplication</code> 类</p>
<p>访问 Spring Cloud Config 服务：<a href="http://localhost:8888/springCloudConfig/dev/master" target="_blank" rel="noopener">http://localhost:8888/springCloudConfig/dev/master</a></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/config/3.png" alt="远程Git仓库 springCloudConfig 配置"></p>
<p>证明配置服务中心可以从远程程序获取配置信息。</p>
<p>http请求地址和资源文件映射如下:</p>
<ul>
<li><code>/{application}/{profile}[/{label}]</code></li>
<li><code>/{application}-{profile}.yml</code></li>
<li><code>/{label}/{application}-{profile}.yml</code></li>
<li><code>/{application}-{profile}.properties</code></li>
<li><code>/{label}/{application}-{profile}.properties</code></li>
</ul>
<h1 id="客户端端配置"><a href="#客户端端配置" class="headerlink" title="客户端端配置"></a>客户端端配置</h1><h2 id="config-Client"><a href="#config-Client" class="headerlink" title="config Client"></a>config Client</h2><p><strong>新建项目</strong> <code>spring-cloud-config-client</code></p>
<h2 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="开启服务注册-1"><a href="#开启服务注册-1" class="headerlink" title="开启服务注册"></a>开启服务注册</h2><p>在程序的启动类 <code>ConfigClientApplication</code> 通过 <code>@Value</code> 获取服务端的    <code>content</code> 值的内容</p>
<pre><code class="java">package io.ymq.example.config.client;

@RestController
@SpringBootApplication
public class ConfigClientApplication {

    @Value(&quot;${content}&quot;)
    String content;

    @RequestMapping(&quot;/&quot;)
    public String home() {
        return &quot;content:&quot; + content;
    }

    public static void main(String[] args) {
        SpringApplication.run(ConfigClientApplication.class, args);
    }
}
</code></pre>
<h2 id="添加配置-1"><a href="#添加配置-1" class="headerlink" title="添加配置"></a>添加配置</h2><p>配置文件 <code>application.properties</code></p>
<pre><code class="sh">spring.application.name=config-client
server.port=8088

spring.cloud.config.label=master
spring.cloud.config.profile=dev
spring.cloud.config.uri=http://localhost:8888/
</code></pre>
<ul>
<li>spring.cloud.config.label 指明远程仓库的分支</li>
<li>spring.cloud.config.profile</li>
<li>dev开发环境配置文件</li>
<li>test测试环境</li>
<li>pro正式环境</li>
<li>spring.cloud.config.uri= <a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a> 指明配置服务中心的网址。</li>
</ul>
<h2 id="测试服务-1"><a href="#测试服务-1" class="headerlink" title="测试服务"></a>测试服务</h2><p>启动程序 <code>ConfigClientApplication</code> 类</p>
<p>访问服务：<a href="http://localhost:8088/" target="_blank" rel="noopener">http://localhost:8088/</a></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/config/4.png" alt="访问服务"></p>
<p><strong>下一篇，继续Spring Cloud Config 整合 eureka, 等更多特性</strong>    </p>
<h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><ul>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-config-server" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-config-server</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-config-client" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-config-client</a></li>
</ul>
<p>出处：<a href="http://www.ymq.io" target="_blank" rel="noopener">http://www.ymq.io</a><br>转自：鹏磊</p>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cloud（九）高可用的分布式配置中心 Spring Cloud Config 集成 Eureka 服务]]></title>
      <url>/2017/12/23/2017-12-14-spring-cloud-config-eureka/</url>
      <content type="html"><![CDATA[<p>上一篇文章，讲了SpringCloudConfig 集成Git仓库，这一篇我们讲一下 SpringCloudConfig 配和 Eureka 注册中心一起使用</p>
<p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client，业界也有些知名的同类开源产品，比如百度的disconf。</p>
<p>相比较同类产品，SpringCloudConfig最大的优势是和Spring无缝集成，支持Spring里面Environment和PropertySource的接口，对于已有的Spring应用程序的迁移成本非常低，在配置获取的接口上是完全一致，结合SpringBoot可使你的项目有更加统一的标准（包括依赖版本和约束规范），避免了应为集成不同开软件源造成的依赖版本冲突。</p>
<a id="more"></a>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="Eureka-Service"><a href="#Eureka-Service" class="headerlink" title="Eureka Service"></a>Eureka Service</h2><p>Eureka 注册中心，就使用第三篇文章的源码</p>
<p><strong>项目：spring-cloud-eureka-service</strong> 下载地址在文章末尾</p>
<p><a href="http://www.ymq.io/2017/12/05/spring-cloud-ribbon-rest/#eureka-server" target="_blank" rel="noopener">Spring Cloud（八）高可用的分布式配置中心 Spring Cloud Config</a></p>
<p><a href="http://www.ymq.io/2017/12/05/spring-cloud-ribbon-rest/#eureka-server" target="_blank" rel="noopener">http://www.ymq.io/2017/12/05/spring-cloud-ribbon-rest/#eureka-server</a></p>
<h1 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h1><h2 id="config-Server-Eureka"><a href="#config-Server-Eureka" class="headerlink" title="config Server Eureka"></a>config Server Eureka</h2><p><strong>复制上一篇的项目</strong> <code>spring-cloud-config-server</code> 修改项目名称为：<code>spring-cloud-config-server-eureka-provider</code></p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="开启服务注册"><a href="#开启服务注册" class="headerlink" title="开启服务注册"></a>开启服务注册</h2><p>在程序的启动类 <code>ConfigApplication</code> 通过 <code>@EnableConfigServer</code> 开启 SpringCloudConfig 服务端，通过 <code>@EnableEurekaClient</code> 开启 Eureka 提供者服务</p>
<pre><code class="java">package io.ymq.example.config.server;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@EnableConfigServer
@EnableEurekaClient
@SpringBootApplication
public class ConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConfigApplication.class, args);
    }
}
</code></pre>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>修改配置文件 <code>application.properties</code> ，添加 eureka 注册中心地址 <code>http://localhost:8761/eureka/</code></p>
<pre><code class="sh">spring.application.name=config-server
server.port=8888
spring.cloud.config.label=master
spring.cloud.config.server.git.uri=https://github.com/souyunku/spring-cloud-config.git
spring.cloud.config.server.git.search-paths=spring-cloud-config

#spring.cloud.config.server.git.username=your username
#spring.cloud.config.server.git.password=your password

eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
</code></pre>
<ul>
<li>spring.cloud.config.server.git.uri：配置git仓库地址</li>
<li>spring.cloud.config.server.git.searchPaths：配置仓库路径</li>
<li>spring.cloud.config.label：配置仓库的分支</li>
<li>spring.cloud.config.server.git.username：访问git仓库的用户名</li>
<li><p>spring.cloud.config.server.git.password：访问git仓库的用户密码</p>
</li>
<li><p>eureka.client.serviceUrl.defaultZone：eureka注册中心地址</p>
</li>
</ul>
<p>Git仓库如果是私有仓库需要填写用户名密码，示例是公开仓库，所以不配置密码。</p>
<p><strong>远程Git仓库</strong></p>
<p><code>spring-cloud-config</code> 文件夹下有 <code>application-dev.properties</code>,<code>application-test.properties</code> 三个文件，内容依次是：<code>content=hello dev</code>,<code>content=hello test</code>,<code>content=hello pre</code></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/config/2.png" alt="远程Git仓库"></p>
<h2 id="测试服务"><a href="#测试服务" class="headerlink" title="测试服务"></a>测试服务</h2><p>启动程序 <code>ConfigApplication</code> 类</p>
<p>访问 Spring Cloud Config 服务：<a href="http://localhost:8888/springCloudConfig/dev/master" target="_blank" rel="noopener">http://localhost:8888/springCloudConfig/dev/master</a></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/config/3.png" alt="远程Git仓库 springCloudConfig 配置"></p>
<p>证明配置服务中心可以从远程程序获取配置信息。</p>
<p>http请求地址和资源文件映射如下:</p>
<ul>
<li><code>/{application}/{profile}[/{label}]</code></li>
<li><code>/{application}-{profile}.yml</code></li>
<li><code>/{label}/{application}-{profile}.yml</code></li>
<li><code>/{application}-{profile}.properties</code></li>
<li><code>/{label}/{application}-{profile}.properties</code></li>
</ul>
<h1 id="客户端端配置"><a href="#客户端端配置" class="headerlink" title="客户端端配置"></a>客户端端配置</h1><h2 id="config-Client-Eureka"><a href="#config-Client-Eureka" class="headerlink" title="config Client Eureka"></a>config Client Eureka</h2><p><strong>复制上一篇的项目</strong> <code>spring-cloud-config-client</code>  修改项目名称为：<code>spring-cloud-config-client-consumer</code></p>
<h2 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="开启服务注册-1"><a href="#开启服务注册-1" class="headerlink" title="开启服务注册"></a>开启服务注册</h2><p>在程序的启动类 <code>ConfigClientApplication</code> 通过 <code>@EnableConfigServer</code> 开启 SpringCloudConfig 服务端，通过 <code>@EnableEurekaClient</code> 开启 Eureka 提供者服务</p>
<pre><code class="java">package io.ymq.example.config.client;

@RestController
@EnableEurekaClient
@SpringBootApplication
public class ConfigClientApplication {

    @Value(&quot;${content}&quot;)
    String content;

    @RequestMapping(&quot;/&quot;)
    public String home() {
        return &quot;content:&quot; + content;
    }

    public static void main(String[] args) {
        SpringApplication.run(ConfigClientApplication.class, args);
    }
}
</code></pre>
<h2 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h2><p>修改配置文件 <code>application.properties</code> 添加 Eureka 注册中心，配置从springCloudConfig 配置中心读取配置，指定springCloudConfigService 服务名称</p>
<pre><code class="sh">spring.application.name=config-client
server.port=8088

spring.cloud.config.label=master
spring.cloud.config.profile=dev
#spring.cloud.config.uri=http://localhost:8888/

eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
spring.cloud.config.discovery.enabled=true
spring.cloud.config.discovery.serviceId=config-server
</code></pre>
<ul>
<li>spring.cloud.config.label 指明远程仓库的分支</li>
<li>spring.cloud.config.profile</li>
<li>dev开发环境配置文件</li>
<li>test测试环境</li>
<li>pro正式环境</li>
<li><p>#spring.cloud.config.uri= <a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a> 指明配置服务中心的网址<strong>（注释掉）</strong></p>
</li>
<li><p>spring.cloud.config.discovery.enabled=true 是从配置中心读取文件。</p>
</li>
<li>spring.cloud.config.discovery.serviceId=config-server  配置中心的servieId，服务名称，通过服务名称去 Eureka注册中心找服务</li>
</ul>
<h2 id="测试服务-1"><a href="#测试服务-1" class="headerlink" title="测试服务"></a>测试服务</h2><p>启动 <code>spring-cloud-eureka-service</code> ,<code>spring-cloud-config-server-eureka-provider</code> ,<code>spring-cloud-config-client-consumer</code>  三个项目</p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/config/5.png" alt="查看服务注册情况"></p>
<p>访问服务:<a href="http://localhost:8088/" target="_blank" rel="noopener">http://localhost:8088/</a></p>
<p><img src="http://www.ymq.io/images/2017/SpringCloud/config/4.png" alt="访问服务"></p>
<h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><ul>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-eureka-service</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-config-server-eureka-provider" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-config-server-eureka-provider</a></li>
<li><a href="https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-config-client-consumer" target="_blank" rel="noopener">https://github.com/souyunku/spring-cloud-examples/tree/master/spring-cloud-config-client-consumer</a></li>
</ul>
<p>出处：<a href="http://www.ymq.io" target="_blank" rel="noopener">http://www.ymq.io</a><br>转自：鹏磊</p>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[基于 Spring Cloud 完整的微服务架构实战]]></title>
      <url>/2017/12/23/2017-12-17-spring-cloud-actual-combat/</url>
      <content type="html"><![CDATA[<h1 id="基于-Spring-Cloud-完整的微服务架构实战"><a href="#基于-Spring-Cloud-完整的微服务架构实战" class="headerlink" title="基于 Spring Cloud 完整的微服务架构实战"></a>基于 Spring Cloud 完整的微服务架构实战</h1><p>本项目是一个基于 Spring Boot、Spring Cloud、Spring Oauth2 和 Spring Cloud Netflix 等框架构建的微服务项目。</p>
<p>@作者：Sheldon<br>地址：<a href="https://github.com/zhangxd1989" target="_blank" rel="noopener">https://github.com/zhangxd1989</a></p>
<h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><ul>
<li>Spring boot - 微服务的入门级微框架，用来简化 Spring 应用的初始搭建以及开发过程。</li>
<li>Eureka - 云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。</li>
<li>Spring Cloud Config - 配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git 以及 Subversion。</li>
<li>Hystrix - 熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</li>
<li>Zuul - Zuul 是在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。</li>
<li>Spring Cloud Bus - 事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 联合实现热部署。</li>
<li>Spring Cloud Sleuth - 日志收集工具包，封装了 Dapper 和 log-based 追踪以及 Zipkin 和 HTrace 操作，为 SpringCloud 应用实现了一种分布式追踪解决方案。</li>
<li>Ribbon - 提供云端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。</li>
<li>Turbine - Turbine 是聚合服务器发送事件流数据的一个工具，用来监控集群下 hystrix 的 metrics 情况。</li>
<li>Spring Cloud Stream - Spring 数据流操作开发包，封装了与 Redis、Rabbit、Kafka 等发送接收消息。</li>
<li>Feign - Feign 是一种声明式、模板化的 HTTP 客户端。</li>
<li>Spring Cloud OAuth2 - 基于 Spring Security 和 OAuth2 的安全工具包，为你的应用程序添加安全控制。</li>
</ul>
<a id="more"></a>
<h1 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a>应用架构</h1><p>该项目包含 8 个服务</p>
<ul>
<li>registry - 服务注册与发现</li>
<li>config - 外部配置</li>
<li>monitor - 监控</li>
<li>zipkin - 分布式跟踪</li>
<li>gateway - 代理所有微服务的接口网关</li>
<li>auth-service - OAuth2 认证服务</li>
<li>svca-service - 业务服务A</li>
<li>svcb-service - 业务服务B</li>
</ul>
<h2 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h2><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/architecture.jpg" alt="architecture"></p>
<h2 id="应用组件"><a href="#应用组件" class="headerlink" title="应用组件"></a>应用组件</h2><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/components.jpg" alt="components"></p>
<h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><ul>
<li>使用 Docker 快速启动<ol>
<li>配置 Docker 环境</li>
<li><code>mvn clean package</code> 打包项目及 Docker 镜像</li>
<li>在项目根目录下执行 <code>docker-compose up -d</code> 启动所有项目</li>
</ol>
</li>
<li>本地手动启动<ol>
<li>配置 rabbitmq</li>
<li>修改 hosts 将主机名指向到本地<br><code>127.0.0.1    registry config monitor rabbitmq auth-service</code><br>或者修改各服务配置文件中的相应主机名为本地 ip</li>
<li>启动 registry、config、monitor、zipkin</li>
<li>启动 gateway、auth-service、svca-service、svcb-service</li>
</ol>
</li>
</ul>
<h1 id="项目预览"><a href="#项目预览" class="headerlink" title="项目预览"></a>项目预览</h1><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>访问 <a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a> 默认账号 user，密码 password</p>
<p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/registry.jpg" alt="registry"></p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>访问 <a href="http://localhost:8040/" target="_blank" rel="noopener">http://localhost:8040/</a> 默认账号 admin，密码 admin</p>
<h3 id="控制面板"><a href="#控制面板" class="headerlink" title="控制面板"></a>控制面板</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/monitor1.jpg" alt="monitor"></p>
<h3 id="应用注册历史"><a href="#应用注册历史" class="headerlink" title="应用注册历史"></a>应用注册历史</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/monitor2.jpg" alt="monitor"></p>
<h3 id="Turbine-Hystrix面板"><a href="#Turbine-Hystrix面板" class="headerlink" title="Turbine Hystrix面板"></a>Turbine Hystrix面板</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/monitor3.jpg" alt="monitor"></p>
<h3 id="应用信息、健康状况、垃圾回收等详情"><a href="#应用信息、健康状况、垃圾回收等详情" class="headerlink" title="应用信息、健康状况、垃圾回收等详情"></a>应用信息、健康状况、垃圾回收等详情</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/monitor4.jpg" alt="monitor"></p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/monitor5.jpg" alt="monitor"></p>
<h3 id="查看和修改环境变量"><a href="#查看和修改环境变量" class="headerlink" title="查看和修改环境变量"></a>查看和修改环境变量</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/monitor6.jpg" alt="monitor"></p>
<h3 id="管理-Logback-日志级别"><a href="#管理-Logback-日志级别" class="headerlink" title="管理 Logback 日志级别"></a>管理 Logback 日志级别</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/monitor7.jpg" alt="monitor"></p>
<h3 id="查看并使用-JMX"><a href="#查看并使用-JMX" class="headerlink" title="查看并使用 JMX"></a>查看并使用 JMX</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/monitor8.jpg" alt="monitor"></p>
<h3 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/monitor9.jpg" alt="monitor"></p>
<h3 id="认证历史"><a href="#认证历史" class="headerlink" title="认证历史"></a>认证历史</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/monitor10.jpg" alt="monitor"></p>
<h3 id="查看-Http-请求轨迹"><a href="#查看-Http-请求轨迹" class="headerlink" title="查看 Http 请求轨迹"></a>查看 Http 请求轨迹</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/monitor11.jpg" alt="monitor"></p>
<h3 id="Hystrix-面板"><a href="#Hystrix-面板" class="headerlink" title="Hystrix 面板"></a>Hystrix 面板</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/monitor12.jpg" alt="monitor"></p>
<h2 id="链路跟踪"><a href="#链路跟踪" class="headerlink" title="链路跟踪"></a>链路跟踪</h2><p>访问 <a href="http://localhost:9411/" target="_blank" rel="noopener">http://localhost:9411/</a> 默认账号 admin，密码 admin</p>
<h3 id="控制面板-1"><a href="#控制面板-1" class="headerlink" title="控制面板"></a>控制面板</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/zipkin1.jpg" alt="zipkin"></p>
<h3 id="链路跟踪明细"><a href="#链路跟踪明细" class="headerlink" title="链路跟踪明细"></a>链路跟踪明细</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/zipkin2.jpg" alt="zipkin"></p>
<h3 id="服务依赖关系"><a href="#服务依赖关系" class="headerlink" title="服务依赖关系"></a>服务依赖关系</h3><p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/zipkin3.jpg" alt="zipkin"></p>
<h2 id="RabbitMQ-监控"><a href="#RabbitMQ-监控" class="headerlink" title="RabbitMQ 监控"></a>RabbitMQ 监控</h2><p>Docker 启动访问 <a href="http://localhost:15673/" target="_blank" rel="noopener">http://localhost:15673/</a> 默认账号 guest，密码 guest（本地 rabbit 管理系统默认端口15672）</p>
<p><img src="https://raw.githubusercontent.com/souyunku/spring-boot-cloud/master/screenshots/rabbit.jpg" alt="rabbit"></p>
<h1 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h1><ol>
<li>获取 Token<pre><code>curl -X POST -vu client:secret http://localhost:8060/uaa/oauth/token -H &quot;Accept: application/json&quot; -d &quot;password=password&amp;username=anil&amp;grant_type=password&amp;scope=read%20write&quot;
</code></pre>返回如下格式数据：<pre><code>{
&quot;access_token&quot;: &quot;eac56504-c4f0-4706-b72e-3dc3acdf45e9&quot;,
&quot;token_type&quot;: &quot;bearer&quot;,
&quot;refresh_token&quot;: &quot;da1007dc-683c-4309-965d-370b15aa4aeb&quot;,
&quot;expires_in&quot;: 3599,
&quot;scope&quot;: &quot;read write&quot;
}
</code></pre></li>
<li>使用 access token 访问 service a 接口<pre><code>curl -i -H &quot;Authorization: Bearer eac56504-c4f0-4706-b72e-3dc3acdf45e9&quot; http://localhost:8060/svca
</code></pre>返回如下数据：<pre><code>svca-service (172.18.0.8:8080)===&gt;name:zhangxd
svcb-service (172.18.0.2:8070)===&gt;Say Hello
</code></pre></li>
<li>使用 access token 访问 service b 接口<pre><code>curl -i -H &quot;Authorization: Bearer eac56504-c4f0-4706-b72e-3dc3acdf45e9&quot; http://localhost:8060/svcb
</code></pre>返回如下数据：<pre><code>svcb-service (172.18.0.2:8070)===&gt;Say Hello
</code></pre></li>
<li>使用 refresh token 刷新 token<pre><code>curl -X POST -vu client:secret http://localhost:8060/uaa/oauth/token -H &quot;Accept: application/json&quot; -d &quot;grant_type=refresh_token&amp;refresh_token=da1007dc-683c-4309-965d-370b15aa4aeb&quot;
</code></pre>返回更新后的 Token：<pre><code>{
&quot;access_token&quot;: &quot;63ff57ce-f140-482e-ba7e-b6f29df35c88&quot;,
&quot;token_type&quot;: &quot;bearer&quot;,
&quot;refresh_token&quot;: &quot;da1007dc-683c-4309-965d-370b15aa4aeb&quot;,
&quot;expires_in&quot;: 3599,
&quot;scope&quot;: &quot;read write&quot;
}
</code></pre></li>
<li>刷新配置<pre><code>curl -X POST -vu user:password http://localhost:8888/bus/refresh
</code></pre><strong>源码下载</strong></li>
</ol>
<p><a href="https://github.com/souyunku/spring-boot-cloud.git" target="_blank" rel="noopener">https://github.com/souyunku/spring-boot-cloud.git</a></p>
<p>出处：<a href="http://www.ymq.io" target="_blank" rel="noopener">http://www.ymq.io</a><br>转自：鹏磊</p>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux基础命令]]></title>
      <url>/2017/12/23/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>玩过Linux的人都会知道，Linux中的命令的确是非常多，但是玩过Linux的人也从来不会因为Linux的命令如此之多而烦恼，因为我们只需要掌握我们最常用的命令就可以了。</p>
<p>然而每个人玩Linux的目的都不同，所以他们常用的命令也就差异非常大，所以常用到的命令可以就会跟一个管理Linux系统的人有所不同。因为不想在使用是总是东查西找，所以在此总结一下，方便一下以后的查看。</p>
<a id="more"></a>
<p>不多说，下面就说说我最常用的Linux命令。</p>
<h1 id="1、cd命令"><a href="#1、cd命令" class="headerlink" title="1、cd命令"></a>1、cd命令</h1><p>这是一个非常基本，也是大家经常需要使用的命令，它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。如：</p>
<p>cd /root/Docements # 切换到目录/root/Docements<br>cd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录<br>cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</p>
<h1 id="2、ls命令"><a href="#2、ls命令" class="headerlink" title="2、ls命令"></a>2、ls命令</h1><p>这是一个非常有用的查看文件与目录的命令，list之意，它的参数非常多，下面就列出一些我常用的参数吧，如下：</p>
<p>-l ：列出长数据串，包含文件的属性与权限数据等<br>-a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）<br>-d ：仅列出目录本身，而不是列出目录的文件数据<br>-h ：将文件容量以较易读的方式（GB，kB等）列出来<br>-R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来<br>注：这些参数也可以组合使用，下面举两个例子：</p>
<p>ls -l #以长数据串的形式列出当前目录下的数据文件和目录<br>ls -lR #以长数据串的形式列出当前目录下的所有文件</p>
<h1 id="3、grep命令"><a href="#3、grep命令" class="headerlink" title="3、grep命令"></a>3、grep命令</h1><p>该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，它的简单语法为</p>
<p>grep [-acinv] [–color=auto] ‘查找字符串’ filename<br>它的常用参数如下：</p>
<p>-a ：将binary文件以text文件的方式查找数据<br>-c ：计算找到‘查找字符串’的次数<br>-i ：忽略大小写的区别，即把大小写视为相同<br>-v ：反向选择，即显示出没有‘查找字符串’内容的那一行<br> 例如：<br> 取出文件/etc/man.config中包含MANPATH的行，并把找到的关键字加上颜色<br>grep –color=auto ‘MANPATH’ /etc/man.config<br> 把ls -l的输出中包含字母file（不区分大小写）的内容输出<br>ls -l | grep -i file</p>
<h1 id="4、find命令"><a href="#4、find命令" class="headerlink" title="4、find命令"></a>4、find命令</h1><p>find是一个基于查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多，所以在这里将给把它们分类列出，它的基本语法如下：</p>
<p>find [PATH] [option] [action]</p>
<p> 与时间有关的参数：<br>-mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；<br>-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；<br>-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；<br>-newer file : 列出比file还要新的文件名<br> 例如：<br>find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件</p>
<p> 与用户或用户组名有关的参数：<br>-user name : 列出文件所有者为name的文件<br>-group name : 列出文件所属用户组为name的文件<br>-uid n : 列出文件所有者为用户ID为n的文件<br>-gid n : 列出文件所属用户组为用户组ID为n的文件<br> 例如：<br>find /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件</p>
<p> 与文件权限及名称有关的参数：<br>-name filename ：找出文件名为filename的文件<br>-size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件<br>-tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、<br>             目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；<br>-perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755；<br>-perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示<br>-perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示<br> 例如：<br>find / -name passwd # 查找文件名为passwd的文件<br>find . -perm 0755 # 查找当前目录中文件权限的0755的文件<br>find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte</p>
<h1 id="5、cp命令"><a href="#5、cp命令" class="headerlink" title="5、cp命令"></a>5、cp命令</h1><p>该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下，它的常用参数如下：</p>
<p>-a ：将文件的特性一起复制<br>-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份<br>-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行<br>-r ：递归持续复制，用于目录的复制行为<br>-u ：目标文件与源文件有差异时才会复制<br>例如 ：</p>
<p>cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2<br>cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中</p>
<h1 id="6、mv命令"><a href="#6、mv命令" class="headerlink" title="6、mv命令"></a>6、mv命令</h1><p>该命令用于移动文件、目录或更名，move之意，它的常用参数如下：</p>
<p>-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖<br>-i ：若目标文件已经存在，就会询问是否覆盖<br>-u ：若目标文件已经存在，且比目标文件新，才会更新<br>注：该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”。</p>
<p>例如：</p>
<p>mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中<br>mv file1 file2 # 把文件file1重命名为file2</p>
<h1 id="7、rm命令"><a href="#7、rm命令" class="headerlink" title="7、rm命令"></a>7、rm命令</h1><p>该命令用于删除文件或目录，remove之间，它的常用参数如下：</p>
<p>-f ：就是force的意思，忽略不存在的文件，不会出现警告消息<br>-i ：互动模式，在删除前会询问用户是否操作<br>-r ：递归删除，最常用于目录删除，它是一个非常危险的参数<br>例如：</p>
<p>rm -i file # 删除文件file，在删除之前会询问是否进行该操作<br>rm -rf dir # 强制删除目录dir中的所有文件</p>
<h1 id="8、ps命令"><a href="#8、ps命令" class="headerlink" title="8、ps命令"></a>8、ps命令</h1><p>该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下：</p>
<p>-A ：所有的进程均显示出来<br>-a ：不与terminal有关的所有进程<br>-u ：有效用户的相关进程<br>-x ：一般与a参数一起使用，可列出较完整的信息<br>-l ：较长，较详细地将PID的信息列出<br>其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下：</p>
<p>ps aux # 查看系统所有的进程数据<br>ps ax # 查看不与terminal有关的所有进程<br>ps -lA # 查看系统所有的进程数据<br>ps axjf # 查看连同一部分进程树状态</p>
<h1 id="9、kill命令"><a href="#9、kill命令" class="headerlink" title="9、kill命令"></a>9、kill命令</h1><p>该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：</p>
<p>kill -signal PID<br>signal的常用参数如下：</p>
<p>注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。</p>
<p>1：SIGHUP，启动被终止的进程<br>2：SIGINT，相当于输入ctrl+c，中断一个程序的进行<br>9：SIGKILL，强制中断一个进程的进行<br>15：SIGTERM，以正常的结束进程方式来终止进程<br>17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行<br>例如：</p>
<p> 以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程<br>kill -SIGTERM %1<br> 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得<br>kill -SIGHUP PID</p>
<h1 id="10、killall命令"><a href="#10、killall命令" class="headerlink" title="10、killall命令"></a>10、killall命令</h1><p>该命令用于向一个命令启动的进程发送一个信号，它的一般语法如下：</p>
<p>killall [-iIe] [command name]<br>它的参数如下：</p>
<p>-i ：交互式的意思，若需要删除时，会询问用户<br>-e ：表示后面接的command name要一致，但command name不能超过15个字符<br>-I ：命令名称忽略大小写<br> 例如：<br>killall -SIGHUP syslogd # 重新启动syslogd</p>
<h1 id="11、file命令"><a href="#11、file命令" class="headerlink" title="11、file命令"></a>11、file命令</h1><p>该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了，它的用法非常简单，基本语法如下：</p>
<p>file filename</p>
<p>#例如：<br>file ./test</p>
<h1 id="12、tar命令"><a href="#12、tar命令" class="headerlink" title="12、tar命令"></a>12、tar命令</h1><p>该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下：</p>
<p>-c ：新建打包文件<br>-t ：查看打包文件的内容含有哪些文件名<br>-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中<br>-j ：通过bzip2的支持进行压缩/解压缩<br>-z ：通过gzip的支持进行压缩/解压缩<br>-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来<br>-f filename ：filename为要处理的文件<br>-C dir ：指定压缩/解压缩的目录dir<br>上面的解说可以已经让你晕过去了，但是通常我们只需要记住下面三条命令即可：</p>
<p>压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称<br>查询：tar -jtv -f filename.tar.bz2<br>解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录<br>注：文件名并不定要以后缀tar.bz2结尾，这里主要是为了说明使用的压缩程序为bzip2</p>
<h1 id="13、cat命令"><a href="#13、cat命令" class="headerlink" title="13、cat命令"></a>13、cat命令</h1><p>该命令用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用，从而可以一页页地查看数据。例如：</p>
<p>cat text | less # 查看text文件中的内容<br> 注：这条命令也可以使用less text来代替</p>
<h1 id="14、chgrp命令"><a href="#14、chgrp命令" class="headerlink" title="14、chgrp命令"></a>14、chgrp命令</h1><p>该命令用于改变文件所属用户组，它的使用非常简单，它的基本用法如下：</p>
<p>chgrp [-R] dirname/filename<br>-R ：进行递归的持续对所有文件和子目录更改<br> 例如：<br>chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users</p>
<h1 id="15、chown命令"><a href="#15、chown命令" class="headerlink" title="15、chown命令"></a>15、chown命令</h1><p>该命令用于改变文件的所有者，与chgrp命令的使用方法相同，只是修改的文件属性不同，不再详述。</p>
<h1 id="16、chmod命令"><a href="#16、chmod命令" class="headerlink" title="16、chmod命令"></a>16、chmod命令</h1><p>该命令用于改变文件的权限，一般的用法如下：</p>
<p>chmod [-R] xyz 文件或目录<br>-R：进行递归的持续更改，即连同子目录下的所有文件都会更改<br>同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改。</p>
<p> 例如：<br>chmod 0755 file # 把file的文件权限改变为-rxwr-xr-x<br>chmod g+w file # 向file的文件权限中加入用户组可写权限</p>
<h1 id="17、vi命令"><a href="#17、vi命令" class="headerlink" title="17、vi命令"></a>17、vi命令</h1><p>Vi 在任何 Linux/Unix 发行安装上都存在。因此，我们有必要了解一些基本的命令。Vi 有两个模式：命令模式和插入模式。使用 [ESC] 键可进入命令模式，使用 i 键可进入插入模式。如果你迷失了，可在命令模式下键入 : help。编辑器 nano 和 pico 通常也都可用，而且更容易(IMHO)使用。</p>
<p>:w newfilename 保存文件为 newfilename<br>:wq or :x 保存并退出<br>:q! 退出但不保存<br>/string 向前查找 string<br>?string 向后查找 string<br>n 同方向重复上一次搜索命令<br>N 反方向重复上一次搜索命令<br>{ 光标移至段落结尾<br>} 光标移至段落开头<br>1G 光标移至文件的第一行首<br>nG 光标移至文件的第 n 行首<br>G 光标移至文件的最后一行首<br>:%s/OLD/NEW/g 替换所有查找到的 OLD 为 NEW<br>dd 删除当前行<br>D 删除光标到当前行末尾的字符<br>dw 删除单词<br>x 删除字符<br>u 回复上一次操作<br>U 回复所有此行的更改</p>
<h1 id="18、vim命令"><a href="#18、vim命令" class="headerlink" title="18、vim命令"></a>18、vim命令</h1><p>该命令主要用于文本编辑，它接一个或多个文件名作为参数，如果文件存在就打开，如果文件不存在就以该文件名创建一个文件。vim是一个非常好用的文本编辑器，它里面有很多非常好用的命令，在这里不再多说。后期单介绍它。</p>
<h1 id="19、gcc命令"><a href="#19、gcc命令" class="headerlink" title="19、gcc命令"></a>19、gcc命令</h1><p>对于一个用Linux开发C程序的人来说，这个命令就非常重要了，它用于把C语言的源程序文件，编译成可执行程序，由于g++的很多参数跟它非常相似，所以这里只介绍gcc的参数，它的常用参数如下：</p>
<p>-o ：output之意，用于指定生成一个可执行文件的文件名<br>-c ：用于把源文件生成目标文件（.o)，并阻止编译器创建一个完整的程序<br>-I ：增加编译时搜索头文件的路径<br>-L ：增加编译时搜索静态连接库的路径<br>-S ：把源文件生成汇编代码文件<br>-lm：表示标准库的目录中名为libm.a的函数库<br>-lpthread ：连接NPTL实现的线程库<br>-std= ：用于指定把使用的C语言的版本</p>
<p> 例如：<br> 把源文件test.c按照c99标准编译成可执行程序test<br>gcc -o test test.c -lm -std=c99</p>
<p>#把源文件test.c转换为相应的汇编程序源文件test.s<br>gcc -S test.c</p>
<h1 id="20、time命令"><a href="#20、time命令" class="headerlink" title="20、time命令"></a>20、time命令</h1><p>该命令用于测算一个命令（即程序）的执行时间。它的使用非常简单，就像平时输入命令一样，不过在命令的前面加入一个time即可，例如：</p>
<p>time ./process<br>time ps aux<br>在程序或命令运行结束后，在最后输出了三个时间，它们分别是：</p>
<p>user：用户CPU时间，命令执行完成花费的用户CPU时间，即命令在用户态中执行时间总和；</p>
<p>system：系统CPU时间，命令执行完成花费的系统CPU时间，即命令在核心态中执行时间总和；</p>
<p>real：实际时间，从command命令行开始执行到运行终止的消逝时间；</p>
<p>注：用户CPU时间和系统CPU时间之和为CPU时间，即命令占用CPU执行的时间总和。实际时间要大于CPU时间，因为Linux是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务。另一个需要注意的问题是即使每次执行相同命令，但所花费的时间也是不一样，其花费时间是与系统运行相关的。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【springboot】 springboot 整合mybatis-plus]]></title>
      <url>/2017/12/23/%E3%80%90springboot%E3%80%91-springboot-%E6%95%B4%E5%90%88mybatis-plus/</url>
      <content type="html"><![CDATA[<p>(转)springboot整和mybatis-plus</p>
<p>整合步骤,以后开发可以使用mybatis-plus了功能非常强大</p>
<p>文档地址：<a href="http://baomidou.oschina.io/mybatis-plus-doc" target="_blank" rel="noopener">http://baomidou.oschina.io/mybatis-plus-doc</a></p>
<a id="more"></a>
<h1 id="1-pom-xml-添加mp依赖"><a href="#1-pom-xml-添加mp依赖" class="headerlink" title="1.pom.xml 添加mp依赖"></a>1.pom.xml 添加mp依赖</h1><pre><code>&lt;!-- mybatis-plus begin --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
        &lt;artifactId&gt;mybatisplus-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;${mybatisplus-spring-boot-starter.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;
    &lt;version&gt;${mybatisplus.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 如果要使用mp的代码生成还需要加入模板引擎,不建议使用maven插件生成啦！！！ --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
    &lt;artifactId&gt;velocity&lt;/artifactId&gt;
    &lt;version&gt;${velocity.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- mybatis-plus end --&gt;
</code></pre><h1 id="2-application-yml-配置"><a href="#2-application-yml-配置" class="headerlink" title="2.application.yml 配置"></a>2.application.yml 配置</h1><pre><code># datasoure默认使用JDBC
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    username: root
    password: root
    url: jdbc:mysql://127.0.0.1/cloud?characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true

#mybaits-plus配置，修改主键类型，mapper.xml、type 别名等
mybatis-plus:
  mapper-locations: classpath:/mapper/*Mapper.xml
  typeAliasesPackage: com.example.sbmp.entity
  global-config:
    #主键类型  0:&quot;数据库ID自增&quot;, 1:&quot;用户输入ID&quot;,2:&quot;全局唯一ID (数字类型唯一ID)&quot;, 3:&quot;全局唯一ID UUID&quot;;
    id-type: 0
    #字段策略 0:&quot;忽略判断&quot;,1:&quot;非 NULL 判断&quot;),2:&quot;非空判断&quot;
    field-strategy: 0
    #驼峰下划线转换
    db-column-underline: true
    #刷新mapper 调试神器
    refresh-mapper: true
    #数据库大写下划线转换
    #capital-mode: true
  configuration:
    map-underscore-to-camel-case: true
    cache-enabled: true
</code></pre><h1 id="3-mapper扫描配置"><a href="#3-mapper扫描配置" class="headerlink" title="3.mapper扫描配置"></a>3.mapper扫描配置</h1><pre><code>@Configuration
@MapperScan(&quot;com.example.sbmp.mapper*&quot;)
public class MybatisPlusConfig {
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        return new PaginationInterceptor();
    }
}
</code></pre><h1 id="4-代码生成配置-来源官方文档（Main方法，maven插件不兼容2-0-版本啦，不推荐使用啦）"><a href="#4-代码生成配置-来源官方文档（Main方法，maven插件不兼容2-0-版本啦，不推荐使用啦）" class="headerlink" title="4.代码生成配置,来源官方文档（Main方法，maven插件不兼容2.0+版本啦，不推荐使用啦）"></a>4.代码生成配置,来源官方文档（Main方法，maven插件不兼容2.0+版本啦，不推荐使用啦）</h1><pre><code>public class MybatisPlusGenerator {
    public static void main(String[] args) {
        AutoGenerator mpg = new AutoGenerator();

        // 全局配置
        GlobalConfig gc = new GlobalConfig();
        gc.setOutputDir(&quot;D://data&quot;);
        gc.setFileOverride(true);
        gc.setActiveRecord(true);
        gc.setEnableCache(false);// XML 二级缓存
        gc.setBaseResultMap(true);// XML ResultMap
        gc.setBaseColumnList(false);// XML columList
        gc.setAuthor(&quot;lengleng&quot;);
        mpg.setGlobalConfig(gc);

        // 数据源配置
        DataSourceConfig dsc = new DataSourceConfig();
        dsc.setDbType(DbType.MYSQL);
        dsc.setDriverName(&quot;com.mysql.jdbc.Driver&quot;);
        dsc.setUsername(&quot;root&quot;);
        dsc.setPassword(&quot;root&quot;);
        dsc.setUrl(&quot;jdbc:mysql://127.0.0.1:3306/cloud?characterEncoding=utf8&quot;);
        mpg.setDataSource(dsc);

        // 策略配置
        StrategyConfig strategy = new StrategyConfig();
        // strategy.setCapitalMode(true);// 全局大写命名 ORACLE 注意
        strategy.setTablePrefix(new String[]{&quot;tlog_&quot;, &quot;tsys_&quot;});// 此处可以修改为您的表前缀
        strategy.setNaming(NamingStrategy.underline_to_camel);// 表名生成策略
        mpg.setStrategy(strategy);

        // 包配置
        PackageConfig pc = new PackageConfig();
        pc.setParent(&quot;com.example.sbmp&quot;);
        mpg.setPackageInfo(pc);

        mpg.execute();
    }
}
</code></pre><p>5.把生成的代码扔到源码下，开始springboot和mybatis 的使用吧。</p>
<p>一些常用功能的说明<br>配置二级缓存<br>application.yml 配置的cache-enabled: true 并不是开启SQL的缓存，而是开启动态加载 mapper.xml</p>
<p>配置方式通普通方式一样在mapper.xml 配置 （注意在生成时候可以设置）</p>
<pre><code>&lt;cache/&gt;
</code></pre><p>关于一级缓存和二级缓存</p>
<p>一级缓存属于sqlSession级别的，同一个sqlSession调用会被命中<br>二级缓存属于mapper级别的，同一个mapper调用会被命中</p>
<p>配置logback.xml 显示mybatis执行SQL</p>
<p>#在application.yml配置</p>
<pre><code>logging:
  config: classpath:logback.xml
 #1.在logback.xml 配置一个logger节点，指定mapper包下日志级别DEBU，并执行一个console appender。（这种方式不受ROOT级别的控制）
&lt;logger name=&quot;com.example.sbmp.mapper&quot; level=&quot;DEBUG&quot;&gt;
    &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;
&lt;/logger&gt;
</code></pre><p>源码： <a href="http://git.oschina.net/boding1/pig-cloud/tree/master/springboot-mybatis-plus" target="_blank" rel="noopener">http://git.oschina.net/boding1/pig-cloud/tree/master/springboot-mybatis-plus</a></p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
            <category> Mybatis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cloud Zuul结合Smconf配置中心动态进行IP黑名单限制]]></title>
      <url>/2017/12/22/Spring-Cloud-Zuul%E7%BB%93%E5%90%88Smconf%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8A%A8%E6%80%81%E8%BF%9B%E8%A1%8CIP%E9%BB%91%E5%90%8D%E5%8D%95%E9%99%90%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>API网关中最常见的一个功能就是防止爬虫，当然防止爬虫的前提是先得识别出这个请求是爬虫</p>
<p>这部分我们不涉及，假设我们已经能够识别出爬虫的请求了，那么怎么限制呢？</p>
<p>最常见的就是根据IP限制，某个IP大量访问就比较异常了</p>
<p>之前讲过 Spring Cloud 如何选择分布式配置中心 利用动态的配置中心我们可以最很多操作</p>
<p>这篇主要介绍下如何对IP进行禁用操作</p>
<a id="more"></a>
<p>首先是集成我们的配置中心Smconf, 至于怎么集成这边不做过多讲解，大家看下我们的github即可<br><a href="https://github.com/yinjihuan/smconf" target="_blank" rel="noopener">https://github.com/yinjihuan/smconf</a></p>
<p>定义一个配置类用来存储IP黑名单信息</p>
<pre><code>/**
 * 基础配置信息
 *
 * @author yinjihuan
 * @create 2017-11-15 17:06
 **/
@CxytianDiConf(system = &quot;fangjia-fsh-api&quot;)
public class BasicConf {

    @ConfField(&quot;IP黑名单，多个用逗号分隔&quot;)
    private String ipStr = &quot;default&quot;;

    public String getIpStr() {
        return ipStr;
    }

    public void setIpStr(String ipStr) {
        this.ipStr = ipStr;
    }
}
</code></pre><p>建一个Zuul的Filter,用来过滤黑名单中存在的IP, 这边直接可以在过滤器中使用配置信息</p>
<pre><code>@Autowired
private BasicConf basicConf;

@Override
public Object run() {
    RequestContext ctx = RequestContext.getCurrentContext();
    String ip = IpUtils.getIpAddr(ctx.getRequest());
    // 在黑名单中禁用
    if (StringUtils.isNotBlank(ip) &amp;&amp; basicConf != null &amp;&amp; basicConf.getIpStr().contains(ip)) {
        ctx.set(&quot;isSuccess&quot;, false);
        ctx.setSendZuulResponse(false);
        ResponseData data = ResponseData.fail(&quot;非法请求&quot;, ResponseCode.NO_AUTH_CODE.getCode());
        ctx.setResponseBody(JsonUtils.toJson(data));
        ctx.getResponse().setContentType(&quot;application/json; charset=utf-8&quot;);
        return null;
    }
    return null;
}
</code></pre><p>在每个请求过来的时候都会去判断这个IP是否在黑名单中是否存在，如果存在则不进行转发操作，直接回复内容给客户端</p>
<p>我们假设判断是否为爬虫的程序已经好了，并且能够识别出爬虫的IP,识别出之后就将IP信息加入到配置中心即可，这边会实时更新配置中心的信息，来做限制</p>
<p>具体代码可以参考我的github:</p>
<p><a href="https://github.com/yinjihuan/spring-cloud" target="_blank" rel="noopener">https://github.com/yinjihuan/spring-cloud</a></p>
]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Cloud Eureka 控制台快速查看Swagger API文档]]></title>
      <url>/2017/12/22/Spring-Cloud-Eureka-%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%BF%AB%E9%80%9F%E6%9F%A5%E7%9C%8BSwagger-API%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<p>在服务比较多的情况下，突然想看某个服务的API 文档</p>
<p>虽然外面使用了Swagger来进行API的管理，但是还是得找到对应的服务，然后访问Swagger的管理页面才行。</p>
<p>为了方便查询文档，把这个功能集成到Eureka中，这样就很方便了</p>
<a id="more"></a>
<p>默认的Instances也是有链接跳转的，外面需要把这个跳转改成Swagger的管理页面</p>
<p>这样直接点击 <strong>fsh-house:192.168.10.170:2101</strong> 就能跳转到Swagger</p>
<p><img src="http://oisa91ton.bkt.clouddn.com/1513921058272fqw8kbq3.png?imageslim" alt="paste image"></p>
<p>很简单，只需要加上下面的配置即可：</p>
<pre><code>eureka.instance.status-page-url=http://${spring.cloud.client.ipAddress}:${server.port}/swagger-ui.html
</code></pre>]]></content>
      
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> swagger </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[梦想开始的地方]]></title>
      <url>/2017/12/17/%E6%A2%A6%E6%83%B3%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
      <content type="html"><![CDATA[<h1 id="梦想开始的地方"><a href="#梦想开始的地方" class="headerlink" title="梦想开始的地方"></a>梦想开始的地方</h1><p><img src="http://oisa91ton.bkt.clouddn.com/1513490917021jgbvulzt.png?imageslim" alt="paste image"></p>
<a id="more"></a>
<div id="dplayer4" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"video":{"url":"http://oisa91ton.bkt.clouddn.com/%E3%80%90SNH48%E3%80%91%20%E3%80%8A%E6%A2%A6%E6%83%B3%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%8B%20-%201.%E6%A2%A6%E6%83%B3%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9%28Av15910070,P1%29.Mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
]]></content>
      
        <categories>
            
            <category> 梦想开始的地方 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【酸奶】EXID - Up & Down 翻跳]]></title>
      <url>/2017/12/17/%E3%80%90%E9%85%B8%E5%A5%B6%E3%80%91EXID-Up-Down-%E7%BF%BB%E8%B7%B3/</url>
      <content type="html"><![CDATA[<h1 id="EXID-Up-amp-Down-翻跳"><a href="#EXID-Up-amp-Down-翻跳" class="headerlink" title="EXID - Up &amp; Down 翻跳"></a>EXID - Up &amp; Down 翻跳</h1><p><img src="http://oisa91ton.bkt.clouddn.com/1513490826881zpdyvl3l.png?imageslim" alt="paste image"></p>
<a id="more"></a>
<div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"video":{"url":"http://oisa91ton.bkt.clouddn.com/%E3%80%90%E9%85%B8%E5%A5%B6%E3%80%91EXID%20-%20Up%20&%20Down%20%E7%BF%BB%E8%B7%B3%20-%201.1%28Av15333337,P1%29.Mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
        <categories>
            
            <category> 舞蹈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【酸奶】AOA 猫步轻俏 翻跳]]></title>
      <url>/2017/12/17/%E3%80%90%E9%85%B8%E5%A5%B6%E3%80%91AOA-%E7%8C%AB%E6%AD%A5%E8%BD%BB%E4%BF%8F-%E7%BF%BB%E8%B7%B3/</url>
      <content type="html"><![CDATA[<h1 id="AOA-猫步轻俏-翻跳"><a href="#AOA-猫步轻俏-翻跳" class="headerlink" title="AOA 猫步轻俏 翻跳"></a>AOA 猫步轻俏 翻跳</h1><p><img src="http://oisa91ton.bkt.clouddn.com/1513490710090mgqyfc39.png?imageslim" alt="paste image"></p>
<a id="more"></a>
<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"http://oisa91ton.bkt.clouddn.com/%E3%80%90%E9%85%B8%E5%A5%B6%E3%80%91AOA%20%E7%8C%AB%E6%AD%A5%E8%BD%BB%E4%BF%8F%20%20%E7%BF%BB%E8%B7%B3%20-%201.1%28Av15336360,P1%29.Mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
        <categories>
            
            <category> 舞蹈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[中华第一腿]]></title>
      <url>/2017/12/17/%E4%B8%AD%E5%8D%8E%E7%AC%AC%E4%B8%80%E8%85%BF/</url>
      <content type="html"><![CDATA[<h1 id="B站第一腿"><a href="#B站第一腿" class="headerlink" title="B站第一腿"></a>B站第一腿</h1><p><img src="http://oisa91ton.bkt.clouddn.com/1513489653068jid286c8.png?imageslim" alt="paste image"></p>
<a id="more"></a>
<div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"video":{"url":"http://oisa91ton.bkt.clouddn.com/%E3%80%90%E7%88%B1%E4%B8%BD%E4%B8%9D%E3%80%91Up&Down%E8%A6%81%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%BF%83%EF%BC%8C%E4%B8%8A%E4%B8%8B%E5%8A%A8%E6%91%87~%20-%201.1%28Av5263897,P1%29.Mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
        <categories>
            
            <category> 舞蹈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[你想怎样就怎样╮(╯_╰)╭ - 1.1]]></title>
      <url>/2017/12/17/%E4%BD%A0%E6%83%B3%E6%80%8E%E6%A0%B7%E5%B0%B1%E6%80%8E%E6%A0%B7%E2%95%AE-%E2%95%AF-%E2%95%B0-%E2%95%AD-1-1/</url>
      <content type="html"><![CDATA[<h1 id="你想怎样就怎样╮-╯-╰-╭"><a href="#你想怎样就怎样╮-╯-╰-╭" class="headerlink" title="你想怎样就怎样╮(╯_╰)╭ -"></a>你想怎样就怎样╮(╯_╰)╭ -</h1><p><img src="http://oisa91ton.bkt.clouddn.com/%E3%80%90Rainbow%E5%B0%8F%E4%BA%9A%E3%80%91%E5%B0%8F%E9%87%8E%E9%A9%AC-Red%20%E7%A5%9D%E5%A4%A7%E5%AE%B62017%E7%BA%A2%E7%BA%A2%E7%81%AB%E7%81%AB.jpg" alt="paste image"></p>
<a id="more"></a>
<div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"video":{"url":"http://oisa91ton.bkt.clouddn.com/%E3%80%90Rainbow%E5%B0%8F%E4%BA%9A%E3%80%91%E5%B0%8F%E9%87%8E%E9%A9%AC-Red%20%E7%A5%9D%E5%A4%A7%E5%AE%B62017%E7%BA%A2%E7%BA%A2%E7%81%AB%E7%81%AB%20-%201.%E7%88%B1%E5%89%AA%E8%BE%91-%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91%E3%80%90red%E3%80%91%2800h00m08s-00h03m35s%29_x26%28Av7840506,P1%29.Mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
        <categories>
            
            <category> 舞蹈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[B站女王啊]]></title>
      <url>/2017/12/17/%E8%BF%99%E8%88%9E%E8%B9%88%E5%8F%AF%E4%BB%A5/</url>
      <content type="html"><![CDATA[<h1 id="B站女王啊"><a href="#B站女王啊" class="headerlink" title="B站女王啊"></a>B站女王啊</h1><p><img src="http://oisa91ton.bkt.clouddn.com/1513489829071e4p6fl20.png?imageslim" alt="paste image"></p>
<a id="more"></a>
<div id="dplayer5" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer5"),"video":{"url":"http://oisa91ton.bkt.clouddn.com/JiJiDown.COM%20%E7%88%B1%E4%B8%BD%E4%B8%9D%20Volume%20Up%20%E8%AE%A9%E6%88%91%E7%9A%84%E5%A3%B0%E9%9F%B3%E5%93%8D%E5%BD%BB%E5%A4%A9%E9%99%85%20Av16695972%20P1%20.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
        <categories>
            
            <category> 舞蹈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bilibili </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git常用命令]]></title>
      <url>/2017/12/16/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p><img src="http://oisa91ton.bkt.clouddn.com/20171216120142.png" alt="“git”"> </p>
<a id="more"></a>
<h3 id="git-流程"><a href="#git-流程" class="headerlink" title="git 流程"></a>git 流程</h3><p>git status<br>git add .<br>git commit<br>git pull<br>git push origin branchName:refs/for/branchName<br>git pull</p>
<h3 id="create-branch"><a href="#create-branch" class="headerlink" title="create branch"></a>create branch</h3><p>git checkout -b featureOne<br>git push —set-upstream origin featureOne<br>git add .<br>git commit -m ‘msg’<br>git pull<br>git push origin featureOne:refs/for/featureOne<br>git pull</p>
<h3 id="merge-to-master"><a href="#merge-to-master" class="headerlink" title="merge to master"></a>merge to master</h3><p>git checkout master<br>git merge featureOne<br>git add .<br>git commit -m ‘merge’<br>git pull<br>git push origin master:refs/for/master<br>git pull</p>
<p>done</p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Git分支管理]]></title>
      <url>/2017/12/15/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>分支的独立性：现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。<br><a id="more"></a><br>git分支的高效：其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<p>理解HEAD头指针</p>
<p>一开始的时候，HEAD头指针指向的是主分支，即master分支。而HEAD指向的是当前分支，master指向的是提交。</p>
<p>如果，在master分支上新建了一个分支dev，此时HEAD指向了dev，Git建立分支的过程很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。</p>
<p>创建dev分支</p>
<p>创建分支使用git branch命令，命令格式：git branch [分支别名]</p>
<p>$ git branch dev<br>可以使用$ git branch来查看所有本地分支，$ git branch -a查看所有分支（包括远程分支）。</p>
<p>使用git checkout [分支名]切换到对应的分支，如：</p>
<p>$ git checkout dev<br>此时，HEAD头指针会指向dev，如果在dev上提交，dev指针会往前移，而其他分支不变。（master分支及指针不变）</p>
<p>当使用git checkout master时，HEAD头指针会重新指向master，此时再提交，master指针会往前移。</p>
<p>这个过程，需要自己亲身的试验才能体会到它们的作用和变化。</p>
<p>$gitk<br>使用Git自带的图形界面，可以很好的来管理分支。</p>
<p>冲突解决</p>
<p>冲突产生：当两个分支中修改的相同的文件并提交（add-&gt;commit），合并(merge)这两个分支的时候，会产生冲突。</p>
<p>如下例：</p>
<p>$ git checkout -b feature1<br>在新的feature1分支下修改了readme.txt：</p>
<p>vi readme.txt<br>//修改，添加Creating a new branch is quick AND simple.<br>$ git add readme.txt<br>$ git commit -m “AND simple”<br>切换到master分支：</p>
<p>$ git checkout master</p>
<p>vi readme.txt<br>//在<code>master</code>分支上把readme.txt文件的最后一行改为：Creating a new branch is quick &amp; simple<br>$ git add readme.txt<br>$ git commit -m “&amp; simple”<br>试图合并master与feature1：</p>
<p>$ git merge feature1<br>Auto-merging readme.txt<br>CONFLICT (content): Merge conflict in readme.txt<br>Automatic merge failed; fix conflicts and then commit the result.</p>
<p>（1）使用：$ git status来查看冲突文件：</p>
<p>$ git status</p>
<h1 id="On-branch-master"><a href="#On-branch-master" class="headerlink" title="On branch master"></a>On branch master</h1><h1 id="Your-branch-is-ahead-of-‘origin-master’-by-2-commits"><a href="#Your-branch-is-ahead-of-‘origin-master’-by-2-commits" class="headerlink" title="Your branch is ahead of ‘origin/master’ by 2 commits."></a>Your branch is ahead of ‘origin/master’ by 2 commits.</h1><p>#</p>
<h1 id="Unmerged-paths"><a href="#Unmerged-paths" class="headerlink" title="Unmerged paths:"></a>Unmerged paths:</h1><h1 id="use-“git-add-rm-…”-as-appropriate-to-mark-resolution"><a href="#use-“git-add-rm-…”-as-appropriate-to-mark-resolution" class="headerlink" title="(use “git add/rm …” as appropriate to mark resolution)"></a>(use “git add/rm <file>…” as appropriate to mark resolution)</file></h1><p>#</p>
<h1 id="both-modified-readme-txt"><a href="#both-modified-readme-txt" class="headerlink" title="both modified:      readme.txt"></a>both modified:      readme.txt</h1><p>#<br>no changes added to commit (use “git add” and/or “git commit -a”)<br>（2）直接查看readme.txt文件内容：</p>
<p>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>Git has a mutable index called stage.<br>Git tracks changes of files.<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h1 id="Creating-a-new-branch-is-quick-amp-simple"><a href="#Creating-a-new-branch-is-quick-amp-simple" class="headerlink" title="Creating a new branch is quick &amp; simple."></a>Creating a new branch is quick &amp; simple.</h1><p>Creating a new branch is quick AND simple.</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>feature1<br>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>Creating a new branch is quick and simple.<br>再提交：</p>
<p>$ git add readme.txt<br>$ git commit -m “conflict fixed”<br>[master 59bc1cb] conflict fixed<br>PS: 用带参数的git log也可以看到分支的合并情况：</p>
<p>$ git log –graph –pretty=oneline –abbrev-commit</p>
<ul>
<li>59bc1cb conflict fixed<br>|\<br>| * 75a857c AND simple</li>
<li>| 400b400 &amp; simple<br>|/</li>
<li>fec145a branch test<br>…<br>最后，删除feature1分支：</li>
</ul>
<p>$ git branch -d feature1<br>Deleted branch feature1 (was 75a857c).</p>
<p>分支管理策略</p>
<p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下–no-ff方式的git merge：</p>
<p>首先，仍然创建并切换dev分支：</p>
<p>$ git checkout -b dev<br>Switched to a new branch ‘dev’<br>修改readme.txt文件，并提交一个新的commit：</p>
<p>$ git add readme.txt<br>$ git commit -m “add merge”<br>[dev 6224937] add merge<br> 1 file changed, 1 insertion(+)<br>现在，我们切换回master：</p>
<p>$ git checkout master<br>Switched to branch ‘master<br>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：</p>
<p>$ git merge –no-ff -m “merge with no-ff” dev<br>Merge made by the ‘recursive’ strategy.<br> readme.txt |    1 +<br> 1 file changed, 1 insertion(+)<br>分支策略</p>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p>Bug分支</p>
<p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：</p>
<p>$ git status</p>
<h1 id="On-branch-dev"><a href="#On-branch-dev" class="headerlink" title="On branch dev"></a>On branch dev</h1><h1 id="Changes-to-be-committed"><a href="#Changes-to-be-committed" class="headerlink" title="Changes to be committed:"></a>Changes to be committed:</h1><h1 id="use-“git-reset-HEAD-…”-to-unstage"><a href="#use-“git-reset-HEAD-…”-to-unstage" class="headerlink" title="(use “git reset HEAD …” to unstage)"></a>(use “git reset HEAD <file>…” to unstage)</file></h1><p>#</p>
<h1 id="new-file-hello-py"><a href="#new-file-hello-py" class="headerlink" title="new file:   hello.py"></a>new file:   hello.py</h1><p>#</p>
<h1 id="Changes-not-staged-for-commit"><a href="#Changes-not-staged-for-commit" class="headerlink" title="Changes not staged for commit:"></a>Changes not staged for commit:</h1><h1 id="use-“git-add-…”-to-update-what-will-be-committed"><a href="#use-“git-add-…”-to-update-what-will-be-committed" class="headerlink" title="(use “git add …” to update what will be committed)"></a>(use “git add <file>…” to update what will be committed)</file></h1><h1 id="use-“git-checkout-–-…”-to-discard-changes-in-working-directory"><a href="#use-“git-checkout-–-…”-to-discard-changes-in-working-directory" class="headerlink" title="(use “git checkout – …” to discard changes in working directory)"></a>(use “git checkout – <file>…” to discard changes in working directory)</file></h1><p>#</p>
<h1 id="modified-readme-txt"><a href="#modified-readme-txt" class="headerlink" title="modified:   readme.txt"></a>modified:   readme.txt</h1><p>#<br>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<p>$ git stash<br>Saved working directory and index state WIP on dev: 6224937 add merge<br>HEAD is now at 6224937 add merge<br>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：</p>
<p>$ git checkout master<br>$ git checkout -b issue-101<br>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p>
<p>$ git add readme.txt<br>$ git commit -m “fix bug 101”<br>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：</p>
<p>$ git checkout master<br>$ git merge –no-ff -m “merged bug fix 101” issue-101<br>$ git branch -d issue-101<br>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！</p>
<p>$ git checkout dev<br>Switched to branch ‘dev’<br>$ git status</p>
<h1 id="On-branch-dev-1"><a href="#On-branch-dev-1" class="headerlink" title="On branch dev"></a>On branch dev</h1><p>nothing to commit (working directory clean)<br>工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：</p>
<p>$ git stash list<br>stash@{0}: WIP on dev: 6224937 add merge<br>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一种方式：用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p>
<p>另一种方式：是用git stash pop，恢复的同时把stash内容也删了：</p>
<p>$ git stash pop</p>
<h1 id="On-branch-dev-2"><a href="#On-branch-dev-2" class="headerlink" title="On branch dev"></a>On branch dev</h1><h1 id="Changes-to-be-committed-1"><a href="#Changes-to-be-committed-1" class="headerlink" title="Changes to be committed:"></a>Changes to be committed:</h1><h1 id="use-“git-reset-HEAD-…”-to-unstage-1"><a href="#use-“git-reset-HEAD-…”-to-unstage-1" class="headerlink" title="(use “git reset HEAD …” to unstage)"></a>(use “git reset HEAD <file>…” to unstage)</file></h1><p>#</p>
<h1 id="new-file-hello-py-1"><a href="#new-file-hello-py-1" class="headerlink" title="new file:   hello.py"></a>new file:   hello.py</h1><p>#</p>
<h1 id="Changes-not-staged-for-commit-1"><a href="#Changes-not-staged-for-commit-1" class="headerlink" title="Changes not staged for commit:"></a>Changes not staged for commit:</h1><h1 id="use-“git-add-…”-to-update-what-will-be-committed-1"><a href="#use-“git-add-…”-to-update-what-will-be-committed-1" class="headerlink" title="(use “git add …” to update what will be committed)"></a>(use “git add <file>…” to update what will be committed)</file></h1><h1 id="use-“git-checkout-–-…”-to-discard-changes-in-working-directory-1"><a href="#use-“git-checkout-–-…”-to-discard-changes-in-working-directory-1" class="headerlink" title="(use “git checkout – …” to discard changes in working directory)"></a>(use “git checkout – <file>…” to discard changes in working directory)</file></h1><p>#</p>
<h1 id="modified-readme-txt-1"><a href="#modified-readme-txt-1" class="headerlink" title="modified:   readme.txt"></a>modified:   readme.txt</h1><p>#<br>Dropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)<br>再用git stash list查看，就看不到任何stash内容了：</p>
<p>$ git stash list<br>你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：</p>
<p>$ git stash apply stash@{0}<br>删除分支</p>
<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>还记得吗？</p>
<p>建立新的分支:git checkout -b feature-new</p>
<p>工作提交：git add –a，git commit -m “something…”</p>
<p>回到dev开发分支：git checkout dev</p>
<p>合并分支：git merge –no-ff feature-new</p>
<p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p>
<p>但是，就在此时，接到上级命令，因经费不足，新功能必须取消！虽然白干了，但是这个分支还是必须就地销毁：</p>
<p>（1）如果没有合并之前，可以简单的使用git branch -d [分支名]来删除分支（使用-D命令，强制删除分支）</p>
<p>（2）如果已经合并，除了上面的需要删除以外，还需要使用前面讲到的git reset –hard HEAD^来退回到上一个版本。</p>
<p>PS:分支的删除，不会影响到其他分支上已经合并的分支内容。</p>
<p>多人协作</p>
<p>多人协作的工作模式通常是这样：</p>
<p>首先，可以试图用git push origin branch-name推送自己的修改；</p>
<p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>
<p>如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p>
<p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p>注：所有工作流建立在已经建立了个人账户，并添加了SSH key到个人的文档中。见Profile Settings → SSH keys → Before you can add an SSH key you need to [generate it].</p>
<p>普通开发人员</p>
<p>情况一：程序员A是后加入到项目中的，项目已经存在代码仓库。</p>
<p>如：git@github.com:kanlidy/HelloGit.git</p>
<p>（1）克隆版本仓库</p>
<p>git clone git@github.com:kanlidy/HelloGit.git<br>（2）建立分支</p>
<p>git checkout -b (分支名)<br>（3）提交代码</p>
<p>查看代码修改的状态：</p>
<p>git status<br>添加到工作区：</p>
<p>git add .<br>提交到本地仓库：</p>
<p>git commit -m “（写下提交日志）”<br>推送到服务器：</p>
<p>git push origin 分支名<br>（4）在服务器上建立Merge Request，把自己的提交到远程的分支，Merge到Dev(开发分支)</p>
<p>情况二：程序员B是在一个新项目中，本地有一些代码，需要建立一个版本控制仓库</p>
<p>（1）在项目目录下，初始化仓库</p>
<p>git init<br>（2）添加到git版本控制系统：</p>
<p>git remote add origin git@github.com:kanlidy/HelloGit.git<br>（3）添加所有已经存在的文件到项目中：</p>
<p>git add .<br>（4）提交代码到本地仓库：</p>
<p>git commit -m “写下日志”<br>（5）提交代码远程服务器</p>
<p>git push origin &lt;本地分支名&gt;：&lt;远程分支名&gt;</p>
<p>git push origin master:master<br>对于单人项目，情况二足以满足代码控制要求。→吕扬、刘扬。</p>
<p>仓库管理人员</p>
<p>情况一：手工合并代码</p>
<p>（1）在指定分支上获取更新</p>
<p>git checkout &lt;指定分支&gt;<br>（2）拉取服务器上的代码</p>
<p>git pull origin &lt;指定分支&gt;<br>（3）切换到dev，并获取dev上的更新，合并指定分支上的代码</p>
<p>git checkout dev<br>git pull origin dev<br>git merge &lt;指定分支&gt;<br>情况二：直接在gitlab上进行操作</p>
<p>直接点击accept merge request进行分支合并。</p>
<p>代码回撤参考git reset命令，获取更新参考git fetch命令，分支查看git branch，逻辑流程图gitk，状态命令git status,日志命令git reflog与git log</p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git常用命令]]></title>
      <url>/2017/12/15/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1/</url>
      <content type="html"><![CDATA[<p>本文介绍了git的常用命令，如git clone、git pull、git push等等。</p>
<p>git clone</p>
<p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。</p>
<p>克隆仓库git clone的语法：<br><a id="more"></a><br>$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;<br>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p>
<p>$ git clone http[s]://example.com/path/to/repo.git/<br>$ git clone ssh://example.com/path/to/repo.git/<br>$ git clone git://example.com/path/to/repo.git/<br>$ git clone /opt/git/project.git<br>$ git clone file:///opt/git/project.git<br>$ git clone ftp[s]://example.com/path/to/repo.git/<br>$ git clone rsync://example.com/path/to/repo.git/<br>SSH协议还有另一种写法。</p>
<p>$ git clone [user@]example.com:path/to/repo.git/<br>还可以使用-b和标签名来克隆指定的分支和tags：</p>
<p>git clone -b r01 <a href="https://github.com/xxxx/xxxx.git" target="_blank" rel="noopener">https://github.com/xxxx/xxxx.git</a><br>git remote</p>
<p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。<br>不带选项的时候，git remote命令列出所有远程主机。</p>
<p>$ git remote<br>origin<br>使用-v选项，可以参看远程主机的网址。</p>
<p>$ git remote -v<br>origin  git@github.com:jquery/jquery.git (fetch)<br>origin  git@github.com:jquery/jquery.git (push)<br>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。<br>克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。</p>
<p>$ git clone -o jQuery <a href="https://github.com/jquery/jquery.git" target="_blank" rel="noopener">https://github.com/jquery/jquery.git</a><br>$ git remote<br>jQuery<br>上面命令表示，克隆的时候，指定远程主机叫做jQuery。<br>git remote show命令加上主机名，可以查看该主机的详细信息。</p>
<p>$ git remote show &lt;主机名&gt;<br>git remote add命令用于添加远程主机。</p>
<p>$ git remote add &lt;主机名&gt; &lt;网址&gt;<br>git remote rm命令用于删除远程主机。</p>
<p>$ git remote rm &lt;主机名&gt;<br>git remote rename命令用于远程主机的改名。</p>
<p>$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;<br>git fetch</p>
<p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。</p>
<p>$ git fetch &lt;远程主机名&gt;<br>上面命令将某个远程主机的更新，全部取回本地。<br>git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。<br>默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>
<p>$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;<br>比如，取回origin主机的master分支。</p>
<p>$ git fetch origin master<br>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。<br>git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。</p>
<p>$ git branch -r<br>origin/master</p>
<p>$ git branch -a</p>
<ul>
<li>master<br>remotes/origin/master<br>上面命令表示，本地主机的当前分支是master，远程分支是origin/master。<br>取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。</li>
</ul>
<p>$ git checkout -b newBrach origin/master<br>上面命令表示，在origin/master的基础上，创建一个新分支。<br>此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。</p>
<p>$ git merge origin/master</p>
<h1 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h1><p>$ git rebase origin/master<br>上面命令表示在当前分支上，合并origin/master。</p>
<p>git pull</p>
<p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p>
<p>$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。</p>
<p>$ git pull origin next:master<br>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>
<p>$ git pull origin next<br>上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。</p>
<p>$ git fetch origin<br>$ git merge origin/next<br>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。<br>Git也允许手动建立追踪关系。</p>
<p>git branch –set-upstream master origin/next<br>上面命令指定master分支追踪origin/next分支。<br>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</p>
<p>$ git pull origin<br>上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。<br>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p>
<p>$ git pull<br>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。<br>如果合并需要采用rebase模式，可以使用–rebase选项。</p>
<p>$ git pull –rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br>如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。<br>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。</p>
<p>$ git pull -p</p>
<h1 id="等同于下面的命令"><a href="#等同于下面的命令" class="headerlink" title="等同于下面的命令"></a>等同于下面的命令</h1><p>$ git fetch –prune origin<br>$ git fetch -p<br>git push</p>
<p>git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。</p>
<p>$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。<br>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>
<p>$ git push origin master<br>上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。<br>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>
<p>$ git push origin :master</p>
<h1 id="等同于"><a href="#等同于" class="headerlink" title="等同于"></a>等同于</h1><p>$ git push origin –delete master<br>上面命令表示删除origin主机的master分支。<br>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>
<p>$ git push origin<br>上面命令表示，将当前分支推送到origin主机的对应分支。<br>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>
<p>$ git push<br>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</p>
<p>$ git push -u origin master<br>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。<br>不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。</p>
<p>$ git config –global push.default matching</p>
<h1 id="或者-1"><a href="#或者-1" class="headerlink" title="或者"></a>或者</h1><p>$ git config –global push.default simple<br>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。</p>
<p>$ git push –all origin<br>上面命令表示，将所有本地分支都推送到origin主机。<br>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。</p>
<p>$ git push –force origin<br>上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。<br>最后，git push不会推送标签（tag），除非使用–tags选项。</p>
<p>$ git push origin –tags</p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot事务配置规则]]></title>
      <url>/2017/12/11/SpringBoot%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99/</url>
      <content type="html"><![CDATA[<h4 id="Spring-Boot-事务配置规则"><a href="#Spring-Boot-事务配置规则" class="headerlink" title="Spring Boot 事务配置规则"></a>Spring Boot 事务配置规则</h4><a id="more"></a>
<pre><code class="java">package com.tayu.interceptor;

import java.util.List;
import java.util.Properties;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.aop.Advisor;
import org.springframework.aop.aspectj.AspectJExpressionPointcut;
import org.springframework.aop.support.DefaultPointcutAdvisor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.interceptor.DefaultTransactionAttribute;
import org.springframework.transaction.interceptor.RollbackRuleAttribute;
import org.springframework.transaction.interceptor.RuleBasedTransactionAttribute;
import org.springframework.transaction.interceptor.TransactionInterceptor;

import com.google.common.collect.Lists;

@Aspect
@Configuration
public class TxAdviceInterceptor {

    /**
     * 需要事务管理的包路径
     */
    private static final String AOP_POINTCUT_EXPRESSION = &quot;execution(* com.tayu.service.*Impl.*(..))&quot;;

    @Autowired
    private PlatformTransactionManager transactionManager;


    /*事务拦截类型*/
    public TransactionInterceptor defaultTransactionInterceptor(PlatformTransactionManager transactionManager,
                                                                List&lt;Class&lt;? extends Exception&gt;&gt; additionalRollbackRuleExceptions) {
        TransactionInterceptor transactionInterceptor = new TransactionInterceptor();
        Properties transactionAttributes = new Properties();

        List&lt;RollbackRuleAttribute&gt; rollbackRules = Lists.newArrayList();
        rollbackRules.add(new RollbackRuleAttribute(Exception.class));
        //回滚异常
        if(additionalRollbackRuleExceptions != null &amp;&amp; !additionalRollbackRuleExceptions.isEmpty()){
            for (Class&lt;? extends Exception&gt; clazz : additionalRollbackRuleExceptions) {
                rollbackRules.add(new RollbackRuleAttribute(clazz));
            }
        }
        DefaultTransactionAttribute readOnlyTransactionAttributes =
                new DefaultTransactionAttribute(TransactionDefinition.PROPAGATION_REQUIRED);
        readOnlyTransactionAttributes.setReadOnly(true);

        RuleBasedTransactionAttribute writeTransactionAttributes =
                new RuleBasedTransactionAttribute(TransactionDefinition.PROPAGATION_REQUIRED, rollbackRules);

        String readOnlyTransactionAttributesDefinition = readOnlyTransactionAttributes.toString();
        String writeTransactionAttributesDefinition = writeTransactionAttributes.toString();
        // read-only 声明只读方法开头
        transactionAttributes.setProperty(&quot;is*&quot;, readOnlyTransactionAttributesDefinition);
        transactionAttributes.setProperty(&quot;has*&quot;, readOnlyTransactionAttributesDefinition);
        transactionAttributes.setProperty(&quot;get*&quot;, readOnlyTransactionAttributesDefinition);
        transactionAttributes.setProperty(&quot;list*&quot;, readOnlyTransactionAttributesDefinition);
        transactionAttributes.setProperty(&quot;search*&quot;, readOnlyTransactionAttributesDefinition);
        transactionAttributes.setProperty(&quot;find*&quot;, readOnlyTransactionAttributesDefinition);
        transactionAttributes.setProperty(&quot;count*&quot;, readOnlyTransactionAttributesDefinition);
        // write et rollback-rule
        transactionAttributes.setProperty(&quot;*&quot;, writeTransactionAttributesDefinition);

        transactionInterceptor.setTransactionAttributes(transactionAttributes);
        transactionInterceptor.setTransactionManager(this.transactionManager);
        return transactionInterceptor;
    }

    /**
     * 切面拦截规则
     */
    @Bean
    public Advisor txAdviceAdvisor() {
        AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
        pointcut.setExpression(AOP_POINTCUT_EXPRESSION);
        return new DefaultPointcutAdvisor(pointcut, this.defaultTransactionInterceptor(this.transactionManager,null));
    }

}
</code></pre>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring Boot Dubbo applications.properties 配置清单]]></title>
      <url>/2017/12/10/Spring-Boot-Dubbo-applications-properties-%E9%85%8D%E7%BD%AE%E6%B8%85%E5%8D%95-1/</url>
      <content type="html"><![CDATA[<p>Springboot 整合 Dubbo/ZooKeeper 详解 SOA 案例</p>
<p>Spring Boot 中如何使用 Dubbo Activate 扩展点<br><a id="more"></a><br>Q：如果一个程序既提供服务又是消费者怎么配置 scan package？<br>A（群友周波）： 就是 com.xxx.provider 生产者，com.xxx.consumer 消费者，那么 scan package 就设置到 com.xxx</p>
<p>Q：如何设置消费者调用生产者的超时时间？<br>A：目前不能通过 application.properties 定义。@Reference timeout</p>
<p>Q：consumer 怎么配置接入多个 provider？<br>A：@Reference 可以指定不同的 register。register （注册中心 like provider container）里面可以对应多个 provider</p>
<p>Q： @Service(version = “1.0.0”) 这个 1.0.0 可以从 application.properties 配置文件中读取吗？可以区分不同的环境，可以统一升级管理<br>A：占时还没有解决… 但是应用环境，如：dev/test/run 可以使用下面的配置，在 application.properties 定义<br>spring.dubbo.application.environment</p>
<p>Spring Boot 整合 Dubbo 的项目依赖了 spring-boot-starter-dubbo 工程，该项目地址是 <a href="https://github.com/teaey/spring-boot-starter-dubbo。" target="_blank" rel="noopener">https://github.com/teaey/spring-boot-starter-dubbo。</a> 感谢作者~</p>
<p>二、applications.properties 配置清单<br>根据 starter 工程源码，可以看出 application.properties 对应的 Dubbo 配置类 DubboProperties 。</p>
<p>@ConfigurationProperties(prefix = “spring.dubbo”)<br>public class DubboProperties {</p>
<pre><code>private String scan;

private ApplicationConfig application;

private RegistryConfig registry;

private ProtocolConfig protocol;
</code></pre><p>}<br>包括了扫描路径、应用配置类、注册中心配置类和服务协议类</p>
<p>所以具体常用配置下<br>扫描包路径：指的是 Dubbo 服务注解的服务包路径</p>
<h1 id="Dubbo-配置"><a href="#Dubbo-配置" class="headerlink" title="Dubbo 配置"></a>Dubbo 配置</h1><h2 id="扫描包路径"><a href="#扫描包路径" class="headerlink" title="扫描包路径"></a>扫描包路径</h2><p>spring.dubbo.scan=org.spring.springboot.dubbo<br>应用配置类：关于 Dubbo 应用级别的配置</p>
<p>这里注意多个注册中心的配置方式。下面介绍单个注册中心的配置方式。</p>
<h1 id="Dubbo-应用配置"><a href="#Dubbo-应用配置" class="headerlink" title="Dubbo 应用配置"></a>Dubbo 应用配置</h1><h2 id="应用名称"><a href="#应用名称" class="headerlink" title="应用名称"></a>应用名称</h2><p>spring.dubbo.application.name=xxx</p>
<h2 id="模块版本"><a href="#模块版本" class="headerlink" title="模块版本"></a>模块版本</h2><p>spring.dubbo.application.version=xxx</p>
<h2 id="应用负责人"><a href="#应用负责人" class="headerlink" title="应用负责人"></a>应用负责人</h2><p>spring.dubbo.application.owner=xxx</p>
<h2 id="组织名-BU或部门"><a href="#组织名-BU或部门" class="headerlink" title="组织名(BU或部门)"></a>组织名(BU或部门)</h2><p>spring.dubbo.application.organization=xxx</p>
<h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>spring.dubbo.application.architecture=xxx</p>
<h2 id="环境，如：dev-test-run"><a href="#环境，如：dev-test-run" class="headerlink" title="环境，如：dev/test/run"></a>环境，如：dev/test/run</h2><p>spring.dubbo.application.environment=xxx</p>
<h2 id="Java代码编译器"><a href="#Java代码编译器" class="headerlink" title="Java代码编译器"></a>Java代码编译器</h2><p>spring.dubbo.application.compiler=xxx</p>
<h2 id="日志输出方式"><a href="#日志输出方式" class="headerlink" title="日志输出方式"></a>日志输出方式</h2><p>spring.dubbo.application.logger=xxx</p>
<h2 id="注册中心-0"><a href="#注册中心-0" class="headerlink" title="注册中心 0"></a>注册中心 0</h2><p>spring.dubbo.application.registries[0].address=zookeeper:#127.0.0.1:2181=xxx</p>
<h2 id="注册中心-1"><a href="#注册中心-1" class="headerlink" title="注册中心 1"></a>注册中心 1</h2><p>spring.dubbo.application.registries[1].address=zookeeper:#127.0.0.1:2181=xxx</p>
<h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p>spring.dubbo.application.monitor.address=xxx<br>注册中心配置类：常用 ZooKeeper 作为注册中心进行服务注册。</p>
<h1 id="Dubbo-注册中心配置类"><a href="#Dubbo-注册中心配置类" class="headerlink" title="Dubbo 注册中心配置类"></a>Dubbo 注册中心配置类</h1><h2 id="注册中心地址"><a href="#注册中心地址" class="headerlink" title="注册中心地址"></a>注册中心地址</h2><p>spring.dubbo.application.registries.address=xxx</p>
<h2 id="注册中心登录用户名"><a href="#注册中心登录用户名" class="headerlink" title="注册中心登录用户名"></a>注册中心登录用户名</h2><p>spring.dubbo.application.registries.username=xxx</p>
<h2 id="注册中心登录密码"><a href="#注册中心登录密码" class="headerlink" title="注册中心登录密码"></a>注册中心登录密码</h2><p>spring.dubbo.application.registries.password=xxx</p>
<h2 id="注册中心缺省端口"><a href="#注册中心缺省端口" class="headerlink" title="注册中心缺省端口"></a>注册中心缺省端口</h2><p>spring.dubbo.application.registries.port=xxx</p>
<h2 id="注册中心协议"><a href="#注册中心协议" class="headerlink" title="注册中心协议"></a>注册中心协议</h2><p>spring.dubbo.application.registries.protocol=xxx</p>
<h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><p>spring.dubbo.application.registries.transporter=xxx</p>
<p>spring.dubbo.application.registries.server=xxx</p>
<p>spring.dubbo.application.registries.client=xxx</p>
<p>spring.dubbo.application.registries.cluster=xxx</p>
<p>spring.dubbo.application.registries.group=xxx</p>
<p>spring.dubbo.application.registries.version=xxx</p>
<h2 id="注册中心请求超时时间-毫秒"><a href="#注册中心请求超时时间-毫秒" class="headerlink" title="注册中心请求超时时间(毫秒)"></a>注册中心请求超时时间(毫秒)</h2><p>spring.dubbo.application.registries.timeout=xxx</p>
<h2 id="注册中心会话超时时间-毫秒"><a href="#注册中心会话超时时间-毫秒" class="headerlink" title="注册中心会话超时时间(毫秒)"></a>注册中心会话超时时间(毫秒)</h2><p>spring.dubbo.application.registries.session=xxx</p>
<h2 id="动态注册中心列表存储文件"><a href="#动态注册中心列表存储文件" class="headerlink" title="动态注册中心列表存储文件"></a>动态注册中心列表存储文件</h2><p>spring.dubbo.application.registries.file=xxx</p>
<h2 id="停止时等候完成通知时间"><a href="#停止时等候完成通知时间" class="headerlink" title="停止时等候完成通知时间"></a>停止时等候完成通知时间</h2><p>spring.dubbo.application.registries.wait=xxx</p>
<h2 id="启动时检查注册中心是否存在"><a href="#启动时检查注册中心是否存在" class="headerlink" title="启动时检查注册中心是否存在"></a>启动时检查注册中心是否存在</h2><p>spring.dubbo.application.registries.check=xxx</p>
<h2 id="在该注册中心上注册是动态的还是静态的服务"><a href="#在该注册中心上注册是动态的还是静态的服务" class="headerlink" title="在该注册中心上注册是动态的还是静态的服务"></a>在该注册中心上注册是动态的还是静态的服务</h2><p>spring.dubbo.application.registries.dynamic=xxx</p>
<h2 id="在该注册中心上服务是否暴露"><a href="#在该注册中心上服务是否暴露" class="headerlink" title="在该注册中心上服务是否暴露"></a>在该注册中心上服务是否暴露</h2><p>spring.dubbo.application.registries.register=xxx</p>
<h2 id="在该注册中心上服务是否引用"><a href="#在该注册中心上服务是否引用" class="headerlink" title="在该注册中心上服务是否引用"></a>在该注册中心上服务是否引用</h2><p>spring.dubbo.application.registries.subscribe=xxx<br>服务协议配置类：</p>
<h1 id="Dubbo-服务协议配置"><a href="#Dubbo-服务协议配置" class="headerlink" title="Dubbo 服务协议配置"></a>Dubbo 服务协议配置</h1><h2 id="服务协议"><a href="#服务协议" class="headerlink" title="服务协议"></a>服务协议</h2><p>spring.dubbo.application.protocol.name=xxx</p>
<h2 id="服务IP地址-多网卡时使用"><a href="#服务IP地址-多网卡时使用" class="headerlink" title="服务IP地址(多网卡时使用)"></a>服务IP地址(多网卡时使用)</h2><p>spring.dubbo.application.protocol.host=xxx</p>
<h2 id="服务端口"><a href="#服务端口" class="headerlink" title="服务端口"></a>服务端口</h2><p>spring.dubbo.application.protocol.port=xxx</p>
<h2 id="上下文路径"><a href="#上下文路径" class="headerlink" title="上下文路径"></a>上下文路径</h2><p>spring.dubbo.application.protocol.contextpath=xxx</p>
<h2 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h2><p>spring.dubbo.application.protocol.threadpool=xxx</p>
<h2 id="线程池大小-固定大小"><a href="#线程池大小-固定大小" class="headerlink" title="线程池大小(固定大小)"></a>线程池大小(固定大小)</h2><p>spring.dubbo.application.protocol.threads=xxx</p>
<h2 id="IO线程池大小-固定大小"><a href="#IO线程池大小-固定大小" class="headerlink" title="IO线程池大小(固定大小)"></a>IO线程池大小(固定大小)</h2><p>spring.dubbo.application.protocol.iothreads=xxx</p>
<h2 id="线程池队列大小"><a href="#线程池队列大小" class="headerlink" title="线程池队列大小"></a>线程池队列大小</h2><p>spring.dubbo.application.protocol.queues=xxx</p>
<h2 id="最大接收连接数"><a href="#最大接收连接数" class="headerlink" title="最大接收连接数"></a>最大接收连接数</h2><p>spring.dubbo.application.protocol.accepts=xxx</p>
<h2 id="协议编码"><a href="#协议编码" class="headerlink" title="协议编码"></a>协议编码</h2><p>spring.dubbo.application.protocol.codec=xxx</p>
<h2 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h2><p>spring.dubbo.application.protocol.serialization=xxx</p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>spring.dubbo.application.protocol.charset=xxx</p>
<h2 id="最大请求数据长度"><a href="#最大请求数据长度" class="headerlink" title="最大请求数据长度"></a>最大请求数据长度</h2><p>spring.dubbo.application.protocol.payload=xxx</p>
<h2 id="缓存区大小"><a href="#缓存区大小" class="headerlink" title="缓存区大小"></a>缓存区大小</h2><p>spring.dubbo.application.protocol.buffer=xxx</p>
<h2 id="心跳间隔"><a href="#心跳间隔" class="headerlink" title="心跳间隔"></a>心跳间隔</h2><p>spring.dubbo.application.protocol.heartbeat=xxx</p>
<h2 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h2><p>spring.dubbo.application.protocol.accesslog=xxx</p>
<h2 id="网络传输方式"><a href="#网络传输方式" class="headerlink" title="网络传输方式"></a>网络传输方式</h2><p>spring.dubbo.application.protocol.transporter=xxx</p>
<h2 id="信息交换方式"><a href="#信息交换方式" class="headerlink" title="信息交换方式"></a>信息交换方式</h2><p>spring.dubbo.application.protocol.exchanger=xxx</p>
<h2 id="信息线程模型派发方式"><a href="#信息线程模型派发方式" class="headerlink" title="信息线程模型派发方式"></a>信息线程模型派发方式</h2><p>spring.dubbo.application.protocol.dispatcher=xxx</p>
<h2 id="对称网络组网方式"><a href="#对称网络组网方式" class="headerlink" title="对称网络组网方式"></a>对称网络组网方式</h2><p>spring.dubbo.application.protocol.networker=xxx</p>
<h2 id="服务器端实现"><a href="#服务器端实现" class="headerlink" title="服务器端实现"></a>服务器端实现</h2><p>spring.dubbo.application.protocol.server=xxx</p>
<h2 id="客户端实现-1"><a href="#客户端实现-1" class="headerlink" title="客户端实现"></a>客户端实现</h2><p>spring.dubbo.application.protocol.client=xxx</p>
<h2 id="支持的telnet命令，多个命令用逗号分隔"><a href="#支持的telnet命令，多个命令用逗号分隔" class="headerlink" title="支持的telnet命令，多个命令用逗号分隔"></a>支持的telnet命令，多个命令用逗号分隔</h2><p>spring.dubbo.application.protocol.telnet=xxx</p>
<h2 id="命令行提示符"><a href="#命令行提示符" class="headerlink" title="命令行提示符"></a>命令行提示符</h2><p>spring.dubbo.application.protocol.prompt=xxx</p>
<h2 id="status检查"><a href="#status检查" class="headerlink" title="status检查"></a>status检查</h2><p>spring.dubbo.application.protocol.status=xxx</p>
<h2 id="是否注册"><a href="#是否注册" class="headerlink" title="是否注册"></a>是否注册</h2><p>spring.dubbo.application.protocol.status=xxx<br>三、@Service 服务提供者常用配置<br>常用 @Service 配置的如下</p>
<p>version 版本<br>group 分组<br>provider 提供者<br>protocol 服务协议<br>monitor 服务监控<br>registry 服务注册<br>…<br>四、@Reference 服务消费者常用配置<br>常用 @Reference 配置的如下</p>
<p>version 版本<br>group 分组<br>timeout 消费者调用提供者的超时时间<br>consumer 服务消费者<br>monitor 服务监控<br>registry 服务注册</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[宅舞]]></title>
      <url>/2017/12/10/%E5%AE%85%E8%88%9E/</url>
      <content type="html"><![CDATA[<p><strong>小姐姐</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><embed pluginspage="http://www.macromedia.com/go/getflashplayer" type="application/x-shockwave-flash" width="800" height="600" flashvars="local=true&amp;amovid=5f4ffbc12418024&amp;refererdomain=yinyuetai.com&amp;domain=yinyuetai.com&amp;videoId=2605740&amp;showlyrics=false&amp;capturevideoavailable=true&amp;sendsnaplog=true&amp;usepromptbar=true&amp;popupwin=true&amp;preamovid=true&amp;autostart=true&amp;showadvipbutton=true&amp;playerready=ifFlash&amp;hasbarrage=true&amp;swflocation=%2F%2Fs.c.yinyuetai.com%2Fswf%2Fcommon%2Fmvplayer.swf%3Ft%3D20171204" bgcolor="#000000" allowfullscreen="true" allowscriptaccess="always" wmode="transparent" id="yinyuetaiplayer" quality="high" name="yinyuetaiplayer" src="//s.c.yinyuetai.com/swf/common/playerloader.swf?t=20170724">]]></content>
      
        <categories>
            
            <category> COS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> COS </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
