<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如果没有你</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ciweigg.github.io/"/>
  <updated>2018-01-29T10:00:43.845Z</updated>
  <id>https://ciweigg.github.io/</id>
  
  <author>
    <name>Ciwei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx负载均衡配置实例</title>
    <link href="https://ciweigg.github.io/2018/01/29/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B/"/>
    <id>https://ciweigg.github.io/2018/01/29/Nginx负载均衡配置实例/</id>
    <published>2018-01-29T08:50:06.000Z</published>
    <updated>2018-01-29T10:00:43.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nginx负载均衡配置实例详解"><a href="#Nginx负载均衡配置实例详解" class="headerlink" title="Nginx负载均衡配置实例详解"></a>Nginx负载均衡配置实例详解</h3><p>[导读] 负载均衡是我们大流量网站要做的一个东西，下面我来给大家介绍在Nginx服务器上进行负载均衡配置方法，希望对有需要的同学有所帮助哦。负载均衡先来简单了解一下什么是负载均衡，单从字面上的意思来理解就可以解</p><p>负载均衡是我们大流量网站要做的一个东西，下面我来给大家介绍在Nginx服务器上进行负载均衡配置方法，希望对有需要的同学有所帮助哦。<br>负载均衡</p><p>先来简单了解一下什么是负载均衡，单从字面上的意思来理解就可以解释N台服务器平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。那么负载均衡的前提就是要有多台服务器才能实现，也就是两台以上即可。<br><a id="more"></a><br>测试环境<br>由于没有服务器，所以本次测试直接host指定域名，然后在VMware里安装了三台CentOS。</p><pre><code>测试域名  ：a.comA服务器IP ：192.168.5.149 （主）B服务器IP ：192.168.5.27C服务器IP ：192.168.5.126</code></pre><p>部署思路<br>A服务器做为主服务器，域名直接解析到A服务器（192.168.5.149）上，由A服务器负载均衡到B服务器（192.168.5.27）与C服务器（192.168.5.126）上。</p><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>由于不是真实环境，域名就随便使用一个a.com用作测试，所以a.com的解析只能在hosts文件设置。</p><p>打开：C:WindowsSystem32driversetchosts</p><p>在末尾添加</p><p>192.168.5.149    a.com</p><p>保存退出，然后启动命令模式ping下看看是否已设置成功</p><p>从截图上看已成功将a.com解析到192.168.5.149IP</p><p>A服务器nginx.conf设置<br>打开nginx.conf，文件位置在nginx安装目录的conf目录下。</p><p>在http段加入以下代码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream a.com &#123; </span><br><span class="line">      server  <span class="number">192.168</span><span class="number">.5</span><span class="number">.126</span>:<span class="number">80</span>; </span><br><span class="line">      server  <span class="number">192.168</span><span class="number">.5</span><span class="number">.27</span>:<span class="number">80</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">server&#123; </span><br><span class="line">    listen <span class="number">80</span>; </span><br><span class="line">    server_name a.com; </span><br><span class="line">    location / &#123; </span><br><span class="line">        proxy_pass         <span class="string">http:</span><span class="comment">//a.com; </span></span><br><span class="line">        proxy_set_header   Host             $host; </span><br><span class="line">        proxy_set_header   X-Real-IP        $remote_addr; </span><br><span class="line">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存重启nginx</p><p>B、C服务器nginx.conf设置<br>打开nginx.confi，在http段加入以下代码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123; </span><br><span class="line">    listen <span class="number">80</span>; </span><br><span class="line">    server_name a.com; </span><br><span class="line">    index index.html; </span><br><span class="line">    root <span class="regexp">/data0/</span>htdocs/www; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存重启nginx</p><p>测试<br>当访问a.com的时候，为了区分是转向哪台服务器处理我分别在B、C服务器下写一个不同内容的index.html文件，以作区分。</p><p>打开浏览器访问a.com结果，刷新会发现所有的请求均分别被主服务器（192.168.5.149）分配到B服务器（192.168.5.27）与C服务器（192.168.5.126）上，实现了负载均衡效果。</p><p>假如其中一台服务器宕机会怎样？<br>当某台服务器宕机了，是否会影响访问呢？</p><p>我们先来看看实例，根据以上例子，假设C服务器192.168.5.126这台机子宕机了（由于无法模拟宕机，所以我就把C服务器关机）然后再来访问看看。</p><p>访问结果：</p><p>我们发现，虽然C服务器（192.168.5.126）宕机了，但不影响网站访问。这样，就不会担心在负载均衡模式下因为某台机子宕机而拖累整个站点了。</p><p>如果b.com也要设置负载均衡怎么办？<br>很简单，跟a.com设置一样。如下：</p><p>假设b.com的主服务器IP是192.168.5.149，负载均衡到192.168.5.150和192.168.5.151机器上</p><p>现将域名b.com解析到192.168.5.149IP上。</p><p>在主服务器(192.168.5.149)的nginx.conf加入以下代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">upstream b.com &#123; </span><br><span class="line">      server  <span class="number">192.168</span><span class="number">.5</span><span class="number">.150</span>:<span class="number">80</span>; </span><br><span class="line">      server  <span class="number">192.168</span><span class="number">.5</span><span class="number">.151</span>:<span class="number">80</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">server&#123; </span><br><span class="line">    listen <span class="number">80</span>; </span><br><span class="line">    server_name b.com; </span><br><span class="line">    location / &#123; </span><br><span class="line">        proxy_pass         <span class="string">http:</span><span class="comment">//b.com; </span></span><br><span class="line">        proxy_set_header   Host             $host; </span><br><span class="line">        proxy_set_header   X-Real-IP        $remote_addr; </span><br><span class="line">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">保存重启nginx</span><br><span class="line"></span><br><span class="line">在<span class="number">192.168</span><span class="number">.5</span><span class="number">.150</span>与<span class="number">192.168</span><span class="number">.5</span><span class="number">.151</span>机器上设置nginx，打开nginx.conf在末尾添加以下代码：</span><br><span class="line"></span><br><span class="line">server&#123; </span><br><span class="line">    listen <span class="number">80</span>; </span><br><span class="line">    server_name b.com; </span><br><span class="line">    index index.html; </span><br><span class="line">    root <span class="regexp">/data0/</span>htdocs/www; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存重启nginx</p><p>完成以后步骤后即可实现b.com的负载均衡配置。</p><h4 id="主服务器不能提供服务吗？"><a href="#主服务器不能提供服务吗？" class="headerlink" title="主服务器不能提供服务吗？"></a>主服务器不能提供服务吗？</h4><p>以上例子中，我们都是应用到了主服务器负载均衡到其它服务器上，那么主服务器本身能不能也加在服务器列表中，这样就不会白白浪费拿一台服务器纯当做转发功能，而是也参与到提供服务中来。</p><p>如以上案例三台服务器：</p><p>A服务器IP ：192.168.5.149 （主）</p><p>B服务器IP ：192.168.5.27</p><p>C服务器IP ：192.168.5.126</p><p>我们把域名解析到A服务器，然后由A服务器转发到B服务器与C服务器，那么A服务器只做一个转发功能，现在我们让A服务器也提供站点服务。</p><p>我们先来分析一下，如果添加主服务器到upstream中，那么可能会有以下两种情况发生：</p><p>1、主服务器转发到了其它IP上，其它IP服务器正常处理；</p><p>2、主服务器转发到了自己IP上，然后又进到主服务器分配IP那里，假如一直分配到本机，则会造成一个死循环。</p><p>怎么解决这个问题呢？因为80端口已经用来监听负载均衡的处理，那么本服务器上就不能再使用80端口来处理a.com的访问请求，得用一个新的。于是我们把主服务器的nginx.conf加入以下一段代码：</p><pre><code>server{     listen 8080;     server_name a.com;     index index.html;     root /data0/htdocs/www; }</code></pre><p>重启nginx，在浏览器输入a.com:8080试试看能不能访问。结果可以正常访问</p><p>既然能正常访问，那么我们就可以把主服务器添加到upstream中，但是端口要改一下，如下代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream a.com &#123; </span><br><span class="line">      server  <span class="number">192.168</span><span class="number">.5</span><span class="number">.126</span>:<span class="number">80</span>; </span><br><span class="line">      server  <span class="number">192.168</span><span class="number">.5</span><span class="number">.27</span>:<span class="number">80</span>; </span><br><span class="line">      server  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这里可以添加主服务器IP192.168.5.149或者127.0.0.1均可以，都表示访问自己。</p><p>重启Nginx，然后再来访问a.com看看会不会分配到主服务器上。</p><p>主服务器也能正常加入服务了。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>一、负载均衡不是nginx独有，著名鼎鼎的apache也有，但性能可能不如nginx。</p><p>二、多台服务器提供服务，但域名只解析到主服务器，而真正的服务器IP不会被ping下即可获得，增加一定安全性。</p><p>三、upstream里的IP不一定是内网，外网IP也可以。不过经典的案例是，局域网中某台IP暴露在外网下，域名直接解析到此IP。然后又这台主服务器转发到内网服务器IP中。</p><p>四、某台服务器宕机、不会影响网站正常运行，Nginx不会把请求转发到已宕机的IP上</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Nginx负载均衡配置实例详解&quot;&gt;&lt;a href=&quot;#Nginx负载均衡配置实例详解&quot; class=&quot;headerlink&quot; title=&quot;Nginx负载均衡配置实例详解&quot;&gt;&lt;/a&gt;Nginx负载均衡配置实例详解&lt;/h3&gt;&lt;p&gt;[导读] 负载均衡是我们大流量网站要做的一个东西，下面我来给大家介绍在Nginx服务器上进行负载均衡配置方法，希望对有需要的同学有所帮助哦。负载均衡先来简单了解一下什么是负载均衡，单从字面上的意思来理解就可以解&lt;/p&gt;
&lt;p&gt;负载均衡是我们大流量网站要做的一个东西，下面我来给大家介绍在Nginx服务器上进行负载均衡配置方法，希望对有需要的同学有所帮助哦。&lt;br&gt;负载均衡&lt;/p&gt;
&lt;p&gt;先来简单了解一下什么是负载均衡，单从字面上的意思来理解就可以解释N台服务器平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。那么负载均衡的前提就是要有多台服务器才能实现，也就是两台以上即可。&lt;br&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://ciweigg.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://ciweigg.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx反向代理JAVA获取真实IP</title>
    <link href="https://ciweigg.github.io/2018/01/29/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86JAVA%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9EIP/"/>
    <id>https://ciweigg.github.io/2018/01/29/Nginx反向代理JAVA获取真实IP/</id>
    <published>2018-01-29T08:47:15.000Z</published>
    <updated>2018-02-02T08:42:06.546Z</updated>
    
    <content type="html"><![CDATA[<h3 id="获取客户端真实的IP地址"><a href="#获取客户端真实的IP地址" class="headerlink" title="获取客户端真实的IP地址"></a>获取客户端真实的IP地址</h3><a id="more"></a><pre><code>/** * 获取用户ip * @param request * @return */public static String getIpAddress(HttpServletRequest request) {    String ip = request.getHeader(&quot;X-requested-For&quot;);    if (StringUtils.isBlank(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {        ip = request.getHeader(&quot;X-Forwarded-For&quot;);    }    if (StringUtils.isBlank(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {        ip = request.getHeader(&quot;Proxy-Client-IP&quot;);    }    if (StringUtils.isBlank(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {        ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);    }    if (StringUtils.isBlank(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {        ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);    }    if (StringUtils.isBlank(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {        ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);    }    if (StringUtils.isBlank(ip) || &quot;unknown&quot;.equalsIgnoreCase(ip)) {        ip = request.getRemoteAddr();    }    // 如果是多级代理，那么取第一个ip为客户ip    if (ip != null &amp;&amp; ip.indexOf(&quot;,&quot;) != -1)    {        ip = ip.substring(ip.lastIndexOf(&quot;,&quot;) + 1, ip.length()).trim();    }    return ip;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;获取客户端真实的IP地址&quot;&gt;&lt;a href=&quot;#获取客户端真实的IP地址&quot; class=&quot;headerlink&quot; title=&quot;获取客户端真实的IP地址&quot;&gt;&lt;/a&gt;获取客户端真实的IP地址&lt;/h3&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://ciweigg.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://ciweigg.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Mysql优化建议</title>
    <link href="https://ciweigg.github.io/2018/01/29/Mysql%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/"/>
    <id>https://ciweigg.github.io/2018/01/29/Mysql优化建议/</id>
    <published>2018-01-29T08:45:49.000Z</published>
    <updated>2018-01-29T10:00:24.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="提高mysql千万级大数据SQL查询优化30条经验（Mysql索引优化注意）"><a href="#提高mysql千万级大数据SQL查询优化30条经验（Mysql索引优化注意）" class="headerlink" title="提高mysql千万级大数据SQL查询优化30条经验（Mysql索引优化注意）"></a>提高mysql千万级大数据SQL查询优化30条经验（Mysql索引优化注意）</h3><p>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0<br><a id="more"></a><br>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p><p>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num=10 or num=20可以这样查询：select id from t where num=10 union all select id from t where num=20</p><p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3</p><p>6.下面的查询也将导致全表扫描：select id from t where name like ‘李%’若要提高效率，可以考虑全文检索。</p><p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：select id from t where num=@num可以改为强制查询使用索引：select id from t with(index(索引名)) where num=@num<br>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where num/2=100应改为:select id from t where num=100*2</p><p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where substring(name,1,3)=’abc’ ，name以abc开头的id</p><p>应改为:</p><p>select id from t where name like ‘abc%’</p><p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p>11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><p>12.不要写一些没有意义的查询，如需要生成一个空表结构：select col1,col2 into #t from t where 1=0</p><p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p><p>create table #t(…)</p><p>13.很多时候用 exists 代替 in 是一个好的选择：select num from a where num in(select num from b)</p><p>用下面的语句替换：</p><p>select num from a where exists(select 1 from b where num=a.num)</p><p>14.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p><p>索引并不是越多越好，索引固然可 以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p><p>应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><p>17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>19.任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段。</p><p>20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>21.避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p><p>23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p><p>24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><p>25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p><p>26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p><p>与临时表一样，游标并不是不可使 用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。<br>28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC 消息。</p><p>29.尽量避免大事务操作，提高系统并发能力。</p><p>30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;提高mysql千万级大数据SQL查询优化30条经验（Mysql索引优化注意）&quot;&gt;&lt;a href=&quot;#提高mysql千万级大数据SQL查询优化30条经验（Mysql索引优化注意）&quot; class=&quot;headerlink&quot; title=&quot;提高mysql千万级大数据SQL查询优化30条经验（Mysql索引优化注意）&quot;&gt;&lt;/a&gt;提高mysql千万级大数据SQL查询优化30条经验（Mysql索引优化注意）&lt;/h3&gt;&lt;p&gt;1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。&lt;/p&gt;
&lt;p&gt;2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0&lt;br&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://ciweigg.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://ciweigg.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 的安装与详细使用（一）</title>
    <link href="https://ciweigg.github.io/2018/01/26/MongoDB%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://ciweigg.github.io/2018/01/26/MongoDB 的安装与详细使用（一）/</id>
    <published>2018-01-26T05:35:06.000Z</published>
    <updated>2018-01-26T05:41:16.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是MongoDB"><a href="#一、什么是MongoDB" class="headerlink" title="一、什么是MongoDB ?"></a>一、什么是MongoDB ?</h1><p>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。</p><p>在高负载的情况下，添加更多的节点，可以保证服务器性能。</p><p>MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。</p><p>MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。<br><a id="more"></a><br><img src="http://oisa91ton.bkt.clouddn.com/151694512210854qcloas.png?imageslim" alt="paste image"></p><h1 id="二、MongoDB-优缺点"><a href="#二、MongoDB-优缺点" class="headerlink" title="二、MongoDB 优缺点"></a>二、MongoDB 优缺点</h1><p><strong>优点</strong></p><ul><li>文档结构的存储方式，能够更便捷的获取数据</li><li>内置GridFS，支持大容量的存储</li><li>海量数据下，性能优越</li><li>动态查询</li><li>全索引支持,扩展到内部对象和内嵌数组</li><li>查询记录分析</li><li>快速,就地更新</li><li>高效存储二进制大对象 (比如照片和视频)</li><li>复制（复制集）和支持自动故障恢复</li><li>内置 Auto- Sharding 自动分片支持云级扩展性，分片简单</li><li>MapReduce 支持复杂聚合</li><li>商业支持,培训和咨询</li></ul><p><strong>缺点</strong></p><ul><li>不支持事务操作</li><li>MongoDB 占用空间过大 （不过这个确定对于目前快速下跌的硬盘价格来说，也不算什么缺点了）</li><li>MongoDB没有如MySQL那样成熟的维护工具</li><li>无法进行关联表查询，不适用于关系多的数据</li><li>复杂聚合操作通过mapreduce创建，速度慢</li><li>模式自由,自由灵活的文件存储格式带来的数据错</li><li>MongoDB 在你删除记录后不会在文件系统回收空间。除非你删掉数据库。但是空间没有被浪费</li></ul><h1 id="三、优缺点详细解释"><a href="#三、优缺点详细解释" class="headerlink" title="三、优缺点详细解释"></a>三、优缺点详细解释</h1><p><strong>1.内置GridFS，支持大容量的存储：</strong></p><p>GridFS是一个出色的分布式文件系统，可以支持海量的数据存储。<br>内置了GridFS了MongoDB，能够满足对大数据集的快速范围查询。</p><p><strong>2.内置 Auto- Sharding 自动分片支持云级扩展性，分片简单</strong></p><p>提供基于Range的Auto Sharding机制：</p><p>一个collection可按照记录的范围，分成若干个段，切分到不同的Shard上。</p><p>Shards可以和复制结合，配合Replica sets能够实现Sharding+fail-over，不同的Shard之间可以负载均衡。<br>查询是对客户端是透明的。客户端执行查询，统计，MapReduce等操作，这些会被MongoDB自动路由到后端的数据节点。<br>这让我们关注于自己的业务，适当的 时候可以无痛的升级。MongoDB的Sharding设计能力最大可支持约20 petabytes，足以支撑一般应用。<br>这可以保证MongoDB运行在便宜的PC服务器集群上。PC集群扩充起来非常方便并且成本很低，避免了“sharding”操作的复杂性和成本。  </p><p><strong>3.海量数据下，性能优越：</strong></p><p>在使用场合下，千万级别的文档对象，近10G的数据，对有索引的ID的查询不会比mysql慢，而对非索引字段的查询，则是全面胜出。 mysql实际无法胜任大数据量下任意字段的查询，而mongodb的查询性能实在让我惊讶。写入性能同样很令人满意，同样写入百万级别的数 据，mongodb比我以前试用过的couchdb要快得多，基本10分钟以下可以解决。补上一句，观察过程中mongodb都远算不上是CPU杀手。</p><p><strong>4.全索引支持,扩展到内部对象和内嵌数组</strong></p><p>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。</p><p>这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p><p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构。</p><p><strong>5.MapReduce 支持复杂聚合</strong></p><p>MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。</p><p><strong>与关系型数据库相比，MongoDB的缺点：</strong></p><p><strong>mongodb不支持事务操作：</strong></p><p>所以事务要求严格的系统（如果银行系统）肯定不能用它。</p><p><strong>mongodb不支持事务操作：</strong></p><p>所以事务要求严格的系统（如果银行系统）肯定不能用它。</p><p><strong>mongodb占用空间过大：</strong></p><p>关于其原因，在官方的FAQ中，提到有如下几个方面：</p><p>1、空间的预分配：为避免形成过多的硬盘碎片，mongodb每次空间不足时都会申请生成一大块的硬盘空间，而且申请的量从64M、128M、256M那 样的指数递增，直到2G为单个文件的最大体积。随着数据量的增加，你可以在其数据目录里看到这些整块生成容量不断递增的文件。</p><p>2、字段名所占用的空间：为了保持每个记录内的结构信息用于查询，mongodb需要把每个字段的key-value都以BSON的形式存储，如果 value域相对于key域并不大，比如存放数值型的数据，则数据的overhead是最大的。一种减少空间占用的方法是把字段名尽量取短一些，这样占用 空间就小了，但这就要求在易读性与空间占用上作为权衡了。</p><p>3、删除记录不释放空间：这很容易理解，为避免记录删除后的数据的大规模挪动，原记录空间不删除，只标记“已删除”即可，以后还可以重复利用。</p><p>4、可以定期运行db.repairDatabase()来整理记录，但这个过程会比较缓慢</p><p>MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方。</p><h1 id="四、安装与使用"><a href="#四、安装与使用" class="headerlink" title="四、安装与使用"></a>四、安装与使用</h1><p>MongoDB 3.6不支持Ubuntu 12.04</p><p>本文使用：Ubuntu 16.04 x64</p><p>安装MongoDB的企业版</p><h2 id="1-导入公钥"><a href="#1-导入公钥" class="headerlink" title="1. 导入公钥"></a>1. 导入公钥</h2><p>导入包管理系统使用的公钥。</p><p>Ubuntu软件包管理工具（即dpkg和apt）通过要求分发者使用GPG密钥签署软件包来确保软件包的一致性和真实性，使用以下命令导入。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5</span><br></pre></td></tr></table></figure><h2 id="2-创建列表文件"><a href="#2-创建列表文件" class="headerlink" title="2. 创建列表文件"></a>2. 创建列表文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"deb [ arch=amd64,arm64,ppc64el,s390x ] http://repo.mongodb.com/apt/ubuntu xenial/mongodb-enterprise/3.6 multiverse"</span> | sudo tee /etc/apt/sources.list.d/mongodb-enterprise.list</span><br></pre></td></tr></table></figure><h2 id="3-更新仓库"><a href="#3-更新仓库" class="headerlink" title="3. 更新仓库"></a>3. 更新仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> apt-get update</span><br></pre></td></tr></table></figure><h2 id="4-安装服务"><a href="#4-安装服务" class="headerlink" title="4. 安装服务"></a>4. 安装服务</h2><p><strong>安装MongoDB Enterprise软件包</strong></p><p>安装MongoDB企业版本3.6</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y mongodb-enterprise</span><br></pre></td></tr></table></figure><p><strong>指定 3.6.2 版本安装 MongoDB Enterprise</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y mongodb-org=3.6.2 mongodb-org-server=3.6.2 mongodb-org-shell=3.6.2 mongodb-org-mongos=3.6.2 mongodb-org-tools=3.6.2</span><br></pre></td></tr></table></figure><h2 id="5-启动服务"><a href="#5-启动服务" class="headerlink" title="5. 启动服务"></a>5. 启动服务</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mongod start</span><br></pre></td></tr></table></figure><h2 id="6-查看日志"><a href="#6-查看日志" class="headerlink" title="6. 查看日志"></a>6. 查看日志</h2><p>确认<code>MongoDB</code>已经成功启动，查看<code>/var/log/mongodb/mongod.log</code> 日志</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less /var/<span class="built_in">log</span>/mongodb/mongod.log</span><br></pre></td></tr></table></figure><p>验证 mongod 已成功启动，通过检查日志文件的内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[initandlisten] waiting <span class="keyword">for</span> connections on port 27017</span><br></pre></td></tr></table></figure><p><code>&lt;port&gt;</code>是<code>mongod</code>监听的端口。如果您修改了 配置文件中的<code>net.port</code>设置<code>/etc/mongod.conf</code>，端口可能会有所不同。</p><p>您可能会在<code>mongod</code> 输出中看到非严重警告。只要你看到上面显示的日志行，你可以放心地忽略这些警告。</p><h1 id="四、MongoDB-使用"><a href="#四、MongoDB-使用" class="headerlink" title="四、MongoDB 使用"></a>四、MongoDB 使用</h1><h2 id="1-连接-MongoDB"><a href="#1-连接-MongoDB" class="headerlink" title="1. 连接 MongoDB"></a>1. 连接 MongoDB</h2><p>mongo在同一台主机上启动一个<code>shell mongod</code>。使用<code>--host</code>命令行选项指定<code>mongod</code> 监听的本地主机地址和端口：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --host 127.0.0.1:27017</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MongoDB shell version v3.6.2</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/</span><br><span class="line">MongoDB server version: 3.6.2</span><br><span class="line">Server has startup warnings: </span><br><span class="line">2018-01-25T12:42:31.472+0000 I STORAGE  [initandlisten] </span><br><span class="line">2018-01-25T12:42:31.473+0000 I STORAGE  [initandlisten] ** WARNING: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine</span><br><span class="line">2018-01-25T12:42:31.473+0000 I STORAGE  [initandlisten] **          See http://dochub.mongodb.org/core/prodnotes-filesystem</span><br><span class="line">2018-01-25T12:42:31.510+0000 I CONTROL  [initandlisten] </span><br><span class="line">2018-01-25T12:42:31.510+0000 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled <span class="keyword">for</span> the database.</span><br><span class="line">2018-01-25T12:42:31.510+0000 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.</span><br><span class="line">2018-01-25T12:42:31.510+0000 I CONTROL  [initandlisten] </span><br><span class="line">2018-01-25T12:42:31.511+0000 I CONTROL  [initandlisten] </span><br><span class="line">2018-01-25T12:42:31.511+0000 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is <span class="string">'always'</span>.</span><br><span class="line">2018-01-25T12:42:31.511+0000 I CONTROL  [initandlisten] **        We suggest setting it to <span class="string">'never'</span></span><br><span class="line">2018-01-25T12:42:31.511+0000 I CONTROL  [initandlisten] </span><br><span class="line">2018-01-25T12:42:31.511+0000 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is <span class="string">'always'</span>.</span><br><span class="line">2018-01-25T12:42:31.511+0000 I CONTROL  [initandlisten] **        We suggest setting it to <span class="string">'never'</span></span><br><span class="line">2018-01-25T12:42:31.511+0000 I CONTROL  [initandlisten] </span><br><span class="line">&gt; 1+1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>上面简单测试了：1+1</p><p><strong>退出：Ctrl+c</strong></p><h2 id="2-MongoDB-创建数据库"><a href="#2-MongoDB-创建数据库" class="headerlink" title="2. MongoDB 创建数据库"></a>2. MongoDB 创建数据库</h2><p>语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use DATABASE_NAME</span><br></pre></td></tr></table></figure><p>创建一个 <code>souyunku</code> 的数据库，使用 <code>db</code> 命令查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; use souyunku</span><br><span class="line">switched to db souyunku</span><br><span class="line">&gt; db</span><br><span class="line">souyunku</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>查看所有数据库使用<code>show dbs</code> </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line"><span class="built_in">local</span>   0.000GB</span><br><span class="line"><span class="built_in">test</span>    0.000GB</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>可以看到，刚创建的数据库 <code>souyunku</code> 并不在数据库的列表中， 要显示它，我们需要向 souyunku 数据库插入一些数据。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.souyunku.insert(&#123;<span class="string">"name"</span>:<span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : 1 &#125;)</span><br><span class="line">&gt; show dbs</span><br><span class="line">admin     0.000GB</span><br><span class="line">config    0.000GB</span><br><span class="line"><span class="built_in">local</span>     0.000GB</span><br><span class="line">souyunku  0.000GB</span><br><span class="line"><span class="built_in">test</span>      0.000GB</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><code>MongoDB</code> 中默认的数据库为 <code>test</code>，如果你没有创建新的数据库，集合将存放在 <code>test</code> 数据库中。</p><h2 id="3-MongoDB-删除数据库"><a href="#3-MongoDB-删除数据库" class="headerlink" title="3. MongoDB 删除数据库"></a>3. MongoDB 删除数据库</h2><p><strong><code>MongoDB</code> 删除数据库的语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><p>实例</p><p>以下操作会把<code>souyunku</code> 数据删除</p><p>查看所有数据库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">admin     0.000GB</span><br><span class="line">config    0.000GB</span><br><span class="line"><span class="built_in">local</span>     0.000GB</span><br><span class="line">souyunku  0.000GB</span><br><span class="line"><span class="built_in">test</span>      0.000GB</span><br></pre></td></tr></table></figure><p>切换到<code>souyunku</code> 数据库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; use souyunku</span><br><span class="line">switched to db souyunku</span><br></pre></td></tr></table></figure><p>使用<code>db.dropDatabase()</code> 删除数据库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.dropDatabase()</span><br><span class="line">&#123; <span class="string">"dropped"</span> : <span class="string">"souyunku"</span>, <span class="string">"ok"</span> : 1 &#125;</span><br></pre></td></tr></table></figure><p>看到已经删除了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line"><span class="built_in">local</span>   0.000GB</span><br><span class="line"><span class="built_in">test</span>    0.000GB</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="4-MongoDB-插入文档"><a href="#4-MongoDB-插入文档" class="headerlink" title="4. MongoDB 插入文档"></a>4. MongoDB 插入文档</h2><p><code>MongoDB</code> 使用 <code>insert()</code> 或 <code>save()</code> 方法向集合中插入文档，语法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.insert(document)</span><br></pre></td></tr></table></figure><p>以下文档可以存储在 <code>MongoDB</code> 的 <code>souyunku</code>数据库 的 <code>col</code> 集合中：</p><p>切换到<code>souyunku</code> 数据库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; use souyunku</span><br><span class="line">switched to db souyunku</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.col.insert(&#123;title: <span class="string">'MongoDB 教程'</span>, </span><br><span class="line">    description: <span class="string">'MongoDB 是一个 Nosql 数据库'</span>,</span><br><span class="line">    by: <span class="string">'搜云库教程-专注于开发技术的研究与知识分享'</span>,</span><br><span class="line">    url: <span class="string">'http://www.souyunku.com'</span>,</span><br><span class="line">    tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">    likes: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.find()</span><br></pre></td></tr></table></figure><p>以上实例中 <code>col</code> 是我们的集合名，如果该集合不在该数据库中， <code>MongoDB</code> 会自动创建该集合并插入文档。<br>查看已插入文档：</p><p>响应</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span>: ObjectId(<span class="string">"5a69eb32ec3046ee8ae54dbb"</span>),</span><br><span class="line"><span class="string">"title"</span>: <span class="string">"MongoDB 教程"</span>,</span><br><span class="line"><span class="string">"description"</span>: <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line"><span class="string">"by"</span>: <span class="string">"搜云库教程-专注于开发技术的研究与知识分享"</span>,</span><br><span class="line"><span class="string">"url"</span>: <span class="string">"http://www.souyunku.com"</span>,</span><br><span class="line"><span class="string">"tags"</span>: [<span class="string">"mongodb"</span>, <span class="string">"database"</span>, <span class="string">"NoSQL"</span>],</span><br><span class="line"><span class="string">"likes"</span>: 100</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>我们也可以将数据定义为一个变量，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document=(&#123;title: <span class="string">'MongoDB 教程'</span>, </span><br><span class="line">    description: <span class="string">'MongoDB 是一个 Nosql 数据库'</span>,</span><br><span class="line">    by: <span class="string">'搜云库教程-专注于开发技术的研究与知识分享'</span>,</span><br><span class="line">    url: <span class="string">'http://www.souyunku.com'</span>,</span><br><span class="line">    tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">    likes: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行后显示结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span>,</span><br><span class="line"><span class="string">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line"><span class="string">"by"</span> : <span class="string">"搜云库教程-专注于开发技术的研究与知识分享"</span>,</span><br><span class="line"><span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>,</span><br><span class="line"><span class="string">"tags"</span> : [</span><br><span class="line"><span class="string">"mongodb"</span>,</span><br><span class="line"><span class="string">"database"</span>,</span><br><span class="line"><span class="string">"NoSQL"</span></span><br><span class="line">],</span><br><span class="line"><span class="string">"likes"</span> : 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行插入操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.insert(document)</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : 1 &#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>插入文档你也可以使用 <code>db.col.save(document)</code> 命令。如果不指定 <code>_id</code> 字段 <code>save()</code> 方法类似于 <code>insert()</code> 方法。如果指定 <code>_id</code> 字段，则会更新该 <code>_id</code> 的数据。</p><p><strong>3.2 版本后还有以下几种语法可用于插入文档:</strong></p><p><code>db.collection.insertOne()</code>:向指定集合中插入一条文档数据。</p><p><code>db.collection.insertMany()</code>:向指定集合中插入多条文档数据。</p><p>插入单条数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; var document = db.collection.insertOne(&#123;<span class="string">"title"</span>: <span class="string">"搜云库"</span>&#125;)</span><br><span class="line">&gt; document</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"acknowledged"</span> : <span class="literal">true</span>,</span><br><span class="line"><span class="string">"insertedId"</span> : ObjectId(<span class="string">"5a69f0dfec3046ee8ae54dbe"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&gt; db.collection.find()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a69f0dfec3046ee8ae54dbe"</span>), <span class="string">"title"</span> : <span class="string">"搜云库"</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>插入多条数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; var res = db.collection.insertMany([&#123;<span class="string">"title"</span>: <span class="string">"搜云库"</span>&#125;, &#123;<span class="string">'description'</span>: <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>&#125;])</span><br><span class="line">&gt; res</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"acknowledged"</span> : <span class="literal">true</span>,</span><br><span class="line"><span class="string">"insertedIds"</span> : [</span><br><span class="line">ObjectId(<span class="string">"5a69f188ec3046ee8ae54dbf"</span>),</span><br><span class="line">ObjectId(<span class="string">"5a69f188ec3046ee8ae54dc0"</span>)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&gt; db.collection.find()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a69f0dfec3046ee8ae54dbe"</span>), <span class="string">"title"</span> : <span class="string">"搜云库"</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a69f188ec3046ee8ae54dc0"</span>), <span class="string">"description"</span> : <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="5-MongoDB-删除文档"><a href="#5-MongoDB-删除文档" class="headerlink" title="5. MongoDB 删除文档"></a>5. MongoDB 删除文档</h2><p><code>MongoDB remove()</code>函数是用来移除集合中的数据。</p><p><code>MongoDB</code>数据更新可以使用<code>update()</code>函数。在执行<code>remove()</code>函数前先执行<code>find()</code>命令来判断执行的条件是否正确，这是一个比较好的习惯。</p><p><strong><code>remove()</code> 方法已经过时了，现在官方推荐使用 <code>deleteOne()</code> 和 <code>deleteMany()</code> 方法。</strong></p><p>如删除集合下全部文档：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.deleteMany(&#123;&#125;)</span><br><span class="line">&#123; <span class="string">"acknowledged"</span> : <span class="literal">true</span>, <span class="string">"deletedCount"</span> : 2 &#125;</span><br><span class="line">&gt; db.col.find()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>删除 <code>title</code> 等于 “搜云库” 的全部文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.collection.deleteMany(&#123; title : &quot;搜云库&quot;&#125;)</span><br><span class="line">&#123; &quot;acknowledged&quot; : true, &quot;deletedCount&quot; : 2 &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; db.collection.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5a69f188ec3046ee8ae54dc0&quot;), &quot;description&quot; : &quot;关注公众号，搜云库，专注于开发技术的研究与知识分享&quot; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>删除 <code>weixin</code> 等于 “souyunku” 的一个文档：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.insert(&#123;weixin:<span class="string">"souyunku"</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : 1 &#125;)</span><br><span class="line">&gt; db.col.find()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a69f5a0ec3046ee8ae54dc1"</span>), <span class="string">"weixin"</span> : <span class="string">"souyunku"</span> &#125;</span><br><span class="line">&gt; db.col.deleteOne(&#123;weixin:<span class="string">"souyunku"</span>&#125;)</span><br><span class="line">&#123; <span class="string">"acknowledged"</span> : <span class="literal">true</span>, <span class="string">"deletedCount"</span> : 1 &#125;</span><br><span class="line">&gt; db.col.find()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="6-MongoDB-查询文档"><a href="#6-MongoDB-查询文档" class="headerlink" title="6. MongoDB 查询文档"></a>6. MongoDB 查询文档</h2><p><code>MongoDB</code> 查询文档使用 <code>find()</code> 方法。</p><p><code>find()</code> 方法以非结构化的方式来显示所有文档。</p><p>语法</p><p>MongoDB 查询数据的语法格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.collection.find(query, projection)</span><br></pre></td></tr></table></figure><ul><li><code>query</code> ：可选，使用查询操作符指定查询条件</li><li><code>projection</code> ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</li></ul><p>pretty() 方法以格式化的方式来显示所有文档。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.col.insert(&#123;title: <span class="string">'MongoDB 教程'</span>, </span><br><span class="line">    description: <span class="string">'MongoDB 是一个 Nosql 数据库'</span>,</span><br><span class="line">    by: <span class="string">'搜云库教程-专注于开发技术的研究与知识分享'</span>,</span><br><span class="line">    url: <span class="string">'http://www.souyunku.com'</span>,</span><br><span class="line">    tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">    likes: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.find().pretty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"5a69f93598891b4abe9cc8cb"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span>,</span><br><span class="line"><span class="string">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line"><span class="string">"by"</span> : <span class="string">"搜云库教程-专注于开发技术的研究与知识分享"</span>,</span><br><span class="line"><span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>,</span><br><span class="line"><span class="string">"tags"</span> : [</span><br><span class="line"><span class="string">"mongodb"</span>,</span><br><span class="line"><span class="string">"database"</span>,</span><br><span class="line"><span class="string">"NoSQL"</span></span><br><span class="line">],</span><br><span class="line"><span class="string">"likes"</span> : 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MongoDB 与 RDBMS Where 语句比较</strong></p><p><img src="http://oisa91ton.bkt.clouddn.com/1516945200213ih4iyhp0.png?imageslim" alt="paste image"></p><h3 id="6-1-MongoDB-AND-条件"><a href="#6-1-MongoDB-AND-条件" class="headerlink" title="6.1 MongoDB AND 条件"></a>6.1 MongoDB AND 条件</h3><p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件。</p><p>语法格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br></pre></td></tr></table></figure><p>实例</p><p>以下实例通过 <code>by</code> 和 <code>title</code> 键来查询 数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.find(&#123;<span class="string">"by"</span>:<span class="string">"搜云库教程-专注于开发技术的研究与知识分享"</span>, <span class="string">"title"</span>:<span class="string">"MongoDB 教程"</span>&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"5a69f93598891b4abe9cc8cb"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span>,</span><br><span class="line"><span class="string">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line"><span class="string">"by"</span> : <span class="string">"搜云库教程-专注于开发技术的研究与知识分享"</span>,</span><br><span class="line"><span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>,</span><br><span class="line"><span class="string">"tags"</span> : [</span><br><span class="line"><span class="string">"mongodb"</span>,</span><br><span class="line"><span class="string">"database"</span>,</span><br><span class="line"><span class="string">"NoSQL"</span></span><br><span class="line">],</span><br><span class="line"><span class="string">"likes"</span> : 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例中类似于 WHERE 语句：WHERE by=’搜云库教程-专注于开发技术的研究与知识分享’ AND title=’MongoDB 教程’</p><h3 id="6-2-MongoDB-OR-条件"><a href="#6-2-MongoDB-OR-条件" class="headerlink" title="6.2 MongoDB OR 条件"></a>6.2 MongoDB OR 条件</h3><p>MongoDB OR 条件语句使用了关键字 $or,语法格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.col.find(</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="variable">$or</span>: [</span><br><span class="line">         &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty</span><br></pre></td></tr></table></figure><p>实例</p><p>以下实例中，我们演示了查询键 <strong>by</strong> 值为 “搜云库教程-专注于开发技术的研究与知识分享” 或键 <strong>title</strong> 值为 <strong>MongoDB 教程</strong> 的文档。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.find(&#123;<span class="variable">$or</span>:[&#123;<span class="string">"by"</span>:<span class="string">"搜云库教程-专注于开发技术的研究与知识分享"</span>&#125;,&#123;<span class="string">"title"</span>: <span class="string">"MongoDB 教程"</span>&#125;]&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"5a69f93598891b4abe9cc8cb"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span>,</span><br><span class="line"><span class="string">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line"><span class="string">"by"</span> : <span class="string">"搜云库教程-专注于开发技术的研究与知识分享"</span>,</span><br><span class="line"><span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>,</span><br><span class="line"><span class="string">"tags"</span> : [</span><br><span class="line"><span class="string">"mongodb"</span>,</span><br><span class="line"><span class="string">"database"</span>,</span><br><span class="line"><span class="string">"NoSQL"</span></span><br><span class="line">],</span><br><span class="line"><span class="string">"likes"</span> : 100</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h3 id="6-3-AND-和-OR-联合使用"><a href="#6-3-AND-和-OR-联合使用" class="headerlink" title="6.3 AND 和 OR 联合使用"></a>6.3 AND 和 OR 联合使用</h3><p>以下实例演示了 <code>AND</code> 和 <code>OR</code> 联合使用，类似常规 <code>SQL</code> 语句为： <code>&#39;where likes&gt;50 AND (by = &#39;搜云库教程-专注于开发技术的研究与知识分享&#39; OR title = &#39;MongoDB 教程&#39;)&#39;</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.find(&#123;<span class="string">"likes"</span>: &#123;<span class="variable">$gt</span>:50&#125;, <span class="variable">$or</span>: [&#123;<span class="string">"by"</span>: <span class="string">"搜云库教程-专注于开发技术的研究与知识分享"</span>&#125;,&#123;<span class="string">"title"</span>: <span class="string">"MongoDB 教程"</span>&#125;]&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"5a69f93598891b4abe9cc8cb"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span>,</span><br><span class="line"><span class="string">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line"><span class="string">"by"</span> : <span class="string">"搜云库教程-专注于开发技术的研究与知识分享"</span>,</span><br><span class="line"><span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>,</span><br><span class="line"><span class="string">"tags"</span> : [</span><br><span class="line"><span class="string">"mongodb"</span>,</span><br><span class="line"><span class="string">"database"</span>,</span><br><span class="line"><span class="string">"NoSQL"</span></span><br><span class="line">],</span><br><span class="line"><span class="string">"likes"</span> : 100</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="7-MongoDB-条件操作符"><a href="#7-MongoDB-条件操作符" class="headerlink" title="7. MongoDB 条件操作符"></a>7. MongoDB 条件操作符</h2><p>条件操作符用于比较两个表达式并从<code>MongoDB</code>集合中获取数据。</p><p><code>MongoDB</code>中条件操作符有：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&gt;) 大于 - <span class="variable">$gt</span></span><br><span class="line">(&lt;) 小于 - <span class="variable">$lt</span></span><br><span class="line">(&gt;=) 大于等于 - <span class="variable">$gte</span></span><br><span class="line">(&lt;= ) 小于等于 - <span class="variable">$lte</span></span><br></pre></td></tr></table></figure><p>清空集合数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.remove(&#123;&#125;)</span><br></pre></td></tr></table></figure><p>插入以下数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.insert(&#123;</span><br><span class="line">    title: <span class="string">'测试数据200'</span>, </span><br><span class="line">    description: <span class="string">'关注公众号，搜云库，专注于开发技术的研究与知识分享'</span>,</span><br><span class="line">    by: <span class="string">'搜云库'</span>,</span><br><span class="line">    url: <span class="string">'http://www.souyunku.com'</span>,</span><br><span class="line">    tags: [<span class="string">'test'</span>],</span><br><span class="line">    likes: 200</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.insert(&#123;</span><br><span class="line">title: <span class="string">'测试数据150'</span>, </span><br><span class="line">    description: <span class="string">'关注公众号，搜云库，专注于开发技术的研究与知识分享'</span>,</span><br><span class="line">    by: <span class="string">'搜云库'</span>,</span><br><span class="line">    url: <span class="string">'http://www.souyunku.com'</span>,</span><br><span class="line">    tags: [<span class="string">'test'</span>],</span><br><span class="line">    likes: 150</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.insert(&#123;</span><br><span class="line">title: <span class="string">'测试数据100'</span>, </span><br><span class="line">    description: <span class="string">'关注公众号，搜云库，专注于开发技术的研究与知识分享'</span>,</span><br><span class="line">    by: <span class="string">'搜云库'</span>,</span><br><span class="line">    url: <span class="string">'http://www.souyunku.com'</span>,</span><br><span class="line">    tags: [<span class="string">'test'</span>],</span><br><span class="line">    likes: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用find()命令查看数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.find()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a6a083598891b4abe9cc8cc"</span>), <span class="string">"title"</span> : <span class="string">"测试数据200"</span>, <span class="string">"description"</span> : <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>, <span class="string">"by"</span> : <span class="string">"搜云库"</span>, <span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>, <span class="string">"tags"</span> : [ <span class="string">"test"</span> ], <span class="string">"likes"</span> : 200 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a6a083e98891b4abe9cc8cd"</span>), <span class="string">"title"</span> : <span class="string">"测试数据150"</span>, <span class="string">"description"</span> : <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>, <span class="string">"by"</span> : <span class="string">"搜云库"</span>, <span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>, <span class="string">"tags"</span> : [ <span class="string">"test"</span> ], <span class="string">"likes"</span> : 150 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a6a084498891b4abe9cc8ce"</span>), <span class="string">"title"</span> : <span class="string">"测试数据100"</span>, <span class="string">"description"</span> : <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>, <span class="string">"by"</span> : <span class="string">"搜云库"</span>, <span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>, <span class="string">"tags"</span> : [ <span class="string">"test"</span> ], <span class="string">"likes"</span> : 100 &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h3 id="7-1-MongoDB-gt-大于操作符-gt"><a href="#7-1-MongoDB-gt-大于操作符-gt" class="headerlink" title="7.1 MongoDB (&gt;) 大于操作符 - $gt"></a>7.1 MongoDB (&gt;) 大于操作符 - $gt</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;<span class="string">"likes"</span> : &#123;<span class="variable">$gt</span> : 100&#125;&#125;)</span><br></pre></td></tr></table></figure><p>类似于SQL语句：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from col <span class="built_in">where</span> likes &gt; 100;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a6a083598891b4abe9cc8cc"</span>), <span class="string">"title"</span> : <span class="string">"测试数据200"</span>, <span class="string">"description"</span> : <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>, <span class="string">"by"</span> : <span class="string">"搜云库"</span>, <span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>, <span class="string">"tags"</span> : [ <span class="string">"test"</span> ], <span class="string">"likes"</span> : 200 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a6a083e98891b4abe9cc8cd"</span>), <span class="string">"title"</span> : <span class="string">"测试数据150"</span>, <span class="string">"description"</span> : <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>, <span class="string">"by"</span> : <span class="string">"搜云库"</span>, <span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>, <span class="string">"tags"</span> : [ <span class="string">"test"</span> ], <span class="string">"likes"</span> : 150 &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h3 id="7-2-MongoDB（-gt-）大于等于操作符-gte"><a href="#7-2-MongoDB（-gt-）大于等于操作符-gte" class="headerlink" title="7.2 MongoDB（&gt;=）大于等于操作符 - $gte"></a>7.2 MongoDB（&gt;=）大于等于操作符 - $gte</h3><p>如果你想获取”col”集合中 “likes” 大于等于 100 的数据，你可以使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;likes : &#123;<span class="variable">$gte</span> : 100&#125;&#125;)</span><br></pre></td></tr></table></figure><p>类似于SQL语句：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from col <span class="built_in">where</span> likes &gt;=100;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a6a083598891b4abe9cc8cc"</span>), <span class="string">"title"</span> : <span class="string">"测试数据200"</span>, <span class="string">"description"</span> : <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>, <span class="string">"by"</span> : <span class="string">"搜云库"</span>, <span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>, <span class="string">"tags"</span> : [ <span class="string">"test"</span> ], <span class="string">"likes"</span> : 200 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a6a083e98891b4abe9cc8cd"</span>), <span class="string">"title"</span> : <span class="string">"测试数据150"</span>, <span class="string">"description"</span> : <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>, <span class="string">"by"</span> : <span class="string">"搜云库"</span>, <span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>, <span class="string">"tags"</span> : [ <span class="string">"test"</span> ], <span class="string">"likes"</span> : 150 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a6a084498891b4abe9cc8ce"</span>), <span class="string">"title"</span> : <span class="string">"测试数据100"</span>, <span class="string">"description"</span> : <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>, <span class="string">"by"</span> : <span class="string">"搜云库"</span>, <span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>, <span class="string">"tags"</span> : [ <span class="string">"test"</span> ], <span class="string">"likes"</span> : 100 &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h3 id="7-3-MongoDB-lt-小于操作符-lt"><a href="#7-3-MongoDB-lt-小于操作符-lt" class="headerlink" title="7.3 MongoDB (&lt;) 小于操作符 - $lt"></a>7.3 MongoDB (&lt;) 小于操作符 - $lt</h3><p>如果你想获取”col”集合中 “likes” 小于 150 的数据，你可以使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;likes : &#123;<span class="variable">$lt</span> : 150&#125;&#125;)</span><br></pre></td></tr></table></figure><p>类似于SQL语句：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from col <span class="built_in">where</span> likes &lt; 150;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.find(&#123;likes : &#123;<span class="variable">$lt</span> : 150&#125;&#125;)</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a6a084498891b4abe9cc8ce"</span>), <span class="string">"title"</span> : <span class="string">"测试数据100"</span>, <span class="string">"description"</span> : <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>, <span class="string">"by"</span> : <span class="string">"搜云库"</span>, <span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>, <span class="string">"tags"</span> : [ <span class="string">"test"</span> ], <span class="string">"likes"</span> : 100 &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h3 id="7-4-MongoDB-lt-小于操作符-lte"><a href="#7-4-MongoDB-lt-小于操作符-lte" class="headerlink" title="7.4 MongoDB (&lt;=) 小于操作符 - $lte"></a>7.4 MongoDB (&lt;=) 小于操作符 - $lte</h3><p>如果你想获取”col”集合中 “likes” 小于等于 150 的数据，你可以使用以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;likes : &#123;<span class="variable">$lte</span> : 150&#125;&#125;)</span><br></pre></td></tr></table></figure><p>类似于SQL语句：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from col <span class="built_in">where</span> likes &lt;= 150;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.find(&#123;likes : &#123;<span class="variable">$lte</span> : 150&#125;&#125;)</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a6a083e98891b4abe9cc8cd"</span>), <span class="string">"title"</span> : <span class="string">"测试数据150"</span>, <span class="string">"description"</span> : <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>, <span class="string">"by"</span> : <span class="string">"搜云库"</span>, <span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>, <span class="string">"tags"</span> : [ <span class="string">"test"</span> ], <span class="string">"likes"</span> : 150 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a6a084498891b4abe9cc8ce"</span>), <span class="string">"title"</span> : <span class="string">"测试数据100"</span>, <span class="string">"description"</span> : <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>, <span class="string">"by"</span> : <span class="string">"搜云库"</span>, <span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>, <span class="string">"tags"</span> : [ <span class="string">"test"</span> ], <span class="string">"likes"</span> : 100 &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h3 id="7-5-MongoDB-使用-lt-和-gt-查询-lt-和-gt"><a href="#7-5-MongoDB-使用-lt-和-gt-查询-lt-和-gt" class="headerlink" title="7.5 MongoDB 使用 (&lt;) 和 (&gt;) 查询 - $lt 和 $gt"></a>7.5 MongoDB 使用 (&lt;) 和 (&gt;) 查询 - $lt 和 $gt</h3><p>如果你想获取”col”集合中 “likes” 大于100，小于 200 的数据，你可以使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;likes : &#123;<span class="variable">$lt</span> :200, <span class="variable">$gt</span> : 100&#125;&#125;)</span><br></pre></td></tr></table></figure><p>类似于SQL语句：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from col <span class="built_in">where</span> likes&gt;100 AND  likes&lt;200;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.find(&#123;likes : &#123;<span class="variable">$lt</span> :200, <span class="variable">$gt</span> : 100&#125;&#125;)</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a6a083e98891b4abe9cc8cd"</span>), <span class="string">"title"</span> : <span class="string">"测试数据150"</span>, <span class="string">"description"</span> : <span class="string">"关注公众号，搜云库，专注于开发技术的研究与知识分享"</span>, <span class="string">"by"</span> : <span class="string">"搜云库"</span>, <span class="string">"url"</span> : <span class="string">"http://www.souyunku.com"</span>, <span class="string">"tags"</span> : [ <span class="string">"test"</span> ], <span class="string">"likes"</span> : 150 &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>一些简写说明：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gt</span> -------- greater than  &gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">$gte</span> --------- gt equal  &gt;=</span><br><span class="line"></span><br><span class="line"><span class="variable">$lt</span> -------- less than  &lt;</span><br><span class="line"></span><br><span class="line"><span class="variable">$lte</span> --------- lt equal  &lt;=</span><br><span class="line"></span><br><span class="line"><span class="variable">$ne</span> ----------- not equal  !=</span><br><span class="line"></span><br><span class="line"><span class="variable">$eq</span>  --------  equal  =</span><br></pre></td></tr></table></figure><p><strong>参考：</strong></p><p>Runoob 教程：<a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/mongodb/mongodb-tutorial.html</a><br>Tutorials 教程：Point<a href="https://www.tutorialspoint.com/mongodb/mongodb_advantages.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/mongodb/mongodb_advantages.htm</a><br>MongoDB 官网地址：<a href="https://www.mongodb.com" target="_blank" rel="noopener">https://www.mongodb.com</a><br>MongoDB 官方英文文档：<a href="https://docs.mongodb.com/manual" target="_blank" rel="noopener">https://docs.mongodb.com/manual</a><br>MongoDB 各平台下载地址：<a href="https://www.mongodb.com/download-center#community" target="_blank" rel="noopener">https://www.mongodb.com/download-center#community</a><br>MongoDB 安装 <a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-enterprise-on-ubuntu" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-enterprise-on-ubuntu</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、什么是MongoDB&quot;&gt;&lt;a href=&quot;#一、什么是MongoDB&quot; class=&quot;headerlink&quot; title=&quot;一、什么是MongoDB ?&quot;&gt;&lt;/a&gt;一、什么是MongoDB ?&lt;/h1&gt;&lt;p&gt;MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。&lt;/p&gt;
&lt;p&gt;在高负载的情况下，添加更多的节点，可以保证服务器性能。&lt;/p&gt;
&lt;p&gt;MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。&lt;/p&gt;
&lt;p&gt;MongoDB 将数据存储为一个文档，数据结构由键值(key=&amp;gt;value)对组成。&lt;/p&gt;
&lt;p&gt;MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://ciweigg.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://ciweigg.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性-时间格式化</title>
    <link href="https://ciweigg.github.io/2018/01/25/Java8%E6%96%B0%E7%89%B9%E6%80%A7-%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>https://ciweigg.github.io/2018/01/25/Java8新特性-时间格式化/</id>
    <published>2018-01-25T03:00:32.000Z</published>
    <updated>2018-01-25T03:28:54.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解析与格式化"><a href="#解析与格式化" class="headerlink" title="解析与格式化"></a>解析与格式化</h3><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：<br>1.预定义的标准格式<br>2.语言环境相关的格式<br>3.自定义的格式<br><a id="more"></a></p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line">import java.time.temporal.TemporalAccessor;</span><br><span class="line">import java.util.Locale;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class TimeFormatTest &#123;</span><br><span class="line">/*</span><br><span class="line"> * 时间格式化：java.time.format.DateTimeFormatter </span><br><span class="line"> * 1.默认提供</span><br><span class="line"> * 2.自定义格式</span><br><span class="line"> * 格式化步骤:</span><br><span class="line"> *1.新建一个DateTimeFormatter对象（有静态对象，也可以自己创建[自己创建是调用ofPattern方法]）。</span><br><span class="line"> *2.调用该对象的format方法，参数是需要格式化的LocalDateTime对象。</span><br><span class="line"> * 解析步骤：</span><br><span class="line"> * 1.新建一个时间的字符串对象。</span><br><span class="line"> * 2.新建一个DateTimeFormatter对象（有静态对象，也可以自己创建[自己创建是调用ofPattern方法]）。</span><br><span class="line"> * 3.调用DateTimeFormatter对象的parse方法，进行解析，返回一个TemporalAccessor对象。</span><br><span class="line"> * 4.调用LocalDateTime的静态方法form，将TemporalAccessor转换成LocalDateTime对象。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 时间格式化：1.默认提供</span><br><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">// 1.新建一个DateTimeFormatter对象（有静态对象，也可以自己创建）</span><br><span class="line">DateTimeFormatter isoDate = DateTimeFormatter.ISO_DATE;</span><br><span class="line"></span><br><span class="line">LocalDateTime ldt1 = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">// 2.调用该对象的format方法，参数是需要格式化的LocalDateTime对象。</span><br><span class="line">String format = isoDate.format(ldt1);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;时间是：&quot; + format);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> * 结果：</span><br><span class="line"> * 时间是：2018-01-22</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 时间格式化：2.自定义格式</span><br><span class="line">@Test</span><br><span class="line">public void test2() &#123;</span><br><span class="line">// 1.新建一个DateTimeFormatter对象（有静态对象，也可以自己创建[自己创建是调用ofPattern方法]）</span><br><span class="line">DateTimeFormatter pattern = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;, Locale.CHINA);</span><br><span class="line"></span><br><span class="line">// 2.调用该对象的format方法，参数是需要格式化的LocalDateTime对象。</span><br><span class="line">String format = pattern.format(LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;时间是：&quot; + format);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> * 结果：</span><br><span class="line"> * 时间是：2018年01月22日 11时30分55秒</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 时间解析：自定义格式</span><br><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">// 1.新建一个时间的字符串对象。</span><br><span class="line">String dateTime = &quot;2017年12月30日 13点20分30秒&quot;;</span><br><span class="line"></span><br><span class="line">// 2.新建一个DateTimeFormatter对象（有静态对象，也可以自己创建[自己创建是调用ofPattern方法]）。</span><br><span class="line">DateTimeFormatter pattern = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH点mm分ss秒&quot;);</span><br><span class="line"></span><br><span class="line">// 3.调用DateTimeFormatter对象的parse方法，进行解析，返回一个TemporalAccessor对象。</span><br><span class="line">TemporalAccessor parse = pattern.parse(dateTime);</span><br><span class="line"></span><br><span class="line">// 4.调用LocalDateTime的静态方法form，将TemporalAccessor转换成LocalDateTime对象。</span><br><span class="line">LocalDateTime ldt1 = LocalDateTime.from(parse);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;LocalDateTime：&quot; + ldt1);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> * 结果：</span><br><span class="line"> * LocalDateTime：2017-12-30T13:20:30</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">     /*</span><br><span class="line">     * TemporalAdjuster: 时间校正器,这是个接口。</span><br><span class="line">     * TemporalAdjusters:时间矫正器的一个工具类，提供了一些对TemporalAdjuster接口的具体实现类。</span><br><span class="line">     *</span><br><span class="line">     * 使用步骤：</span><br><span class="line">     * 1.调用LocalDateTime的with方法。</span><br><span class="line">     * 2.在with方法中传入TemporalAdjuster</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // 使用TemporalAdjusters工具类。</span><br><span class="line">    @Test</span><br><span class="line">    public void test4() &#123;</span><br><span class="line">        LocalDateTime ldt1 = LocalDateTime.now();</span><br><span class="line">        System.out.println(&quot;现在是：&quot; + ldt1);</span><br><span class="line"></span><br><span class="line">//        LocalDateTime ldt2 = ldt1.plusDays(1); //获取当前日期的下一天</span><br><span class="line">//        LocalDateTime ldt2 = ldt1.plusDays(-1); //获取当前日期的前一天</span><br><span class="line">        LocalDateTime ldt2 = ldt1.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)); //获取下一个周日</span><br><span class="line">        //日期格式化</span><br><span class="line">        DateTimeFormatter isoDate = DateTimeFormatter.ISO_DATE;</span><br><span class="line">        String dates = isoDate.format(ldt2);</span><br><span class="line">        System.out.println(&quot;下一个日期：&quot; + ldt2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * 3.计算时间差/日期差</span><br><span class="line">     * Duration:用于计算两个“时间”间隔</span><br><span class="line">     * Period:用于计算两个“日期”间隔</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void test5() &#123;</span><br><span class="line">        Instant ins1 = Instant.now();</span><br><span class="line">        for (int i = 0; i &lt; 1000*10000; i++) &#123;</span><br><span class="line">            //为了测试时间间隔，不做任何处理这边。</span><br><span class="line">        &#125;</span><br><span class="line">        Instant ins2 = Instant.now();</span><br><span class="line">        /*</span><br><span class="line">         * Duration.between：传Instant/LocalDateTime都行。</span><br><span class="line">         */</span><br><span class="line">        // 1.Duration.between:计算两个时间间隔，返回一个Duration对象</span><br><span class="line">        Duration between = Duration.between(ins1,ins2);</span><br><span class="line"></span><br><span class="line">        // 2.Duration的toXxx方法：转换成对应的时间单位</span><br><span class="line">        System.out.println(&quot;时间间隔：&quot; + between.toMillis() + &quot;s&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Period.between:计算两个日期的间隔，返回一个Period对象</span><br><span class="line">         */</span><br><span class="line">        LocalDate ld1 = LocalDate.now();</span><br><span class="line"></span><br><span class="line">        LocalDate ld2 = LocalDate.of(2018, 10, 20);</span><br><span class="line"></span><br><span class="line">        Period period = Period.between(ld1, ld2);</span><br><span class="line"></span><br><span class="line">        // 相差 多少年 多少月 多少天</span><br><span class="line">        System.out.println(period.getYears());</span><br><span class="line">        System.out.println(period.getMonths());</span><br><span class="line">        System.out.println(period.getDays());</span><br><span class="line">        System.out.println(&quot;相差：&quot;+ period.getYears()+&quot;年&quot;+period.getMonths()+&quot;月&quot;+period.getDays()+&quot;天&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;解析与格式化&quot;&gt;&lt;a href=&quot;#解析与格式化&quot; class=&quot;headerlink&quot; title=&quot;解析与格式化&quot;&gt;&lt;/a&gt;解析与格式化&lt;/h3&gt;&lt;p&gt;java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：&lt;br&gt;1.预定义的标准格式&lt;br&gt;2.语言环境相关的格式&lt;br&gt;3.自定义的格式&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://ciweigg.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://ciweigg.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>分布式和集群区别？什么是云计算平台？分布式的应用场景？</title>
    <link href="https://ciweigg.github.io/2018/01/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E9%9B%86%E7%BE%A4%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%EF%BC%9F%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F/"/>
    <id>https://ciweigg.github.io/2018/01/24/分布式和集群区别？什么是云计算平台？分布式的应用场景？/</id>
    <published>2018-01-24T05:18:00.000Z</published>
    <updated>2018-01-24T05:37:28.406Z</updated>
    
    <content type="html"><![CDATA[<p>分布式是指将一个业务拆分不同的子业务，分布在不同的机器上执行，集群是指多台服务器集中在一起，实现同一业务，可以视为一台计算机，一个云计算平台，就是通过一套软件系统把分布式部署的资源集中调度使用。要应对大并发，要实现高可用，既需要分布式，也离不开集群。<br><a id="more"></a></p><h1 id="分布式和集群区别？"><a href="#分布式和集群区别？" class="headerlink" title="分布式和集群区别？"></a>分布式和集群区别？</h1><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><strong>分布式</strong>：是指将一个业务拆分不同的子业务，分布在不同的机器上执行。</p><p>常用的分布式就是在负载均衡服务器后加一堆web服务器，然后在上面搞一个缓存服务器来保存临时状态，后面共享一个数据库，</p><p>如图所示:</p><p><img src="http://oisa91ton.bkt.clouddn.com/1516771212768cvv1ea6t.png?imageslim" alt="paste image"></p><p>这种环境下真正进行分布式的只是web server而已，并且web server之间没有任何联系，所以结构和实现都非常简单。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p><strong>集群</strong>：是指多台服务器集中在一起，实现同一业务，可以视为一台计算机。</p><p>多台服务器组成的一组计算机，作为一个整体存在，向用户提供一组网络资源，这些单个的服务器就是集群的节点。</p><h2 id="两个特点"><a href="#两个特点" class="headerlink" title="两个特点"></a>两个特点</h2><p><strong>可扩展性</strong>：集群中的服务节点，可以动态的添加机器，从而增加集群的处理能力。</p><p><strong>高可用性</strong>：如果集群某个节点发生故障，这台节点上面运行的服务，可以被其他服务节点接管，从而增强集群的高可用性。</p><h2 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类</h2><p>常用的集群分类</p><p><strong>1.高可用集群</strong>(High Availability Cluster)</p><p>高可用集群,普通两节点双机热备，多节点HA集群。</p><p><strong>2.负载均衡集群</strong>(Load Balance Cluster) </p><p>常用的有 Nginx 把请求分发给后端的不同web服务器，还有就是数据库集群，负载均衡就是，为了保证服务器的高可用，高并发。  </p><p><strong>3.科学计算集群</strong>(High Performance Computing Cluster)  </p><p>简称HPC集群。这类集群致力于提供单个计算机所不能提供的强大的计算能力。  </p><h2 id="两大能力"><a href="#两大能力" class="headerlink" title="两大能力"></a>两大能力</h2><p><strong>负载均衡</strong>：负载均衡能把任务比较均衡地分布到集群环境下的计算和网络资源。</p><p><strong>集群容错</strong>：当我们的系统中用到集群环境,因为各种原因在集群调用失败时，集群容错起到关键性的作用。</p><p>例如 Dubbo 的集群容错：</p><p><strong>Failover Cluster</strong>  </p><p>失败自动切换，当出现失败，重试其它服务器，通常用于读操作，但重试会带来更长延迟。  </p><p><strong>Failfast Cluster</strong>  </p><p>快速失败，只发起一次调用，失败立即报错，通常用于非幂等性的写操作，比如新增记录。  </p><p><strong>Failback Cluster</strong>  </p><p>失败自动恢复，后台记录失败请求，定时重发，通常用于消息通知操作。</p><p><strong>Forking Cluster</strong>  </p><p>并行调用多个服务器，只要一个成功即返回，通常用于实时性要求较高的读操作，但需要浪费更多服务资源。  </p><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>分布式，从狭义上理解，也与集群差不多，但是它的组织比较松散，不像集群，有一定组织性，一台服务器宕了，其他的服务器可以顶上来。</p><p>分布式的每一个节点，都完成不同的业务，一个节点宕了，这个业务就不可访问了。</p><p><strong>1. 分布式是指将一个业务拆分不同的子业务，分布在不同的机器上执行。</strong> </p><p><strong>2. 集群是指多台服务器集中在一起，实现同一业务，可以视为一台计算机。</strong> </p><p>分布式的每一个节点，都可以用来做集群。而集群不一定就是分布式了。  </p><h1 id="什么是云计算平台？"><a href="#什么是云计算平台？" class="headerlink" title="什么是云计算平台？"></a>什么是云计算平台？</h1><p>一个云计算平台，就是通过一套软件系统把分布式部署的资源集中调度使用。要应对大并发，要实现高可用，既需要分布式，也离不开集群。</p><p>比如负载均衡，如果只是一台服务器，这台宕机了就完蛋了。</p><p>分布式的难点，就是很多机器做存在依赖关系的不同活儿，这些活儿需要的资源、时间区别可能很大，某些机器还可能罢工，要怎么样才能协调好，做到效率最高，消耗最少，不出错。</p><h1 id="分布式的应用场景？"><a href="#分布式的应用场景？" class="headerlink" title="分布式的应用场景？"></a>分布式的应用场景？</h1><p>平时接触到的分布式系统有很多种，比如分布式文件系统，分布式数据库，分布式WebService，分布式计算等等，面向的情景不同，但分布式的思路是否是一样的呢?</p><h2 id="1-简单的例子"><a href="#1-简单的例子" class="headerlink" title="1.简单的例子"></a>1.简单的例子</h2><p>假设我们有一台服务器，它可以承担1百万/秒的请求，这个请求可以的是通过http访问网页，通过tcp下载文件，jdbc执行sql，RPC调用接口…，现在我们有一条数据的请求是2百万/秒，很显然服务器hold不住了，会各种拒绝访问，甚至崩溃，宕机，怎么办呢。</p><p>一台机器解决不了的问题，那就两台。所以我们加一台机器，每台承担1百万。如果请求继续增加呢，两台解决不了的问题，那就三台呗。</p><p>这种方式我们称之为<strong>水平扩展</strong>。如何实现请求的平均分配便是<strong>负载均衡了</strong>。</p><p>另一个栗子，我们现在有两个数据请求，数据1 90万，数据2 80万，上面那台机器也hold不住，我们加一台机器来负载均衡一下，每台机器处理45万数据1和40万数据2，但是平分太麻烦，不如一台处理数据1，一台处理数据2，同样能解决问题，这种方式我们称之为<strong>垂直拆分</strong>。</p><p><strong>水平扩展和垂直拆分</strong>是分布式架构的两种思路，但并不是一个二选一的问题，更多的是兼并合用。下面介绍一个实际的场景。这也是许多互联网的公司架构思路。</p><h2 id="2-实际的例子"><a href="#2-实际的例子" class="headerlink" title="2.实际的例子"></a>2.实际的例子</h2><p>我此时所在的公司的计算机系统很庞大，自然是一个整的分布式系统，为了方便组织管理，公司将整个技术部按业务和平台拆分为部门，订单的，会员的，商家的等等，每个部门有自己的web服务器集群，数据库服务器集群，通过同一个网站访问的链接可能来自于不同的服务器和数据库，对网站及底层对数据库的访问被分配到了不同的服务器集群,这个便是典型的按业务做的<strong>垂直拆分</strong>，每个部门的服务器在hold不住时，会有弹性的扩展，这便是<strong>水平扩展</strong>。</p><p>在数据库层，有些表非常大，数据量在亿级，如果只是纯粹的水平的扩展并不一定最好，如果对表进行拆分，比如可以按用户id进行水平拆表，通过对id取模的方式，将用户划分到多张表中，同时这些表也可以处在不同的服务器。按业务的垂直拆库和按用户<strong>水平拆表</strong>是分布式数据库中通用的解决方案。</p><p>比如 Mycat 开源分布式数据库中间件 <a href="http://www.mycat.io/" target="_blank" rel="noopener">http://www.mycat.io/</a></p><h2 id="3-分布式一致性"><a href="#3-分布式一致性" class="headerlink" title="3.分布式一致性"></a>3.分布式一致性</h2><p>分布式系统中，解决了负载均衡的问题后，另外一个问题就是数据的一致性了，这个就需要通过同步来保障。根据不同的场景和需求，同步的方式也是有选择的。</p><p>在分布式文件系统中，比如商品页面的图片，如果进行了修改，同步要求并不高，就算有数秒甚至数分钟的延迟都是可以接受的，因为一般不会产生损失性的影响，因此可以简单的通过文件修改的时间戳，隔一定时间扫描同步一次，可以牺牲一致性来提高效率。</p><p>但银行中的分布式数据库就不一样了，一丁点不同步就是无法接受的，甚至可以通过加锁等牺牲性能的方式来保障完全的一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式是指将一个业务拆分不同的子业务，分布在不同的机器上执行，集群是指多台服务器集中在一起，实现同一业务，可以视为一台计算机，一个云计算平台，就是通过一套软件系统把分布式部署的资源集中调度使用。要应对大并发，要实现高可用，既需要分布式，也离不开集群。&lt;br&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://ciweigg.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://ciweigg.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用MyBatis轻松实现递归查询与存储过程调用</title>
    <link href="https://ciweigg.github.io/2018/01/23/%E4%BD%BF%E7%94%A8MyBatis%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    <id>https://ciweigg.github.io/2018/01/23/使用MyBatis轻松实现递归查询与存储过程调用/</id>
    <published>2018-01-23T06:03:00.000Z</published>
    <updated>2018-01-24T05:18:40.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h3><p>由于部门的层级不可控，因此如果我想要获取所有部门的完整json的话，就要采用递归调用，使用Java代码处理递归有点low，刚好MyBatis的ResultMap中的collection可以很方便的解决这个问题，核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;org.sang.bean.Department&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;parentId&quot; property=&quot;parentId&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;isParent&quot; property=&quot;isParent&quot;/&gt;</span><br><span class="line">    &lt;collection property=&quot;children&quot; ofType=&quot;org.sang.bean.Department&quot; select=&quot;org.sang.mapper.DepartmentMapper.getDepByPid&quot; column=&quot;id&quot;&gt;</span><br><span class="line">    &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;getDepByPid&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">    select d1.*from department d1 where d1.`parentId`=#&#123;pid&#125; AND d1.enabled=true;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p>每一个Department中都有一个children属性，getDepByPid方法的返回结果是一个BaseResultMap，BaseResultMap中的collection又将调用getDepByPid方法，通过这种方式我们可以快速实现一个递归调用。Mapper中只需要定义如下方法即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Department&gt; getDepByPid(Long pid);</span><br></pre></td></tr></table></figure><p>查询结果如下(部分)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;: 1,</span><br><span class="line">        &quot;name&quot;: &quot;股东会&quot;,</span><br><span class="line">        &quot;parentId&quot;: -1,</span><br><span class="line">        &quot;enabled&quot;: true,</span><br><span class="line">        &quot;children&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 4,</span><br><span class="line">                &quot;name&quot;: &quot;董事长&quot;,</span><br><span class="line">                &quot;parentId&quot;: 1,</span><br><span class="line">                &quot;enabled&quot;: true,</span><br><span class="line">                &quot;children&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;id&quot;: 5,</span><br><span class="line">                        &quot;name&quot;: &quot;总经理&quot;,</span><br><span class="line">                        &quot;parentId&quot;: 4,</span><br><span class="line">                        &quot;enabled&quot;: true,</span><br><span class="line">                        &quot;children&quot;: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                &quot;id&quot;: 8,</span><br><span class="line">                                &quot;name&quot;: &quot;财务部&quot;,</span><br><span class="line">                                &quot;parentId&quot;: 5,</span><br><span class="line">                                &quot;enabled&quot;: true,</span><br><span class="line">                                &quot;children&quot;: [],</span><br><span class="line">                                &quot;parent&quot;: false</span><br><span class="line">                            &#125;],</span><br><span class="line">                        &quot;parent&quot;: true</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                &quot;parent&quot;: true</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;parent&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="存储过程调用"><a href="#存储过程调用" class="headerlink" title="存储过程调用"></a>存储过程调用</h3><p>存储过程调用比较简单，以添加部门为例，如下：</p><h4 id="1-Mapper中添加如下方法："><a href="#1-Mapper中添加如下方法：" class="headerlink" title="1.Mapper中添加如下方法："></a>1.Mapper中添加如下方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void addDep(@Param(&quot;dep&quot;) Department department);</span><br></pre></td></tr></table></figure><h4 id="2-xml中写法如下："><a href="#2-xml中写法如下：" class="headerlink" title="2.xml中写法如下："></a>2.xml中写法如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;addDep&quot; statementType=&quot;CALLABLE&quot;&gt;</span><br><span class="line">    call addDep(#&#123;dep.name,mode=IN,jdbcType=VARCHAR&#125;,#&#123;dep.parentId,mode=IN,jdbcType=INTEGER&#125;,#&#123;dep.enabled,mode=IN,jdbcType=BOOLEAN&#125;,#&#123;dep.result,mode=OUT,jdbcType=INTEGER&#125;,#&#123;dep.id,mode=OUT,jdbcType=BIGINT&#125;)</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>注意statementType调用表示这是一个存储过程，mode=IN表示这是输入参数，mode=OUT表示这是输出参数，调用成功之后，在service中获取department的id和result字段，就能拿到相应的调用结果了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;递归调用&quot;&gt;&lt;a href=&quot;#递归调用&quot; class=&quot;headerlink&quot; title=&quot;递归调用&quot;&gt;&lt;/a&gt;递归调用&lt;/h3&gt;&lt;p&gt;由于部门的层级不可控，因此如果我想要获取所有部门的完整json的话，就要采用递归调用，使用Java代码处理递归有点low，刚好MyBatis的ResultMap中的collection可以很方便的解决这个问题，核心代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;resultMap id=&amp;quot;BaseResultMap&amp;quot; type=&amp;quot;org.sang.bean.Department&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;id property=&amp;quot;id&amp;quot; column=&amp;quot;id&amp;quot;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;result column=&amp;quot;name&amp;quot; property=&amp;quot;name&amp;quot;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;result column=&amp;quot;parentId&amp;quot; property=&amp;quot;parentId&amp;quot;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;result column=&amp;quot;isParent&amp;quot; property=&amp;quot;isParent&amp;quot;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;collection property=&amp;quot;children&amp;quot; ofType=&amp;quot;org.sang.bean.Department&amp;quot; select=&amp;quot;org.sang.mapper.DepartmentMapper.getDepByPid&amp;quot; column=&amp;quot;id&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/collection&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/resultMap&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;select id=&amp;quot;getDepByPid&amp;quot; resultMap=&amp;quot;BaseResultMap&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    select d1.*from department d1 where d1.`parentId`=#&amp;#123;pid&amp;#125; AND d1.enabled=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Mybatis" scheme="https://ciweigg.github.io/categories/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="https://ciweigg.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>工作总结-git的使用</title>
    <link href="https://ciweigg.github.io/2018/01/23/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://ciweigg.github.io/2018/01/23/工作总结-git的使用/</id>
    <published>2018-01-23T05:47:35.000Z</published>
    <updated>2018-01-23T05:58:24.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关联本地和远程仓库"><a href="#关联本地和远程仓库" class="headerlink" title="关联本地和远程仓库"></a>关联本地和远程仓库</h2><h3 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1. 安装git"></a>1. 安装git</h3><p>先安装homebrew，然后通过homebrew安装git</p><p>git中clone项目有两种方式：https和ssh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https：不管是谁，拿到url随便clone，但是在push的时候需要验证用户名和密码</span><br><span class="line">ssh：clone项目你必须是拥有者或者管理员，而且需要在clone前添加SSH Key。</span><br><span class="line">     SSH在push的时候，是不需要输入用户名的，如果配置SSH Key的时候设置了密码，</span><br><span class="line">     则需要输入密码，否则是不需要输入密码的</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>git中使用SSH Key的步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.检查电脑是否存在SSH Key</span><br><span class="line">cd ~/.ssh</span><br><span class="line">ls</span><br><span class="line">如果存在id_rsa.pub或id_dsa.pub文件，说明文件已经存在，跳过创建SSH Key步骤</span><br><span class="line">2.创建SSH Key</span><br><span class="line">ssh -keygen -t rasa -C “your_email@example.com”</span><br><span class="line">3.查看SSH Key</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line">4.将查看的SSH Key赋值到git中设置好</span><br><span class="line">5.测试SSH Key</span><br><span class="line">ssh -T git@git.oschina.net </span><br><span class="line">出现Welcome to xxx就可以了</span><br></pre></td></tr></table></figure><h3 id="2-新建本地仓库"><a href="#2-新建本地仓库" class="headerlink" title="2. 新建本地仓库"></a>2. 新建本地仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir learn-git</span><br><span class="line">cd learn-git</span><br><span class="line">git init // 初始化仓库</span><br></pre></td></tr></table></figure><h3 id="3-推送到远程仓库"><a href="#3-推送到远程仓库" class="headerlink" title="3.推送到远程仓库"></a>3.推送到远程仓库</h3><p>在github上新建一个空的仓库，默认设置<br>github告诉我们可以从这个仓库克隆出新的仓库，也可以把已有的本地仓库与之关联，然后把本地仓库的内容推送到github仓库上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;server&gt;  // 将本地仓库连接到某个远程服务器</span><br><span class="line">git push origin master // 推送本地仓库到远程某个分支上</span><br><span class="line">git remote remove origin // 取消本地目录下关联的远程仓库</span><br></pre></td></tr></table></figure><p>在执行如下操作会遇到点小问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/Liuhui11/learn-git.git</span><br><span class="line">git push -u origin master 报错error: src refspec master does not match any.</span><br></pre></td></tr></table></figure><p>这样是因为：空仓库不能提交上去（给项目添加文件），执行如下命令即可解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch README // 创建新文件</span><br><span class="line">git commit -m ‘first commit’</span><br><span class="line">git push -u origin master // 第一推送需要加-u选项</span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch dev // 创建分支 </span><br><span class="line">git branch // 查看分支</span><br><span class="line">git checkout dev // 切换分支</span><br><span class="line">git merge dev // 合并指定分支到当前分支</span><br><span class="line"> git push origin dev:master // 提交本地分支到远程</span><br><span class="line">git branch -d dev // 删除分支</span><br></pre></td></tr></table></figure><h4 id="1-分支管理策略"><a href="#1-分支管理策略" class="headerlink" title="1. 分支管理策略"></a>1. 分支管理策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">master分支：稳定、仅用来发布新版本，平时不能在上面干活</span><br><span class="line">dev分支：不稳定、干活的地方，发布新版本时合并到master上</span><br><span class="line">个人开发的分支：每个人都有自己的分支，最终要往dev上合并</span><br><span class="line"></span><br><span class="line">合并分支时加上—no-ff参数可使用普通模式合并，合并后的历史有分支，能看出来曾经做过合并；</span><br><span class="line">而fast forward合并就看不出来曾经做过合并</span><br></pre></td></tr></table></figure><h4 id="2-bug分支"><a href="#2-bug分支" class="headerlink" title="2. bug分支"></a>2. bug分支</h4><p>但当前工作区任务还未完成又要改bug的时候使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash 将当前工作现场储存起来，等以后恢复现场后继续工作</span><br><span class="line">git stash apply 恢复之前的工作现场</span><br><span class="line">git stash list</span><br><span class="line">git stash drop 删除stash内容</span><br><span class="line">it stash apply stash@&#123;0&#125; 恢复到指定的stash</span><br></pre></td></tr></table></figure><h4 id="3-feature分支"><a href="#3-feature分支" class="headerlink" title="3. feature分支"></a>3. feature分支</h4><p>为新功能创建分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D feature-vulcan 强行删除分支</span><br></pre></td></tr></table></figure></p><h4 id="4-多人协作"><a href="#4-多人协作" class="headerlink" title="4. 多人协作"></a>4. 多人协作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git remote -v 查看远程库的信息</span><br><span class="line">master分支是主分支，因此时刻与远程同步</span><br><span class="line">dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步</span><br><span class="line">bug分支只用于在本地修复bug，就没必要推到远程了</span><br><span class="line">feature分支是否推到远程，取决于你是否和你的小伙伴在上面开发</span><br><span class="line"></span><br><span class="line">git checkout -b dev origin/dev 关联远程dev分支到本地，即创建本地dev分支</span><br><span class="line">git branch --set-upstream dev origin/dev dev和origin/dev的连接</span><br></pre></td></tr></table></figure><h3 id="工作模式："><a href="#工作模式：" class="headerlink" title="工作模式："></a>工作模式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.试图用git push origin branch-name推送自己的修改</span><br><span class="line">2.如果推送失败，则因为远程分支比你的本地更新，需要新用git pull试图合并</span><br><span class="line">3.如果合并有冲突，则解决冲突，并在本地提交</span><br><span class="line">4.没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功</span><br><span class="line"></span><br><span class="line">如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，</span><br><span class="line">用命令git branch --set-upstream branch-name origin/branch-name</span><br></pre></td></tr></table></figure><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0 // 创建标签，默认标签是打在最新提交的commit上的</span><br><span class="line">git tag // 查看标签</span><br><span class="line">git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; // 指定标签信息</span><br><span class="line">git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot; // 用PGP签名标签</span><br></pre></td></tr></table></figure><p>找到历史提交的commit id打标签:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.git log --pretty=oneline --abbrev-commit </span><br><span class="line">2.git tag v1.0 commi-id</span><br><span class="line"></span><br><span class="line">git tag -d v1.0 // 删除标签</span><br><span class="line">git push origin &lt;tagname&gt; // 推送指定标签</span><br><span class="line">git push origin --tags // 一次性推送全部尚未推送到远程的本地标签</span><br><span class="line">git tag -d v0.9 &amp; git push origin :refs/tags/v0.9 // 删除远程标签</span><br></pre></td></tr></table></figure></p><h3 id="代码管理"><a href="#代码管理" class="headerlink" title="代码管理"></a>代码管理</h3><h4 id="1-工作区与暂存区"><a href="#1-工作区与暂存区" class="headerlink" title="1. 工作区与暂存区"></a>1. 工作区与暂存区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">工作区 work </span><br><span class="line">暂存区 index/stage</span><br><span class="line">git rm file 删除暂存区或分支上的文件，同时工作区也不需要</span><br><span class="line">git rm —cached file 保留了工作区的这个文件</span><br></pre></td></tr></table></figure><h4 id="2-管理修改"><a href="#2-管理修改" class="headerlink" title="2. 管理修改"></a>2. 管理修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git比其他版本控制系统优秀的原因是git跟踪并管理的是修改，而非文件</span><br></pre></td></tr></table></figure><h4 id="3-提交修改"><a href="#3-提交修改" class="headerlink" title="3.提交修改"></a>3.提交修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git pull // 相当于是从远程获取最新版并merge到本地</span><br><span class="line">git fetch // 相当于是从远程获取最新版本到本地，不会自动merge </span><br><span class="line">git fetch // 拉取分支</span><br><span class="line">git diff dev // 比较分支修改</span><br><span class="line">git merge dev // 合并分支</span><br><span class="line">git log -p master ..origin/master // 比较本地和远程分支的差别</span><br><span class="line">git pull // 相当于git fetch加git merge，实际过程中git fetch更安全一些，因为在merge前可以查看更新情况，然后决定是否合并</span><br><span class="line">git branch --set-upstream-to=origin/dev 本地新建分支后必须要做远程分支关联，这样在pull、push的时候不需要指定远程的分支</span><br><span class="line">git commit // 只负责把暂存区的修改提交了</span><br><span class="line">git diff HEAD — app/user/user.html // 查看工作区和版本库里面最新版本的区别</span><br><span class="line">git checkout — file // 丢弃工作区的修改</span><br><span class="line">git rm file // 删除文件</span><br><span class="line">git rm // 如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容</span><br></pre></td></tr></table></figure><h4 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git log／git log --pretty=oneline // 查看commit的历史记录</span><br><span class="line">git reset —hard HEAD^ // 回退到上一个版本，或者通过commit id来回退到指定版本</span><br><span class="line">git reflog // 记录你的每一次命令，包括未来的版本 找到之前版本的commit id可以返回到最新的版本</span><br><span class="line">git checkout file // 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件，已添加到暂存区的改动以及新文件都不会受到影响。</span><br><span class="line">git fetch origin &amp; git reset —hard origin/master // 丢去你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它</span><br></pre></td></tr></table></figure><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>忽略文件的原则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 忽略操作系统自动生成的文件，比如缩略图</span><br><span class="line">2. 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库</span><br><span class="line">3. 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件</span><br><span class="line"></span><br><span class="line">比如忽略所有js文件的规则：*.js</span><br><span class="line">git add -f file 强制添加文件，即使被忽略了</span><br><span class="line">git check-ignore -v file 查看文件不能被提交是哪个规则写的</span><br><span class="line">https://github.com/github/gitignore 在线自动生成忽略文件</span><br></pre></td></tr></table></figure></p><h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">忽略已经被追踪的文件</span><br><span class="line">git rm --cached file</span><br><span class="line">更新.gitignore忽略掉目标文件</span><br><span class="line">git add .</span><br><span class="line">git commit -m </span><br><span class="line">或者：git update-index --assume-unchanged logs/*.log</span><br></pre></td></tr></table></figure><h4 id="参考资料：按难易程度排序"><a href="#参考资料：按难易程度排序" class="headerlink" title="参考资料：按难易程度排序"></a>参考资料：按难易程度排序</h4><p><a href="https://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">https://rogerdudler.github.io/git-guide/index.zh.html</a> git - 简明指南<br><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">https://marklodato.github.io/visual-git-guide/index-zh-cn.html</a> 图解git<br><a href="https://try.github.io/levels/1/challenges/1" target="_blank" rel="noopener">https://try.github.io/levels/1/challenges/1</a> git在线练习<br><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a> git必看 git入门和进深<br><a href="https://segmentfault.com/q/1010000000358588" target="_blank" rel="noopener">https://segmentfault.com/q/1010000000358588</a> github相关资料推荐<br><a href="https://git-scm.com/docs/" target="_blank" rel="noopener">https://git-scm.com/docs/</a> git官方文档</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关联本地和远程仓库&quot;&gt;&lt;a href=&quot;#关联本地和远程仓库&quot; class=&quot;headerlink&quot; title=&quot;关联本地和远程仓库&quot;&gt;&lt;/a&gt;关联本地和远程仓库&lt;/h2&gt;&lt;h3 id=&quot;1-安装git&quot;&gt;&lt;a href=&quot;#1-安装git&quot; class=&quot;headerlink&quot; title=&quot;1. 安装git&quot;&gt;&lt;/a&gt;1. 安装git&lt;/h3&gt;&lt;p&gt;先安装homebrew，然后通过homebrew安装git&lt;/p&gt;
&lt;p&gt;git中clone项目有两种方式：https和ssh&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https：不管是谁，拿到url随便clone，但是在push的时候需要验证用户名和密码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh：clone项目你必须是拥有者或者管理员，而且需要在clone前添加SSH Key。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     SSH在push的时候，是不需要输入用户名的，如果配置SSH Key的时候设置了密码，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     则需要输入密码，否则是不需要输入密码的&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://ciweigg.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://ciweigg.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Centos7安装Docker</title>
    <link href="https://ciweigg.github.io/2018/01/19/Centos7%E5%AE%89%E8%A3%85Docker/"/>
    <id>https://ciweigg.github.io/2018/01/19/Centos7安装Docker/</id>
    <published>2018-01-19T02:53:00.000Z</published>
    <updated>2018-01-19T03:01:28.110Z</updated>
    
    <content type="html"><![CDATA[<p> Docker 是由 Go 语言编写，一个快速部署的 轻量级虚拟技术项目，它允许开发人员把自己的程序 和 开发环境一起打包，制作成一个 Docker 的image（镜像），这样部署到服务器上，也只需要下载这个 image 镜像将程序跑起来，免去了每次安装依赖和环境的麻烦，还能做到应用间的隔离<br><a id="more"></a></p><h3 id="下载源"><a href="#下载源" class="headerlink" title="下载源"></a>下载源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tee /etc/yum.repos.d/docker.repo &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/7/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  -y  install docker-engine</span><br></pre></td></tr></table></figure><h3 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker.service</span><br></pre></td></tr></table></figure><p>docker常用命令：<br>systemctl stop docker<br>systemctl start docker<br>systemctl status docker</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; Docker 是由 Go 语言编写，一个快速部署的 轻量级虚拟技术项目，它允许开发人员把自己的程序 和 开发环境一起打包，制作成一个 Docker 的image（镜像），这样部署到服务器上，也只需要下载这个 image 镜像将程序跑起来，免去了每次安装依赖和环境的麻烦，还能做到应用间的隔离&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://ciweigg.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://ciweigg.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Async异步执行</title>
    <link href="https://ciweigg.github.io/2018/01/19/Spring%20Boot%20Async%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C/"/>
    <id>https://ciweigg.github.io/2018/01/19/Spring Boot Async异步执行/</id>
    <published>2018-01-19T02:19:12.000Z</published>
    <updated>2018-01-19T02:21:07.260Z</updated>
    
    <content type="html"><![CDATA[<p>异步调用就是不用等待结果的返回就执行后面的逻辑，同步调用则需要等带结果再执行后面的逻辑。</p><p>通常我们使用异步操作都会去创建一个线程执行一段逻辑，然后把这个线程丢到线程池中去执行，代码如下：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(10);</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 业务逻辑</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p><p>这样的方式看起来没那么优雅，尽管用了java的lambda。在Spring Boot中有一种更简单的方式来执行异步操作，只需要一个@Async注解即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Async</span><br><span class="line">public void saveLog() &#123;</span><br><span class="line">    System.err.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以直接在Controller中调用这个业务方法，它就是异步执行的，会在默认的线程池中去执行。需要注意的是一定要在外部的类中去调用这个方法，如果在本类调用是不起作用的，比如this.saveLog()。 最后在启动类上开启异步任务的执行，添加@EnableAsync即可。</p><p>另外关于执行异步任务的线程池我们也可以自定义，首先我们定义一个线程池的配置类，用来配置一些参数，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Configuration;  </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 异步任务线程池配置</span><br><span class="line"> * </span><br><span class="line"> * @author yinjihuan</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.task.pool&quot;)</span><br><span class="line">public class TaskThreadPoolConfig &#123; </span><br><span class="line"></span><br><span class="line">    //核心线程数</span><br><span class="line">    private int corePoolSize = 5;  </span><br><span class="line"></span><br><span class="line">    //最大线程数</span><br><span class="line">    private int maxPoolSize = 50;  </span><br><span class="line"></span><br><span class="line">    //线程池维护线程所允许的空闲时间</span><br><span class="line">    private int keepAliveSeconds = 60;  </span><br><span class="line"></span><br><span class="line">    //队列长度</span><br><span class="line">    private int queueCapacity = 10000;</span><br><span class="line"></span><br><span class="line">    //线程名称前缀</span><br><span class="line">    private String threadNamePrefix = &quot;FSH-AsyncTask-&quot;;</span><br><span class="line"></span><br><span class="line">    public String getThreadNamePrefix() &#123;</span><br><span class="line">        return threadNamePrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setThreadNamePrefix(String threadNamePrefix) &#123;</span><br><span class="line">        this.threadNamePrefix = threadNamePrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCorePoolSize() &#123;</span><br><span class="line">        return corePoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCorePoolSize(int corePoolSize) &#123;</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMaxPoolSize() &#123;</span><br><span class="line">        return maxPoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMaxPoolSize(int maxPoolSize) &#123;</span><br><span class="line">        this.maxPoolSize = maxPoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getKeepAliveSeconds() &#123;</span><br><span class="line">        return keepAliveSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKeepAliveSeconds(int keepAliveSeconds) &#123;</span><br><span class="line">        this.keepAliveSeconds = keepAliveSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getQueueCapacity() &#123;</span><br><span class="line">        return queueCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setQueueCapacity(int queueCapacity) &#123;</span><br><span class="line">        this.queueCapacity = queueCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们重新定义线程池的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.concurrent.Executor;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.scheduling.annotation.AsyncConfigurer;</span><br><span class="line">import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line">@Configuration  </span><br><span class="line">public class AsyncTaskExecutePool implements AsyncConfigurer &#123;    </span><br><span class="line">    private Logger logger = LoggerFactory.getLogger(AsyncTaskExecutePool.class);</span><br><span class="line"></span><br><span class="line">    @Autowired    </span><br><span class="line">    private TaskThreadPoolConfig config;</span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public Executor getAsyncExecutor() &#123;  </span><br><span class="line">        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();  </span><br><span class="line">        executor.setCorePoolSize(config.getCorePoolSize());    </span><br><span class="line">        executor.setMaxPoolSize(config.getMaxPoolSize());    </span><br><span class="line">        executor.setQueueCapacity(config.getQueueCapacity());    </span><br><span class="line">        executor.setKeepAliveSeconds(config.getKeepAliveSeconds());    </span><br><span class="line">        executor.setThreadNamePrefix(config.getThreadNamePrefix());</span><br><span class="line">        //线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy</span><br><span class="line">        //AbortPolicy:直接抛出java.util.concurrent.RejectedExecutionException异常 --&gt;</span><br><span class="line">        //CallerRunsPolicy:主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，可以有效降低向线程池内添加任务的速度 --&gt;</span><br><span class="line">        //DiscardOldestPolicy:抛弃旧的任务、暂不支持；会导致被丢弃的任务无法再次被执行 --&gt;</span><br><span class="line">        //DiscardPolicy:抛弃当前任务、暂不支持；会导致被丢弃的任务无法再次被执行 --&gt;</span><br><span class="line">        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());  </span><br><span class="line">        executor.initialize();    </span><br><span class="line">        return executor;    </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123;// 异步任务中异常处理  </span><br><span class="line">        return new AsyncUncaughtExceptionHandler() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void handleUncaughtException(Throwable arg0, Method arg1, Object... arg2) &#123;  </span><br><span class="line">                logger.error(&quot;==========================&quot;+arg0.getMessage()+&quot;=======================&quot;, arg0);  </span><br><span class="line">                logger.error(&quot;exception method:&quot; + arg1.getName());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完之后我们的异步任务执行的线程池就是我们自定义的了，我们可以通过在属性文件里面配置线程池的大小等等信息，也可以使用默认的配置：</p><p>spring.task.pool.maxPoolSize=100<br>最后讲下线程池配置的拒绝策略，当我们的线程数量高于线程池的处理速度时，任务会被缓存到本地的队列中，队列也是有大小的，如果超过了这个大小，我们需要有拒绝的策略，不然就会内存溢出了，目前支持2中拒绝策略：</p><p>AbortPolicy: 直接抛出java.util.concurrent.RejectedExecutionException异常<br>CallerRunsPolicy: 主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，可以有效降低向线程池内添加任务的速度<br>建议大家用CallerRunsPolicy策略，因为当队列中的任务满了之后，如果直接抛异常，那么这个任务就会被丢弃，如果是CallerRunsPolicy策略会用主线程去执行，就是同步执行，最起码这样任务不会丢弃。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异步调用就是不用等待结果的返回就执行后面的逻辑，同步调用则需要等带结果再执行后面的逻辑。&lt;/p&gt;
&lt;p&gt;通常我们使用异步操作都会去创建一个线程执行一段逻辑，然后把这个线程丢到线程池中去执行，代码如下：&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="https://ciweigg.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://ciweigg.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>swagger 注解使用</title>
    <link href="https://ciweigg.github.io/2018/01/19/swagger%20%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
    <id>https://ciweigg.github.io/2018/01/19/swagger 注解使用/</id>
    <published>2018-01-19T02:08:34.000Z</published>
    <updated>2018-01-19T02:13:58.422Z</updated>
    
    <content type="html"><![CDATA[<p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。Swagger的目标是对REST API定义一个标准的和语言无关的接口，可让人和计算机无需访问源码、文档或网络流量监测就可以发现和理解服务的能力。当通过Swagger进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。与为底层编程所实现的接口类似，Swagger消除了调用服务时可能会有的猜测。<br><a id="more"></a><br>关于Swagger的集成请参考：<a href="https://github.com/yinjihuan/spring-boot-starter-swagger" target="_blank" rel="noopener">https://github.com/yinjihuan/spring-boot-starter-swagger</a></p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>@Api 用在类上，说明该类的作用。可以标记一个Controller类做为swagger 文档资源，使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Api(value=&quot;企业用户控制器&quot;, tags=&#123;&quot;用户接口&quot;&#125;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class EnterpriseProductUserController &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>value：接口说明</li><li>tags：接口说明，可以在页面中显示。可以配置多个，当配置多个的时候，在页面中会显示多个接口的信息</li></ul><h3 id="ApiModel"><a href="#ApiModel" class="headerlink" title="ApiModel"></a>ApiModel</h3><p>@ApiModel用在类上，表示对类进行说明，用于实体类中的参数接收说明，使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ApiModel(value = &quot;com.fangjia.fsh.user.query.LoginQuery&quot;, description = &quot;登录参数&quot;)</span><br><span class="line">public class LoginQuery &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ApiModelProperty"><a href="#ApiModelProperty" class="headerlink" title="ApiModelProperty"></a>ApiModelProperty</h3><p>@ApiModelProperty()用于字段,表示对model属性的说明,使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ApiModel(value = &quot;com.fangjia.fsh.user.query.LoginQuery&quot;, description = &quot;登录参数&quot;)</span><br><span class="line">public class LoginQuery &#123;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(value = &quot;企业编号&quot;, required = true)</span><br><span class="line">    private Long eid;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(value = &quot;用户编号&quot;, required = true)</span><br><span class="line">    private String uid;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ApiParam"><a href="#ApiParam" class="headerlink" title="ApiParam"></a>ApiParam</h3><p>@ ApiParam用于Controller中方法的参数说明，使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/login&quot;)</span><br><span class="line">public ResponseData login(@ApiParam(value = &quot;登录参数&quot;, required = true) @RequestBody LoginQuery query) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>value：参数说明</li><li>required：是否必填</li></ul><h3 id="ApiOperation"><a href="#ApiOperation" class="headerlink" title="ApiOperation"></a>ApiOperation</h3><p>@ApiOperation用在Controller里的方法上，说明方法的作用，每一个接口的定义,使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ApiOperation(value = &quot;用户登录&quot;, notes = &quot;企业用户认证接口，参数为必填项&quot;)</span><br><span class="line">@PostMapping(&quot;/login&quot;)</span><br><span class="line">public ResponseData login(@ApiParam(value = &quot;登录参数&quot;, required = true) @RequestBody LoginQuery query) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>value：接口名称</li><li>notes：详细说明</li></ul><h3 id="ApiResponse和ApiResponses"><a href="#ApiResponse和ApiResponses" class="headerlink" title="ApiResponse和ApiResponses"></a>ApiResponse和ApiResponses</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ApiResponses(&#123; @ApiResponse(code = 403, message = &quot;无权限访问&quot;) &#125;)</span><br><span class="line">public ResponseData login(@ApiParam(value = &quot;登录参数&quot;, required = true) @RequestBody LoginQuery query) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>code：响应状态码</li><li>message：状态码对应的说明</li></ul><h3 id="ApiImplicitParam和ApiImplicitParams"><a href="#ApiImplicitParam和ApiImplicitParams" class="headerlink" title="ApiImplicitParam和ApiImplicitParams"></a>ApiImplicitParam和ApiImplicitParams</h3><p>用于方法上，为单独的请求参数进行说明，使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ApiImplicitParams(&#123;</span><br><span class="line">      @ApiImplicitParam(name=&quot;uid&quot;, value=&quot;用户ID&quot;, required=true, paramType=&quot;query&quot;, dataType=&quot;String&quot;, defaultValue=&quot;1&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">@GetMapping(&quot;/hello&quot;)</span><br><span class="line">public String hello(String uid) &#123;</span><br><span class="line">   return uid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>name：参数名，对应方法中单独的参数名称</li><li>value：参数中文说明</li><li>required：是否必填</li><li>paramType：参数类型，取值为path, query, body, header, form</li><li>dataType：参数数据类型</li><li>defaultValue：默认值</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。Swagger的目标是对REST API定义一个标准的和语言无关的接口，可让人和计算机无需访问源码、文档或网络流量监测就可以发现和理解服务的能力。当通过Swagger进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。与为底层编程所实现的接口类似，Swagger消除了调用服务时可能会有的猜测。&lt;br&gt;
    
    </summary>
    
      <category term="swagger" scheme="https://ciweigg.github.io/categories/swagger/"/>
    
    
      <category term="swagger" scheme="https://ciweigg.github.io/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA基于Springboot的测试生产远程调试</title>
    <link href="https://ciweigg.github.io/2018/01/14/Intellij-IDEA%E5%9F%BA%E4%BA%8ESpringboot%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%9F%E4%BA%A7%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>https://ciweigg.github.io/2018/01/14/Intellij-IDEA基于Springboot的测试生产远程调试/</id>
    <published>2018-01-14T04:50:00.000Z</published>
    <updated>2018-01-14T04:55:22.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本篇博客介绍一下在Intellij IDEA下对Springboot类型的项目的远程调试功能。所谓的远程调试就是服务端程序运行在一台远程服务器上，我们可以在本地服务端的代码（前提是本地的代码必须和远程服务器运行的代码一致）中设置断点，每当有请求到远程服务器时时能够在本地知道远程服务端的此时的内部状态。<br><a id="more"></a></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>首先，打开Edit configurations，点击+号，创建一个Remote应用。<br><img src="http://oisa91ton.bkt.clouddn.com/1515905506985cxng7pn0.png?imageslim" alt="paste image"></p><p>填写name，配置Host地址（远程服务器地址）和端口（选一个未被占用的端口）。然后复制For JDK1.4.x下面的参数，示例配置的端口为5005</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005</span><br></pre></td></tr></table></figure><p><img src="http://oisa91ton.bkt.clouddn.com/151590553445978inszc5.png?imageslim" alt="paste image"></p><p>经过以上步骤，已经获得了启动远程服务器的参数。在启动springboot时默认使用java命令来启动。<br>比如，示例项目启动命令为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar remotedebug-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></p><p>那么此时在启动命令上添加上面获得的参数（非springbboot项目，就是把多的那段配置添加到相应的环境变量即可）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005  remotedebug-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></p><p>这样服务端就监听在5005端口了。可以通过以下命令来检查是否监听成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp | grep 5005</span><br></pre></td></tr></table></figure></p><p>docker<br>如果应用是跑在容器中的，只需要修改Dockerfile即可。例子如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">COPY target/agents.jar /app.jar</span><br><span class="line">EXPOSE 8080</span><br><span class="line">EXPOSE 5005</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot; ,&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005&quot;,&quot;-Dspring.profiles.active=sit&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure><p>通过以上步骤已经完成了服务器端参数的添加。下面启动刚才配置的Remote服务。在启动时候我们会发现此项启动程序只有debug启动模式。</p><p>启动完成，对需要debug的代码打上断点，剩下的操作步骤就是访问远程服务器对应的业务请求，本地就会同步debug。其余的操作与本地debug相同，测试环境调试可以这样操作，生产千万别这样测试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;本篇博客介绍一下在Intellij IDEA下对Springboot类型的项目的远程调试功能。所谓的远程调试就是服务端程序运行在一台远程服务器上，我们可以在本地服务端的代码（前提是本地的代码必须和远程服务器运行的代码一致）中设置断点，每当有请求到远程服务器时时能够在本地知道远程服务端的此时的内部状态。&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://ciweigg.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://ciweigg.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>接口的安全加密</title>
    <link href="https://ciweigg.github.io/2018/01/11/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86/"/>
    <id>https://ciweigg.github.io/2018/01/11/接口的安全加密/</id>
    <published>2018-01-11T10:21:14.000Z</published>
    <updated>2018-01-11T10:31:55.952Z</updated>
    
    <content type="html"><![CDATA[<p>接口传输中如果全部是明文的话，很容易被人家模拟，那么就产生了sign的传输<br>我介绍的加密主要采用：<br>1.对所有传入参数按照字段名的 ASCII 码从小到大排序（字典序），并且生成url参数串<br>2.然后使用md5加密刚才拼接的字符串，字符串后面再拼上key<br>3.使用AES加密md5的签名后的数据，AESkey也使用上面的key<br><a id="more"></a></p><h3 id="首先需要将传入的数据非空的转换成map"><a href="#首先需要将传入的数据非空的转换成map" class="headerlink" title="首先需要将传入的数据非空的转换成map"></a>首先需要将传入的数据非空的转换成map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  /** </span><br><span class="line"> * 将对象装换为map </span><br><span class="line"> * @param bean </span><br><span class="line"> * @return </span><br><span class="line"> */</span><br><span class="line">public static &lt;T&gt; Map&lt;String, Object&gt; beanToMap(T bean) &#123; </span><br><span class="line">  Map&lt;String, Object&gt; map = Maps.newHashMap(); </span><br><span class="line">  if (bean != null) &#123; </span><br><span class="line">    BeanMap beanMap = BeanMap.create(bean); </span><br><span class="line">    for (Object key : beanMap.keySet()) &#123; </span><br><span class="line">      map.put(key+&quot;&quot;, beanMap.get(key)); </span><br><span class="line">    &#125;       </span><br><span class="line">  &#125; </span><br><span class="line">  return map; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ASCII-码从小到大排序（字典序），并且生成url参数串"><a href="#ASCII-码从小到大排序（字典序），并且生成url参数串" class="headerlink" title="ASCII 码从小到大排序（字典序），并且生成url参数串"></a>ASCII 码从小到大排序（字典序），并且生成url参数串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 方法用途: 对所有传入参数按照字段名的 ASCII 码从小到大排序（字典序），并且生成url参数串</span><br><span class="line">     * 实现步骤: </span><br><span class="line">     *</span><br><span class="line">     * @param paraMap    要排序的Map对象</span><br><span class="line">     * @param urlEncode  是否需要URLENCODE</span><br><span class="line">     * @param keyToLower 是否需要将Key转换为全小写</span><br><span class="line">     *                   true:key转化成小写，false:不转化</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String formatUrlMap(Map&lt;String, String&gt; paraMap, boolean urlEncode, boolean keyToLower) &#123;</span><br><span class="line">        String buff = &quot;&quot;;</span><br><span class="line">        Map&lt;String, String&gt; tmpMap = paraMap;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;Map.Entry&lt;String, String&gt;&gt; infoIds = new ArrayList&lt;Map.Entry&lt;String, String&gt;&gt;(tmpMap.entrySet());</span><br><span class="line">            // 对所有传入参数按照字段名的 ASCII 码从小到大排序（字典序）</span><br><span class="line">            Collections.sort(infoIds, new Comparator&lt;Map.Entry&lt;String, String&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public int compare(Map.Entry&lt;String, String&gt; o1, Map.Entry&lt;String, String&gt; o2) &#123;</span><br><span class="line">                    return (o1.getKey()).toString().compareTo(o2.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            // 构造URL 键值对的格式</span><br><span class="line">            StringBuilder buf = new StringBuilder();</span><br><span class="line">            for (Map.Entry&lt;String, String&gt; item : infoIds) &#123;</span><br><span class="line">                if (StringUtils.isNotBlank(item.getKey())) &#123;</span><br><span class="line">                    String key = item.getKey();</span><br><span class="line">                    String val = item.getValue();</span><br><span class="line">                    if (urlEncode) &#123;</span><br><span class="line">                        val = URLEncoder.encode(val, &quot;utf-8&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (keyToLower) &#123;</span><br><span class="line">                        buf.append(key.toLowerCase() + &quot;=&quot; + val);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        buf.append(key + &quot;=&quot; + val);</span><br><span class="line">                    &#125;</span><br><span class="line">                    buf.append(&quot;&amp;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            buff = buf.toString();</span><br><span class="line">            if (buff.isEmpty() == false) &#123;</span><br><span class="line">                buff = buff.substring(0, buff.length() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return buff;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拼接key在上面排序后产生的字符串最后"><a href="#拼接key在上面排序后产生的字符串最后" class="headerlink" title="拼接key在上面排序后产生的字符串最后"></a>拼接key在上面排序后产生的字符串最后</h3><p>String ready  = formatUrlMap()+key</p><h3 id="md5签名"><a href="#md5签名" class="headerlink" title="md5签名"></a>md5签名</h3><p>md5(ready)</p><h3 id="DES加密md5字符串"><a href="#DES加密md5字符串" class="headerlink" title="DES加密md5字符串"></a>DES加密md5字符串</h3><p>DES KEY使用上面的 一般一个用户一个key的<br>DES(MD5)</p><p>可以使用Hutool的工具类：<br>DES des = SecureUtil.des(“String”.getBytes());</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口传输中如果全部是明文的话，很容易被人家模拟，那么就产生了sign的传输&lt;br&gt;我介绍的加密主要采用：&lt;br&gt;1.对所有传入参数按照字段名的 ASCII 码从小到大排序（字典序），并且生成url参数串&lt;br&gt;2.然后使用md5加密刚才拼接的字符串，字符串后面再拼上key&lt;br&gt;3.使用AES加密md5的签名后的数据，AESkey也使用上面的key&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://ciweigg.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://ciweigg.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装Minio——AWS S3存储的开源实现</title>
    <link href="https://ciweigg.github.io/2018/01/10/Docker%E5%AE%89%E8%A3%85Minio%E2%80%94%E2%80%94AWS%20S3%E5%AD%98%E5%82%A8%E7%9A%84%E5%BC%80%E6%BA%90%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ciweigg.github.io/2018/01/10/Docker安装Minio——AWS S3存储的开源实现/</id>
    <published>2018-01-10T03:21:15.000Z</published>
    <updated>2018-01-10T03:30:37.969Z</updated>
    
    <content type="html"><![CDATA[<h3 id="首先安装docker："><a href="#首先安装docker：" class="headerlink" title="首先安装docker："></a>首先安装docker：</h3><p><a href="https://docs.minio.io/" target="_blank" rel="noopener">传送门</a></p><p>docker pull minio/minio</p><p>docker run -d -p 9000:9000 minio/minio server /data</p><a id="more"></a><h3 id="查看启动输出的秘钥："><a href="#查看启动输出的秘钥：" class="headerlink" title="查看启动输出的秘钥："></a>查看启动输出的秘钥：</h3><p>docker logs festive_northcutt</p><p>这2个是用来登陆后台的，保存即可：<br>AccessKey<br>SecretKey</p><h3 id="登陆后台"><a href="#登陆后台" class="headerlink" title="登陆后台"></a>登陆后台</h3><p><a href="http://ip:9000" target="_blank" rel="noopener">http://ip:9000</a></p><h3 id="java后台API"><a href="#java后台API" class="headerlink" title="java后台API"></a>java后台API</h3><p><a href="https://docs.minio.io/docs/java-client-quickstart-guide" target="_blank" rel="noopener">传送门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;首先安装docker：&quot;&gt;&lt;a href=&quot;#首先安装docker：&quot; class=&quot;headerlink&quot; title=&quot;首先安装docker：&quot;&gt;&lt;/a&gt;首先安装docker：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://docs.minio.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;docker pull minio/minio&lt;/p&gt;
&lt;p&gt;docker run -d -p 9000:9000 minio/minio server /data&lt;/p&gt;
    
    </summary>
    
      <category term="分布式文件存储" scheme="https://ciweigg.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="分布式文件存储" scheme="https://ciweigg.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于redis的分布式锁组件，简单方便快捷接入项目</title>
    <link href="https://ciweigg.github.io/2018/01/08/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%BB%84%E4%BB%B6%EF%BC%8C%E7%AE%80%E5%8D%95%E6%96%B9%E4%BE%BF%E5%BF%AB%E6%8D%B7%E6%8E%A5%E5%85%A5%E9%A1%B9%E7%9B%AE/"/>
    <id>https://ciweigg.github.io/2018/01/08/基于redis的分布式锁组件，简单方便快捷接入项目/</id>
    <published>2018-01-08T03:01:00.000Z</published>
    <updated>2018-01-08T03:25:30.732Z</updated>
    
    <content type="html"><![CDATA[<p>使项目拥有分布式锁能力 <a href="https://github.com/kekingcn/spring-boot-klock-starter" target="_blank" rel="noopener">https://github.com/kekingcn/spring-boot-klock-starter</a><br>spring-boot-klock-starter<br>基于redis的分布式锁spring-boot starter组件，使得项目拥有分布式锁能力变得异常简单，支持spring boot，和spirng mvc等spring相关项目<br><a id="more"></a><br>快速开始<br>spring boot项目接入</p><p>1.添加lock starter组件依赖，目前还没上传到公共仓库，需要自己下源码build<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-klock-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>2.application.properties配置redis链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.klock.address=127.0.0.1:6379</span><br></pre></td></tr></table></figure></p><p>3.在需要加分布式锁的方法上，添加注解@Klock，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class TestService &#123;</span><br><span class="line"></span><br><span class="line">    @Klock(waitTime = Long.MAX_VALUE)</span><br><span class="line">    public String getValue(String param) throws Exception &#123;</span><br><span class="line">        if (&quot;sleep&quot;.equals(param)) &#123;//线程休眠或者断点阻塞，达到一直占用锁的测试效果</span><br><span class="line">            Thread.sleep(1000 * 50);</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使项目拥有分布式锁能力 &lt;a href=&quot;https://github.com/kekingcn/spring-boot-klock-starter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kekingcn/spring-boot-klock-starter&lt;/a&gt;&lt;br&gt;spring-boot-klock-starter&lt;br&gt;基于redis的分布式锁spring-boot starter组件，使得项目拥有分布式锁能力变得异常简单，支持spring boot，和spirng mvc等spring相关项目&lt;br&gt;
    
    </summary>
    
      <category term="分布式锁" scheme="https://ciweigg.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    
      <category term="分布式锁" scheme="https://ciweigg.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>next的自动更新背景图片实现方法及效果图展示</title>
    <link href="https://ciweigg.github.io/2018/01/06/next%E7%9A%84%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%95%88%E6%9E%9C%E5%9B%BE%E5%B1%95%E7%A4%BA/"/>
    <id>https://ciweigg.github.io/2018/01/06/next的自动更新背景图片实现方法及效果图展示/</id>
    <published>2018-01-06T14:29:55.000Z</published>
    <updated>2018-01-06T14:31:24.507Z</updated>
    
    <content type="html"><![CDATA[<p>实现的原理<br>修改背景样式<br>修改themes/next/source/css/ _custom/custom.styl文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(https://source.unsplash.com/random/1600x900);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果自己不喜欢这个网址提供的图片做背景，那么修改url()里面的路径即可。repeat、attachment、position就是调整图片的位置，不重复出现、不滚动等等。</p><p>修改不透明度<br>完成这一步其实背景就会自动更换了，但是会出现一个问题，因为next主题的背景是纯透明的，这样子就造成背景图片的影响看不见文字，这对于博客来说肯定不行。</p><p>那么就需要调整背景的不透明度了。同样是修改themes/next/source/css/_custom/custom.styl文件。在后面添加如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.main-inner &#123; </span><br><span class="line">    margin-top: 60px;</span><br><span class="line">    padding: 60px 60px 60px 60px;</span><br><span class="line">    background: #fff;</span><br><span class="line">    opacity: 0.8;</span><br><span class="line">    min-height: 500px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>background: #fff; 白色 opacity: 0.8;不透明度</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现的原理&lt;br&gt;修改背景样式&lt;br&gt;修改themes/next/source/css/ _custom/custom.styl文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;body &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    background:url(https://source.unsplash.com/random/1600x900);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    background-repeat: no-repeat;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    background-attachment:fixed;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    background-position:50% 50%;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://ciweigg.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://ciweigg.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>为Hexo-Next主题设置头部图片</title>
    <link href="https://ciweigg.github.io/2018/01/06/%E4%B8%BAHexo-Next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E5%A4%B4%E9%83%A8%E5%9B%BE%E7%89%87/"/>
    <id>https://ciweigg.github.io/2018/01/06/为Hexo-Next主题设置头部图片/</id>
    <published>2018-01-06T13:56:06.000Z</published>
    <updated>2018-01-06T13:57:34.473Z</updated>
    
    <content type="html"><![CDATA[<p> vi themes/next/source/css/_common/components/header/header.styl<br>// 下面的url()里不一定非要填相对路径，填一个能访问的url即可，比如放在七牛云上的图片<br>.header { background: url(‘../image/background.jpg’); }<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; vi themes/next/source/css/_common/components/header/header.styl&lt;br&gt;// 下面的url()里不一定非要填相对路径，填一个能访问的url即可，比如放在七牛云上的图片&lt;br&gt;.header { background: url(‘../image/background.jpg’); }&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://ciweigg.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://ciweigg.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>修改next主题右侧栏的背景图片</title>
    <link href="https://ciweigg.github.io/2018/01/06/%E4%BF%AE%E6%94%B9next%E4%B8%BB%E9%A2%98%E5%8F%B3%E4%BE%A7%E6%A0%8F%E7%9A%84%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/"/>
    <id>https://ciweigg.github.io/2018/01/06/修改next主题右侧栏的背景图片/</id>
    <published>2018-01-06T11:37:31.000Z</published>
    <updated>2018-01-06T11:41:47.413Z</updated>
    
    <content type="html"><![CDATA[<p>右侧栏都是黑色的看腻了啦<br>那么我们就换一套风格看看，哈哈<br><a id="more"></a></p><h3 id="修改背景图片"><a href="#修改背景图片" class="headerlink" title="修改背景图片"></a>修改背景图片</h3><p>vi themes/next/source/css/_custom/custom.styl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#sidebar &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    width: 0;</span><br><span class="line">    z-index: 1040;</span><br><span class="line">    box-shadow: inset 2px 2px 40px #35644a;</span><br><span class="line">    background: #f5f5f5;</span><br><span class="line">    background: url(http://oisa91ton.bkt.clouddn.com/sidebar.png);</span><br><span class="line">    -webkit-transform: translateZ(0);</span><br><span class="line">&#125;</span><br><span class="line">.site-author-name &#123;</span><br><span class="line">    margin: 5px 0 0;</span><br><span class="line">    text-align: center;</span><br><span class="line">    color: #35644a;</span><br><span class="line">    font-weight: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改a链接的字体颜色"><a href="#修改a链接的字体颜色" class="headerlink" title="修改a链接的字体颜色"></a>修改a链接的字体颜色</h3><p>注释掉以前的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  // color: $grey-dark;</span><br><span class="line">  color: #63b1b5;</span><br><span class="line">  border-bottom-color: $black-light;</span><br><span class="line">  &amp;:hover &#123; color: $gainsboro; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;右侧栏都是黑色的看腻了啦&lt;br&gt;那么我们就换一套风格看看，哈哈&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://ciweigg.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://ciweigg.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>开源微信支付SDK-分分钟解决支付</title>
    <link href="https://ciweigg.github.io/2018/01/06/%E5%BC%80%E6%BA%90%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98SDK-%E5%88%86%E5%88%86%E9%92%9F%E8%A7%A3%E5%86%B3%E6%94%AF%E4%BB%98/"/>
    <id>https://ciweigg.github.io/2018/01/06/开源微信支付SDK-分分钟解决支付/</id>
    <published>2018-01-06T02:45:04.000Z</published>
    <updated>2018-01-06T04:08:38.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>让使用微信支付的朋友最快速度接入微信支付.</p><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>两行代码解决微信支付提供的各种服务, 开箱即用, 可扩展性超强(只需根据服务的上下行协议定义协议类后, 放入工厂即可获取调用结果).<br><a id="more"></a></p><h3 id="最新发布"><a href="#最新发布" class="headerlink" title="最新发布"></a>最新发布</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.arccode&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;wechat-pay-sdk&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="http://oisa91ton.bkt.clouddn.com/wx-pay-sdk.jpg" alt=""></p><h3 id="项目源代码"><a href="#项目源代码" class="headerlink" title="项目源代码"></a>项目源代码</h3><blockquote><p>源码地址 <a href="https://github.com/arccode/wechat-pay-sdk" target="_blank" rel="noopener">https://github.com/arccode/wechat-pay-sdk</a></p></blockquote><h3 id="目前支持的服务及调用示例"><a href="#目前支持的服务及调用示例" class="headerlink" title="目前支持的服务及调用示例"></a>目前支持的服务及调用示例</h3><p>所有服务在单元测试类(WXPayClientTest.java)中均已测试通过, 下行参数response.isSuccess == true表示服务调用成功.</p><h3 id="支付举例"><a href="#支付举例" class="headerlink" title="支付举例"></a>支付举例</h3><h4 id="扫码支付"><a href="#扫码支付" class="headerlink" title="扫码支付"></a>扫码支付</h4><p>官方文档详见: <a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String nonceStr = SDKUtils.genRandomStringByLength(32);</span><br><span class="line">UnifiedOrderRequest request = new UnifiedOrderRequest(&quot;donate-899&quot;,SDKUtils.genOutTradeNo(),1, &quot;192.168.1.1&quot;, asyncNotifyUrl, &quot;NATIVE&quot;, nonceStr);</span><br><span class="line">UnifiedOrderResponse response = wxPayClient.execute(request);</span><br><span class="line">Assert.assertNotNull(response);</span><br><span class="line">LOG.info(JSON.toJSONString(response));</span><br><span class="line">// TODO 开发人员根据 response中的属性值处理业务逻辑, 此处可完美嵌入业务层(小型系统)或服务层(大型系统)</span><br></pre></td></tr></table></figure><h3 id="初始化-sdk"><a href="#初始化-sdk" class="headerlink" title="初始化 sdk"></a>初始化 sdk</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private WXPayClient wxPayClient;</span><br><span class="line"></span><br><span class="line">    private WXPayClient wxPayVIPClient;</span><br><span class="line"></span><br><span class="line">    private String asyncNotifyUrl = &quot;http://domain:port/path&quot;;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line"></span><br><span class="line">        // 以下配置参数根据公司申请的微信支付帐号填写</span><br><span class="line">        String appId = &quot;&quot;;</span><br><span class="line">        String mchId = &quot;&quot;;</span><br><span class="line">        String key = &quot;&quot;;</span><br><span class="line">        String certPwd = &quot;&quot;;</span><br><span class="line">        // 绝对路径, 用于退款和商户支付</span><br><span class="line">        String certPath = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        wxPayClient = new WXPayClient(appId, mchId, key);</span><br><span class="line">        wxPayVIPClient = new WXPayClient(appId, mchId, key, certPwd, certPath);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="公众号支付"><a href="#公众号支付" class="headerlink" title="公众号支付"></a>公众号支付</h4><p>官方文档详见: <a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String nonceStr = SDKUtils.genRandomStringByLength(32);</span><br><span class="line">UnifiedOrderRequest request = new UnifiedOrderRequest(&quot;donate-899&quot;,SDKUtils.genOutTradeNo(),</span><br><span class="line">                1, &quot;192.168.1.1&quot;, asyncNotifyUrl, &quot;JSAPI&quot;, nonceStr);</span><br><span class="line">request.setOpenId(&quot;oKVmeuHht8J0Ni58CSNe474AHA3E&quot;);</span><br><span class="line">UnifiedOrderResponse response = wxPayClient.execute(request);</span><br><span class="line">Assert.assertNotNull(response);</span><br><span class="line">LOG.info(JSON.toJSONString(response));</span><br><span class="line">// TODO 开发人员根据 response中的属性值处理业务逻辑, 此处可完美嵌入业务层(小型系统)或服务层(大型系统)</span><br></pre></td></tr></table></figure><h4 id="APP支付"><a href="#APP支付" class="headerlink" title="APP支付"></a>APP支付</h4><p>官方文档详见: <a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String nonceStr = SDKUtils.genRandomStringByLength(32);</span><br><span class="line">UnifiedOrderRequest request = new UnifiedOrderRequest(&quot;donate-899&quot;,SDKUtils.genOutTradeNo(),</span><br><span class="line">                1, &quot;192.168.1.1&quot;, asyncNotifyUrl, &quot;APP&quot;, nonceStr);</span><br><span class="line">UnifiedOrderResponse response = wxPayClient.execute(request);</span><br><span class="line">Assert.assertNotNull(response);</span><br><span class="line">LOG.info(JSON.toJSONString(response));</span><br><span class="line">// TODO 开发人员根据 response中的属性值处理业务逻辑, 此处可完美嵌入业务层(小型系统)或服务层(大型系统)</span><br></pre></td></tr></table></figure><h4 id="商家支付"><a href="#商家支付" class="headerlink" title="商家支付"></a>商家支付</h4><p>官方文档详见: <a href="https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_2" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_2</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String nonceStr = SDKUtils.genRandomStringByLength(32);</span><br><span class="line">String customerOpenId = &quot;oKVmeuHht8J0Ni58CSNe474AHA3E&quot;;</span><br><span class="line">MchPayRequest mchPayRequest = new MchPayRequest(SDKUtils.genOutTradeNo(),</span><br><span class="line">                customerOpenId, &quot;NO_CHECK&quot;, 100, &quot;xxxx年xx月结算&quot;, &quot;192.168.1.1&quot;, nonceStr);</span><br><span class="line">MchPayResponse response = wxPayVIPClient.execute(mchPayRequest);</span><br><span class="line">Assert.assertNotNull(response);</span><br><span class="line">LOG.info(JSON.toJSONString(response));</span><br><span class="line">// TODO 开发人员根据 response中的属性值处理业务逻辑, 此处可完美嵌入业务层(小型系统)或服务层(大型系统)</span><br></pre></td></tr></table></figure><h4 id="退款"><a href="#退款" class="headerlink" title="退款"></a>退款</h4><p>官方文档详见: <a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_4&amp;index=6" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_4&amp;index=6</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String nonceStr = SDKUtils.genRandomStringByLength(32);</span><br><span class="line">RefundRequest request = new RefundRequest(&quot;T15121416014891124211768&quot;,</span><br><span class="line">                SDKUtils.genOutRefundNo(), 1, 1, &quot;112102020&quot;, nonceStr);</span><br><span class="line">RefundResponse response = wxPayVIPClient.execute(request);</span><br><span class="line">Assert.assertNotNull(response);</span><br><span class="line">LOG.info(JSON.toJSONString(response));</span><br><span class="line">// TODO 开发人员根据 response中的属性值处理业务逻辑, 此处可完美嵌入业务层(小型系统)或服务层(大型系统)</span><br></pre></td></tr></table></figure><h4 id="支付异步通知解析"><a href="#支付异步通知解析" class="headerlink" title="支付异步通知解析"></a>支付异步通知解析</h4><p>官方文档详见: <a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_7" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_7</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String notifyTxt = &quot;&lt;xml&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;appid&gt;&lt;![CDATA[wx2421b1c4370eccdcd]]&gt;&lt;/appid&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;attach&gt;&lt;![CDATA[支付测试]]&gt;&lt;/attach&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;bank_type&gt;&lt;![CDATA[CFT]]&gt;&lt;/bank_type&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;fee_type&gt;&lt;![CDATA[CNY]]&gt;&lt;/fee_type&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;is_subscribe&gt;&lt;![CDATA[Y]]&gt;&lt;/is_subscribe&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;mch_id&gt;&lt;![CDATA[10000100]]&gt;&lt;/mch_id&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;nonce_str&gt;&lt;![CDATA[5d2b6c2a8db53831f7eda20af46e531c]]&gt;&lt;/nonce_str&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;openid&gt;&lt;![CDATA[oUpF8uMEb4qRXf22hE3X68TekukE]]&gt;&lt;/openid&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;out_trade_no&gt;&lt;![CDATA[1409811653]]&gt;&lt;/out_trade_no&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;result_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/result_code&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;sign&gt;&lt;![CDATA[B552ED6B279343CB493C5DD0D78AB241]]&gt;&lt;/sign&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;sub_mch_id&gt;&lt;![CDATA[10000100]]&gt;&lt;/sub_mch_id&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;time_end&gt;&lt;![CDATA[20140903131540]]&gt;&lt;/time_end&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;total_fee&gt;1&lt;/total_fee&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;trade_type&gt;&lt;![CDATA[JSAPI]]&gt;&lt;/trade_type&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;transaction_id&gt;&lt;![CDATA[1004400740201409030005092168]]&gt;&lt;/transaction_id&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;/xml&gt;&quot;;</span><br><span class="line">PayNotifyResponse response = wxPayClient.parseNotify(notifyTxt, PayNotifyResponse.class);</span><br><span class="line">Assert.assertNotNull(response);</span><br><span class="line">LOG.info(JSON.toJSONString(response));</span><br><span class="line">// TODO 开发人员根据 response中的属性值处理业务逻辑, 此处可完美嵌入业务层(小型系统)或服务层(大型系统)</span><br></pre></td></tr></table></figure><h4 id="刷卡支付"><a href="#刷卡支付" class="headerlink" title="刷卡支付"></a>刷卡支付</h4><p>官方文档详见: <a href="https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=9_10&amp;index=1" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/micropay.php?chapter=9_10&amp;index=1</a></p><p>目前未使用, 待续……</p><p>扩展<br>该SDK设计了一个服务工厂, 该工厂中包含HTTP执行器/返回数据解析方式(json/xml)/入参数据格式(json/xml)构造等, 开发人员需要增加服务仅需要根据服务协议文档编写上下行协议, 并在协议中指明API接口和返回数据类型, 再将上行协议放入工厂中执行即可; 可参考已完成的服务协议进行扩展编写.</p><p>本文出处: <a href="http://www.arccode.net/wechat-pay-sdk-out-of-the-box.html" target="_blank" rel="noopener">http://www.arccode.net/wechat-pay-sdk-out-of-the-box.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;让使用微信支付的朋友最快速度接入微信支付.&lt;/p&gt;
&lt;h3 id=&quot;核心&quot;&gt;&lt;a href=&quot;#核心&quot; class=&quot;headerlink&quot; title=&quot;核心&quot;&gt;&lt;/a&gt;核心&lt;/h3&gt;&lt;p&gt;两行代码解决微信支付提供的各种服务, 开箱即用, 可扩展性超强(只需根据服务的上下行协议定义协议类后, 放入工厂即可获取调用结果).&lt;br&gt;
    
    </summary>
    
      <category term="微信支付" scheme="https://ciweigg.github.io/categories/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"/>
    
    
      <category term="微信支付" scheme="https://ciweigg.github.io/tags/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>Next主题小屏幕下保留侧边栏</title>
    <link href="https://ciweigg.github.io/2018/01/05/Next%E4%B8%BB%E9%A2%98%E5%B0%8F%E5%B1%8F%E5%B9%95%E4%B8%8B%E4%BF%9D%E7%95%99%E4%BE%A7%E8%BE%B9%E6%A0%8F/"/>
    <id>https://ciweigg.github.io/2018/01/05/Next主题小屏幕下保留侧边栏/</id>
    <published>2018-01-05T14:03:49.000Z</published>
    <updated>2018-01-06T05:38:35.235Z</updated>
    
    <content type="html"><![CDATA[<p>当然，iissnan最初决定在小屏幕上block掉侧栏是有原因的，这个副作用在这番改动之后也依然存在：极端尺寸设备上会出现侧栏完全覆盖主体甚至显示不全。改动的好处也很明显，页面内容展示更完全。毕竟H5普及之后，小型网站越来越不需要考虑兼容性问题，权衡利弊，这样做还是有意义的。<br><a id="more"></a><br>恢复侧栏开关(适用于手机)</p><p>这一步参考上面提到的那篇教程。</p><h3 id="启用侧边栏有两种方法："><a href="#启用侧边栏有两种方法：" class="headerlink" title="启用侧边栏有两种方法："></a>启用侧边栏有两种方法：</h3><h4 id="1-针对next主题："><a href="#1-针对next主题：" class="headerlink" title="1.针对next主题："></a>1.针对next主题：</h4><p>默认已经实现了，改成true就行<br>themes/next/_config.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Enable sidebar on narrow view (only for Muse | Mist).</span><br><span class="line">onmobile: true</span><br></pre></td></tr></table></figure></p><h4 id="2-针对其他主题"><a href="#2-针对其他主题" class="headerlink" title="2.针对其他主题"></a>2.针对其他主题</h4><p>打开source/css/_common/components/sidebar/sidebar.styl，删掉或注释掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*+tablet() &#123;</span><br><span class="line">    display: none !important;</span><br><span class="line">&#125;</span><br><span class="line">+mobile() &#123;</span><br><span class="line">  display: none !important;</span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure><p>启用按钮<br>首先是侧边栏开关，打开source/css/_common/components/sidebar/sidebar-toggle.styl，在.sidebar-toggle下修改</p><p>注释掉里面多余的代码留下和下面一样的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+tablet() &#123;</span><br><span class="line">  right: 20px;</span><br><span class="line">  opacity: 0.8;</span><br><span class="line">&#125;</span><br><span class="line">+mobile() &#123;</span><br><span class="line">  right: 20px;</span><br><span class="line">  opacity: 0.8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里在解除隐藏的同时微调了显示效果。<br>然后是back-to-top按钮，类似的，打开source/css/_common/components/back-to-top.styl，在.back-to-top下修改</p><p>注释掉里面多余的代码留下和下面一样的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+tablet() &#123;</span><br><span class="line">  right: 20px;</span><br><span class="line">  opacity: 0.8;</span><br><span class="line">&#125;</span><br><span class="line">+mobile() &#123;</span><br><span class="line">  right: 20px;</span><br><span class="line">  opacity: 0.8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里已经实现了目标，但触摸屏上关闭侧边栏最方便的还是点击外围区域或者滑动，这里选择前一种实现方式。</p><p>增加关闭侧栏的方式<br>策略很简单，增加一个覆盖层与侧栏联动，点击覆盖层触发侧栏开关按钮的点击事件。首先修改layout/_macro/sidebar.swig，增加sidebar-dimmer层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;aside id=&quot;sidebar&quot; class=&quot;sidebar&quot;&gt;</span><br><span class="line">  + &lt;div id=&quot;sidebar-dimmer&quot;&gt;&lt;/div&gt;</span><br><span class="line">  + &lt;div class=&quot;sidebar-inner&quot;&gt;</span><br></pre></td></tr></table></figure><p>定义sidebar-dimmer的样式，这里我把代码放在source/css/_common/components/sidebar/sidebar-toggle.styl中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.sidebar-active #sidebar-dimmer &#123;</span><br><span class="line">  opacity: .7;</span><br><span class="line">  -webkit-transform: translateX(-150%);</span><br><span class="line">  transform: translateX(-150%);</span><br><span class="line">  transition: opacity .2s;</span><br><span class="line">&#125;</span><br><span class="line">#sidebar-dimmer &#123;</span><br><span class="line">  display: none;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 100%;</span><br><span class="line">  width: 200%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  background: #000;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  transition: opacity .2s,transform 0s .2s;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    display: block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dimmer宽度倍率x和左移倍率y需要满足y=1+1/x的关系才能在侧栏展开时与dimmer右边界形成良好的衔接，所以需要根据mobile view最大宽度调整x的值。这里图省事把x设定为200%，y自然是150%了。<br>最后添加触发条件，修改source/js/src/motion.js<br>对比代码是否一样就行了，可能主题里添加过了</p><pre><code>var sidebarToggleMotion = {  toggleEl: $(&apos;.sidebar-toggle&apos;),  dimmerEl: $(&apos;#sidebar-dimmer&apos;),  //init  sidebarEl: $(&apos;.sidebar&apos;),  isSidebarVisible: false,  init: function () {    this.toggleEl.on(&apos;click&apos;, this.clickHandler.bind(this));    this.dimmerEl.on(&apos;click&apos;, this.clickHandler.bind(this));   //binding    this.toggleEl.on(&apos;mouseenter&apos;, this.mouseEnterHandler.bind(this));    this.toggleEl.on(&apos;mouseleave&apos;, this.mouseLeaveHandler.bind(this));</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当然，iissnan最初决定在小屏幕上block掉侧栏是有原因的，这个副作用在这番改动之后也依然存在：极端尺寸设备上会出现侧栏完全覆盖主体甚至显示不全。改动的好处也很明显，页面内容展示更完全。毕竟H5普及之后，小型网站越来越不需要考虑兼容性问题，权衡利弊，这样做还是有意义的。&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://ciweigg.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://ciweigg.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
